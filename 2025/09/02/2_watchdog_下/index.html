

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#37AFE1">
  <meta name="author" content="CubeHuang">
  <meta name="keywords" content="">
  
    <meta name="description" content="[TOC]回顾：从上篇文章中，我们主要从问题角度描述了我们system_server中watchdog的原理，粒度是很粗糙的。简单可以概括为下面三点：  关键服务对象锁不能被某线程异常长时间占用——问题1 系统关键线程不能长时间只执行一个单一逻辑，避免后面的消息阻塞——问题2 当监测到上面异常时，我们根据异常时间长短来决策是否重启手机，并且根据异常时间我们针对性的输出日志，让程序员根据log解决异">
<meta property="og:type" content="article">
<meta property="og:title" content="Android system_server中watchdog机制介绍（下）">
<meta property="og:url" content="http://example.com/2025/09/02/2_watchdog_%E4%B8%8B/">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC]回顾：从上篇文章中，我们主要从问题角度描述了我们system_server中watchdog的原理，粒度是很粗糙的。简单可以概括为下面三点：  关键服务对象锁不能被某线程异常长时间占用——问题1 系统关键线程不能长时间只执行一个单一逻辑，避免后面的消息阻塞——问题2 当监测到上面异常时，我们根据异常时间长短来决策是否重启手机，并且根据异常时间我们针对性的输出日志，让程序员根据log解决异">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_6_%E9%A1%B5.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%82%E4%B9%B1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/binder_montor.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E6%9D%82%E4%B9%B1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E9%87%8D%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/dump_%E8%BF%9B%E7%A8%8B.jpg">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/kernel_D_log.jpg">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC10_%E9%A1%B5.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC11_%E9%A1%B5.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/log_red.PNG">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/wait_binder_target.jpg">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/system_server%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%AD%BB%E9%94%81.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/system_server_to_phone_2.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/system_server_to_phone_1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/audio00.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/audio0.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/audio1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/same_backtrace.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/3_deadlock_1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/3_deadlock_3.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/3_deadlock_2.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_1.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_2.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_3.png">
<meta property="og:image" content="http://example.com/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_4.png">
<meta property="article:published_time" content="2025-09-02T12:46:25.000Z">
<meta property="article:modified_time" content="2025-09-20T12:46:25.000Z">
<meta property="article:author" content="CubeHuang">
<meta property="article:tag" content="SWT">
<meta property="article:tag" content="系统概念原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_6_%E9%A1%B5.png">
  
  
  
  <title>Android system_server中watchdog机制介绍（下） - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CubeHuang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/main_wallpapers/wp_1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Android system_server中watchdog机制介绍（下）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-02 20:46" pubdate>
          2025年9月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android system_server中watchdog机制介绍（下）</h1>
            
            
              <div class="markdown-body">
                
                <p>[TOC]<br><strong>回顾</strong>：<br>从上篇文章中，我们主要从问题角度描述了我们<code>system_server</code>中<code>watchdog</code>的原理，粒度是很粗糙的。简单可以概括为下面三点：</p>
<ul>
<li><strong>关键服务</strong>对象锁不能被某线程异常长时间占用——<strong>问题1</strong></li>
<li><strong>系统关键线程</strong>不能长时间只执行一个单一逻辑，避免后面的消息阻塞——<strong>问题2</strong></li>
<li>当监测到上面异常时，我们根据异常时间长短来决策是否重启手机，并且根据异常时间我们针对性的输出日志，让程序员根据log解决异常。</li>
</ul>
<p>本篇文章，我们再进一步将上述三点内容，进一步细化以及列举一些常见的案例。</p>
<h2 id="1-关键线程异常"><a href="#1-关键线程异常" class="headerlink" title="1. 关键线程异常"></a>1. 关键线程异常</h2><p><code>system_server</code>中的众多模块功能，离不开<code>system_server</code>中各个线程的执行，<code>system_server</code>中线程组成如下：</p>
<p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_6_%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="dce0c8d48bb5f707c303f5c305476bad.png"></p>
<p>如上虚线框内的线程中我们主要关注<strong>关键线程</strong>（<strong>绿色部分线程</strong>），他们的职能如同名字一样，服务模块如果处理例如io，显示等职能事务，可以将事务专门交给这些关键线程。而不是将所有事务都交给模块线程来处理。这些关键线程就像我们生活中的公共交通工具火车、地铁、公交一样在system_server中扮演着重要的作用。</p>
<h3 id="1-1-关键线程具体有哪些"><a href="#1-1-关键线程具体有哪些" class="headerlink" title="1.1 关键线程具体有哪些?"></a>1.1 关键线程具体有哪些?</h3><p>我们通过系统源码查看可以查看，我们主要监测着下面表格中这些线程：</p>
<table>
<thead>
<tr>
<th>关键线程名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>主线程（优先级：-2）</td>
</tr>
<tr>
<td>android.ui</td>
<td>处理系统进程UI相关的事务（优先级：-2）</td>
</tr>
<tr>
<td>android.io</td>
<td>文件读写相关的事务（优先级：0）</td>
</tr>
<tr>
<td>android.display</td>
<td>处理系统显示事务相关（优先级：-3）</td>
</tr>
<tr>
<td>android.anim</td>
<td>处理系统动画相关的事务（优先级：-4）</td>
</tr>
<tr>
<td>android.anim.lf</td>
<td>处理系统动画相关和Vsync相关（优先级：-4）</td>
</tr>
<tr>
<td>android.fg</td>
<td>前台公共线程（优先级：0）</td>
</tr>
<tr>
<td>android.bg</td>
<td>后台公共线程（优先级：10）</td>
</tr>
<tr>
<td>watchdog.monitor</td>
<td>用来check关键服务锁情况（优先级：0）</td>
</tr>
<tr>
<td>服务模块线程</td>
<td>服务模块逻辑线程</td>
</tr>
<tr>
<td>ActivityManager:starter</td>
<td>AMS进程创建相关线程</td>
</tr>
<tr>
<td>RollbackManagerServiceHandler</td>
<td>回滚相关线程</td>
</tr>
<tr>
<td>PermissionManager</td>
<td>权限管理线程</td>
</tr>
<tr>
<td>PowerManagerService</td>
<td>电量&#x2F;源管理服务线程</td>
</tr>
<tr>
<td>PackageManagerService</td>
<td>包管理服务线程</td>
</tr>
<tr>
<td>可根据问题自主添加</td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2-watchdog中添加线程监控方法："><a href="#1-2-watchdog中添加线程监控方法：" class="headerlink" title="1.2 watchdog中添加线程监控方法："></a>1.2 watchdog中添加线程监控方法：</h3><p>模块代码中使用<br><code>Watchdog.getInstance().addThread(..)</code></p>
<h2 id="2-关键服务异常"><a href="#2-关键服务异常" class="headerlink" title="2. 关键服务异常"></a>2. 关键服务异常</h2><p>具体的监测服务如下，100多个服务为什么选择这几个服务呢？这里我们不得而知，但是可想而知的是，随之系统的迭代以及项目的不断开发，系统中会遇到各种各样的问题，会根据问题的分类，增加新的监测模块。</p>
<ul>
<li>StorageManagerService</li>
<li>MediaProjectionManagerService</li>
<li>MediaRouterService</li>
<li>InputManagerService</li>
<li>PowerManagerService</li>
<li>WindowManagerService</li>
<li>ActivityManagerService</li>
<li>BatteryStatsService</li>
<li>BinderThreadMonitor(补充)<br>目前系统中监测的服务为上面的这些服务，当然如果我们往system_server中添加新的重要服务，我们也可以将该服务添加到监控中去。</li>
</ul>
<h3 id="2-1-监控关键服务的方法："><a href="#2-1-监控关键服务的方法：" class="headerlink" title="2.1 监控关键服务的方法："></a>2.1 监控关键服务的方法：</h3><p>我们添加重要的模块&#x2F;服务到<code>system_server</code>中，可以通过以下方法添加到<code>watchdog</code>监控中去。</p>
<ol>
<li>实现<code>Watchdog.Monitor</code>接口中的 <code>monitor()</code> 方法，方法中实现本模块认为异常的监测逻辑。</li>
<li>模块代码调用  <code>Watchdog.getInstance().addMonitor(this)</code>。</li>
</ol>
<h3 id="2-2-Binder线程监测补充"><a href="#2-2-Binder线程监测补充" class="headerlink" title="2.2 Binder线程监测补充"></a>2.2 Binder线程监测补充</h3><p>在<code>system_server</code>中<code>Binder线程</code>（下图橙色部分）作为应用进程和<code>system_server</code>交互的桥梁，并且<code>system_server</code>作为整个Android系统中Binder线程数量最多的进程，<strong>Binder线程资源多并且十分重要</strong>。</p>
<p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%82%E4%B9%B1.png" srcset="/img/loading.gif" lazyload alt="052ad1ef0eee091636769b3f2f1e0166.png"></p>
<p><strong>问题</strong>：<u>会不会出现所有Binder线程都阻塞到某个逻辑，导致其他应用进程访问system_server却没有Binder线程处理事务？</u></p>
<blockquote>
<p>是会这样的，所有要对这种异常情况进行监控。我们就可以使用上面的 2.1 中方法添加到watchdog监控中去。</p>
</blockquote>
<p>我们可以根据2.1的步骤可以看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br>   <span class="hljs-number">1.</span> 现Watchdog.Monitor接口中的 `monitor()` 方法，方法中实现本模块认为异常的监测逻辑<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderThreadMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>           Binder.blockUntilThreadAvailable();<br>       &#125;<br>   &#125;<br><span class="hljs-number">2.</span> 模块代码调用  `Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>)`<br>addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>())<br></code></pre></td></tr></table></figure>
<p> <code>monitor</code>方法具体实现：<br> 如果所有Binder线程都在阻塞（正常来说不可能所有Binder线程都长时间阻塞的），那么打印异常日志并且一直等待阻塞，阻塞将会被<code>watchdog</code>监测到，持续异常将触发重启。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> IPCThreadState::blockUntilThreadAvailable()<br>&#123;<br>    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);<br>    mProcess-&gt;mWaitingForThreads++;<br>    <span class="hljs-keyword">while</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads) &#123;<br>        ALOGW(<span class="hljs-string">&quot;Waiting for thread to be free. mExecutingThreadsCount=%lu mMaxThreads=%lu\n&quot;</span>,<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mExecutingThreadsCount),<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mMaxThreads));<br>        pthread_cond_wait(&amp;mProcess-&gt;mThreadCountDecrement, &amp;mProcess-&gt;mThreadCountLock);<br>    &#125;<br>    mProcess-&gt;mWaitingForThreads--;<br>    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="3-异常监测的衡量"><a href="#3-异常监测的衡量" class="headerlink" title="3. 异常监测的衡量"></a>3. 异常监测的衡量</h2><p>在对于问题1、2的详细阐述后我们可以得到下面这个图片：<br><img src="/blog_imgs/2_watchdog_2/binder_montor.png" srcset="/img/loading.gif" lazyload alt="6422d9568c21b454540ae3349dfc1487.png"></p>
<p><code>watchdog线程</code>给各个关键线程发送一条消息，各个关键线程在规定时间内处理完该消息，那么<code>watchdog线程</code>认为系统正常。如果规定时间内无法处理完该消息，那么认为系统异常。</p>
<p><strong>问题</strong>： <u>那么这个规定时间是多少呢？</u></p>
<blockquote>
<p>答案是：30s，每隔30s发送一条消息，如果超过30s各个关键线程没有处理完消息，系统将会打印对应的日志。</p>
</blockquote>
<p><strong>问题</strong>：假如system_server异常后不能长时间卡住，用户无法忍受，如何处理？</p>
<blockquote>
<p>超过第二个30s（即一分钟），消息还未被处理完成，重启系统，让用户能恢复手机使用。</p>
</blockquote>
<p>当然有人会问为什么是30s？</p>
<blockquote>
<p>这里无从考证，个人猜测一方面可能是用户的体验不能卡住太久，另一方面是时间一分钟&#x3D;60s&#x3D;两个30s，便于编码。</p>
</blockquote>
<p>经过第三点的补充后我们得到了下面完整的框架图片：<br>![a6625f96485e3a8391ecba9a419a7ec5.png](&#x2F;blog_imgs&#x2F;2_watchdog_2&#x2F;watchdog_1-第_5 页.png)</p>
<p>图片解读:</p>
<ol>
<li><code>system_server</code>中watchdog线程每隔30s给各个<strong>关键线程</strong>发送一条消息，消息内容：设置一个<strong>标志位</strong>，代表处理完成。</li>
<li>Binder线程是否空余，以及各个关键服务的对象锁是否被异常持有，由<code>watchdog.monitor线程</code>进行检测，检测方式：逐一调用各个模块实现的<code>monitor方法</code>即可，<code>monitor接口</code>是否阻塞则决定各个模块是否异常。</li>
<li>如果&gt;<strong>30s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中。</li>
<li>如果&gt;<strong>60s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中，并且<strong>重启system_server进程</strong>。</li>
</ol>
<h2 id="4-日志的输出"><a href="#4-日志的输出" class="headerlink" title="4. 日志的输出"></a>4. 日志的输出</h2><p>在超时30s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条log：<br><code>07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG</code><br>在在超时60s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条相似的log：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure>
<p>光凭借这点log我们程序员可无法准确的定位出问题，我们的目的只有一个:输出log要能让程序员定位到问题。</p>
<h3 id="4-1-问题：-我们还需要输出哪些log？"><a href="#4-1-问题：-我们还需要输出哪些log？" class="headerlink" title="4.1 问题： 我们还需要输出哪些log？"></a>4.1 问题： 我们还需要输出哪些log？</h3><p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E6%9D%82%E4%B9%B1.png" srcset="/img/loading.gif" lazyload alt="d098fbc833faeda9532b15223a5b1e37.png"></p>
<h4 id="4-1-1-system-server-自身堆栈信息"><a href="#4-1-1-system-server-自身堆栈信息" class="headerlink" title="4.1.1 system_server 自身堆栈信息"></a>4.1.1 system_server 自身堆栈信息</h4><p><strong>system_server</strong> 中存在的问题很可能就是上图的情况，可能还比上图更为杂乱，各个线程间相互等待，相互等锁等等，我们最直观能看到问题点就是将<code>system_server</code>中各个的线程的堆栈dump出来，通过堆栈找出问题点。</p>
<ul>
<li><strong>输出日志</strong>：dump出 <strong>system_server中各个线程的堆栈信息</strong></li>
</ul>
<h4 id="4-1-2-system-server-关联进程堆栈信息"><a href="#4-1-2-system-server-关联进程堆栈信息" class="headerlink" title="4.1.2 system_server 关联进程堆栈信息"></a>4.1.2 system_server 关联进程堆栈信息</h4><p><img src="/blog_imgs/2_watchdog_2/%E9%87%8D%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E.png" srcset="/img/loading.gif" lazyload alt="2cf19497de20cf3bb9abca5d6f585923.png"></p>
<p>对于<code>system_server</code>进程而言，除了自身进程之外，<code>system_server</code>进程还会和其他进程交互，这里尤其指的是服务模块进程，万一我们<code>system_server</code>中的线程阻塞在这些其他进程上怎么办？</p>
<blockquote>
<p>所以我们需要dump出和<code>system_server</code>交互频繁的这些服务进程的线程堆栈。native 层服务进程，以及hal层服务进程，以及Java层的匿名Binder服务进程等等：</p>
</blockquote>
<ul>
<li><p>例如：<strong>native&#x2F;hal层服务进程</strong> : <code>SF</code>、<code>Netd</code>、<code>audio模块</code>、<code>sensor模块</code>等。</p>
</li>
<li><p>例如：<strong>Java层匿名Binder服务进程</strong>: <code>com.android.phone</code>、<code>com.google.android.providers.media.module</code>等。</p>
</li>
<li><p><strong>输出日志</strong>： dump出<strong>和system_server交互频繁的服务进程的线程堆栈</strong></p>
</li>
</ul>
<p>我们能从watchdog代码中看到下面的这些需要dump的进程的信息：<br><img src="/blog_imgs/2_watchdog_2/dump_%E8%BF%9B%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="3f81357d1ea62e19f0c7346a7826a61c.jpeg"><br>这里的信息也是随着项目产品不断迭代，出现问题后，不断往上添加的一个过程。例如你在项目中遇到问题指向某个服务进程并且排查问题时候这个服务进程没有被dump出来，你就可以在上面代码中添加。</p>
<h4 id="4-1-3-kernel异常进程信息"><a href="#4-1-3-kernel异常进程信息" class="headerlink" title="4.1.3 kernel异常进程信息"></a>4.1.3 kernel异常进程信息</h4><p>上面我们主要dump的都是用户态的堆栈信息，但是我们还需要想一个点——问题：<strong>内核模块会不会异常</strong>？<br>会的，我们还是从上上个图中来看，底层的一些重要的服务是依赖于kernel中的一些驱动模块的，除了我们常知道内存、cpu、gpu等还有tp&#x2F;屏显&#x2F;sensor等等一些内核模块，也是会出现异常的进而间接会影响到system_server中的模块。所以我们需要dump出内核模块中异常的堆栈信息。</p>
<p><strong>但是怎么判断内核异常模块进程呢</strong>？</p>
<ul>
<li><code>TASK_UNINTERRUPTIBLE</code>：不可中断休眠，长时间的不可中断休眠状态的线程则很容易出现阻塞问题，进而引发SWT问题</li>
<li>进程状态：<strong>D状态</strong></li>
</ul>
<p><strong>不可中断休眠状态进程的特点</strong>：</p>
<ul>
<li>不接受中断（软&#x2F;硬）signal信号等，只等待想等待的事情完成。</li>
<li>常见场景：有 Swap 读数据、信号量机制、mutex 锁、内存慢路径回收等场景。<br>(参考：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE">https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE</a>)</li>
</ul>
<p><strong>dump方式</strong>：<code>echo w &gt; /proc/sysrq-trigger</code><br>类似：<br><img src="/blog_imgs/2_watchdog_2/kernel_D_log.jpg" srcset="/img/loading.gif" lazyload alt="a1d88ec87f02b6fef4adbc78c8c06aee.jpeg"></p>
<h4 id="4-1-4-小结"><a href="#4-1-4-小结" class="headerlink" title="4.1.4 小结"></a>4.1.4 小结</h4><p>上述就是我们需要dump出来的log信息，但是还缺一样log，在Android系统中服务进程间通信方式使用的的是Binder通信，所以我们要知道A进程中的A1线程和B进程中B1线程是否存在通信的关系，我们需要dump Binder通信的log信息。<br>位置：<code>/dev/binderfs/binder_logs/transactions</code>或者<code>/sys/kernel/debug/binder</code>目录下。<br>所需的日志如下：</p>
<ul>
<li><strong>system_server自身线程堆栈信息</strong></li>
<li><strong>与system_server关联其他服务端进程信息</strong></li>
<li><strong>kernel异常状态进程堆栈信息</strong></li>
<li><strong>Binder进程间交互信息</strong></li>
</ul>
<p>如下图：<br><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC10_%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="a8b702225974fac1cf9d81af66fe25cf.png"></p>
<h3 id="4-2-日志解读"><a href="#4-2-日志解读" class="headerlink" title="4.2 日志解读"></a>4.2 日志解读</h3><p>我们在分析SWT 问题时候，通常来说是按照下面的log进行分析的：</p>
<ul>
<li><strong>红色部分日志</strong>：先从events system 这些log中确定system_server中遭遇了哪类问题？是<strong>问题一</strong>还是<strong>问题二</strong>。</li>
<li><strong>蓝色部分日志</strong>：进而从dump的堆栈信息（不管是kernel还是用户态其他进程）分析异常模块。</li>
<li><strong>绿色日志</strong>：Binder交互信息作为辅助，借助交互信息可以得知各个阻塞模块的联系。</li>
</ul>
<p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC11_%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt="e955d2a63ccbd59a8f085e159a603a35.png"></p>
<h3 id="4-2-1-events-system-日志解读"><a href="#4-2-1-events-system-日志解读" class="headerlink" title="4.2.1 events system 日志解读"></a>4.2.1 events system 日志解读</h3><p><code>events log</code>中下面两条log分别是在异常大于30s，大于60s两个时间节点输出</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG<br>07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure>
<p><strong>第二条log</strong>会直接指出出现的异常是那种类型，也就是我们之前分析的问题一或者问题二，当前的log表明，<code>watchdog.monitor</code> 线程想要去获取<code>ActivityManagerService</code>的对象锁，很遗憾超过60s都没有获取到，说明问题点是：AMS这个模块中的对象锁被某个线程异常长时间持有，有可能是线程逻辑阻塞，也有可能是线程死锁。</p>
<p>上述的第二条log信息是比较重要的，直接为为我们指明了排查方向，第二条log还有其他好几种形式，但是log的模板基本上只有两种，因为我们要检测的问题基本上就两个：</p>
<ul>
<li><code>Blocked in handler on</code> 关键线程名 <code>thread</code> (关键线程)——<strong>问题2</strong></li>
<li><code>Blocked in monitor</code> 关键服务对象 <code>on monitor thread (watchdog.monitor)</code>——<strong>问题1</strong></li>
</ul>
<table>
<thead>
<tr>
<th>关键线程名</th>
<th>关键服务对象</th>
</tr>
</thead>
<tbody><tr>
<td>线程名</td>
<td>关键服务对象</td>
</tr>
<tr>
<td>main</td>
<td>StorageManagerService</td>
</tr>
<tr>
<td>android.ui</td>
<td>MediaRouterService</td>
</tr>
<tr>
<td>android.io</td>
<td>InputManagerService</td>
</tr>
<tr>
<td>android.display</td>
<td>WindowManagerService</td>
</tr>
<tr>
<td>android.anim</td>
<td>ActivityManagerService</td>
</tr>
<tr>
<td>android.anim.lf</td>
<td>BatteryStatsService</td>
</tr>
<tr>
<td>android.fg</td>
<td>BinderThreadMonitor</td>
</tr>
<tr>
<td>android.bg</td>
<td>…</td>
</tr>
<tr>
<td>watchdog.monitor</td>
<td></td>
</tr>
<tr>
<td>ActivityManager:starter，RollbackManagerServiceHandler，PermissionManager，PowerManagerService，PackageManagerService</td>
<td></td>
</tr>
</tbody></table>
<p>打印的log只是上面表格中列出来的一种或者多种组合。<br>例如：下面的日志中所有问题都囊括了</p>
<ul>
<li>关键服务AMS服务的对象锁被异常持有。</li>
<li>关键线程 <code>android.fg</code>、<code>main</code>、<code>android.io</code>、<code>android.display</code>、<code>android.anim</code>阻塞</li>
<li>没有空闲Binder线程。</li>
</ul>
<p><img src="/blog_imgs/2_watchdog_2/log_red.PNG" srcset="/img/loading.gif" lazyload alt="d1c8f2a81b6c7825f864369bc3ec638d.png"></p>
<p>排查的时候我们使用一条线索往下排查就行，往往是各个问题相互杂糅相互影响的（目前没有遇到过几个问题点是分开的这种问题）。</p>
<p>在system log 中会打印下面这样的log：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br>W Watchdog: watchdog.monitor annotated stack trace:<br>W Watchdog:     at com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>W Watchdog:     - waiting to lock &lt;0x0bcefae9&gt; (a com.android.server.am.ActivityManagerService)<br>W Watchdog:     at com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<br>W Watchdog:     at android.os.Handler.handleCallback(Handler.java:959)<br>W Watchdog:     at android.os.Handler.dispatchMessage(Handler.java:100)<br>W Watchdog:     at android.os.Looper.loopOnce(Looper.java:232)<br>W Watchdog:     at android.os.Looper.loop(Looper.java:317)<br>W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:85)<br>W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:46)<br>W Watchdog: *** GOODBYE!<br></code></pre></td></tr></table></figure>
<p>log会打印出阻塞的关键线程的堆栈信息（有时候受负载影响可能不准，但是可以作为参考），如上能看到AMS对象锁的地址，会打印出<strong>GOODBYE</strong>关键字。<br>除此之外在system log中还会打印出现SWT先后dump两次trace文件的名称，给我们指明下一步排查的文件的位置（这里比较关键，有的伙伴分析问题直接就随便点开一个anr_xx就开始排查，可能看的trace文件都不对，这会影响问题的分析结果）。<br><code>ActivityManager: Dumping to /data/anr/anr_2025-07-26-09-32-16-000</code> （可以在system log中检索<code>Dumping to</code> 这个关键字，anr问题的分析也是如此）。</p>
<h3 id="4-2-2-trace-文件概要解读"><a href="#4-2-2-trace-文件概要解读" class="headerlink" title="4.2.2 trace 文件概要解读"></a>4.2.2 trace 文件概要解读</h3><p><code>SWT</code>以及<code>ANR</code>问题都会将进程的线程堆栈信息dump出来，文件保存到<code>data/anr</code>目录下面。区别在于SWT问题trace文件dump的进程较多，ANR问题dump的trace文件进程较少（通常只是ANR进程本身以及system_server进程）。<br>通常来说<strong>trace文件</strong>主要包括以下几部分内容：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Subject: Blocked in monitor com.android.server.am.ActivityManagerService on monitor thread (watchdog.monitor) <span class="hljs-keyword">for</span> <span class="hljs-number">15</span>s<br>--- CriticalEventLog ---<br>capacity: <span class="hljs-number">20</span><br>timestamp_ms: <span class="hljs-number">1753493489805</span><br>window_ms: <span class="hljs-number">300000</span><br><br>----- dumping <span class="hljs-keyword">pid</span>: <span class="hljs-number">1453</span> at <span class="hljs-number">156092124</span><br><span class="hljs-keyword">proc</span> 1453<span class="hljs-title"></span><br><span class="hljs-title">context</span> binder<span class="hljs-title"></span><br><span class="hljs-title">  thread</span> 2538:<span class="hljs-title"> l</span> 01<span class="hljs-title"> need_return</span> 0<span class="hljs-title"> tr</span> 0<span class="hljs-title"></span><br><span class="hljs-title">    incoming</span> transaction 8113988: 0000000000000000<span class="hljs-title"> from</span> 16729:16729<span class="hljs-title"> to</span> 1453:2538<span class="hljs-title"> code</span> 5f434d44<span class="hljs-title"> flags</span> 10<span class="hljs-title"> pri</span> 0:120<span class="hljs-title"> r1</span> elapsed 29819ms<span class="hljs-title"> node</span> 5247<span class="hljs-title"> size</span> 148:40<span class="hljs-title"> offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">  buffer</span> 8113988: 0<span class="hljs-title"> size</span> 148:40:0<span class="hljs-title"> active</span><br><br>-----<span class="hljs-title"> pid</span> 1453<span class="hljs-title"> at</span> 2025-07-26 09:31:33.233489611+0800 -----<span class="hljs-title"></span><br><span class="hljs-title">Cmd</span> line:<span class="hljs-title"> system_server</span><br>Build<span class="hljs-title"> fingerprint:</span> xxxx<span class="hljs-title"></span><br><span class="hljs-title">ABI:</span> &#x27;arm64&#x27;<span class="hljs-title"></span><br><span class="hljs-title">Build</span> type:<span class="hljs-title"> optimized</span><br>Debug<span class="hljs-title"> Store:</span> 1,0,156092154::<span class="hljs-title"></span><br><span class="hljs-title">suspend</span> all<span class="hljs-title"> histogram:</span>	Sum: 64.207ms 99%<span class="hljs-title"> C.I.</span> 3us-7449.600us<span class="hljs-title"> Avg:</span> 369.005us<span class="hljs-title"> Max:</span> 22931us<span class="hljs-title"></span><br><span class="hljs-title">DALVIK</span> THREADS (226):<br>&quot;watchdog.monitor&quot;<span class="hljs-title"> prio=5</span> tid=12<span class="hljs-title"> Blocked</span><br>  |<span class="hljs-title"> group=&quot;main&quot;</span> sCount=1<span class="hljs-title"> ucsCount=0</span> flags=1<span class="hljs-title"> obj=0x2016da8</span> self=0x8b0000598a4b8000<br>  |<span class="hljs-title"> sysTid=1570</span> nice=-2<span class="hljs-title"> cgrp=foreground</span> sched=0/0<span class="hljs-title"> handle=0x7001af0730</span><br>  |<span class="hljs-title"> state=S</span> schedstat=( 14628587427 2412564438 42408 )<span class="hljs-title"> utm=581</span> stm=880<span class="hljs-title"> core=0</span> HZ=100<br>  |<span class="hljs-title"> stack=0x70019ed000-0x70019ef000</span> stackSize=1037KB<br>  |<span class="hljs-title"> held</span> mutexes=<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>  -<span class="hljs-title"> waiting</span> to<span class="hljs-title"> lock</span> &lt;0x0bcefae9&gt; (a<span class="hljs-title"> com.android.server.am.ActivityManagerService)</span> held<span class="hljs-title"> by</span> thread 57<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.handleCallback(Handler.java:959)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.dispatchMessage(Handler.java:100)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loopOnce(Looper.java:232)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loop(Looper.java:317)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.HandlerThread.run(HandlerThread.java:85)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.ServiceThread.run(ServiceThread.java:46)<span class="hljs-title"></span><br><span class="hljs-title">DumpLatencyMs:</span> 102.166<br><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>anr_XXX.txt 包含log</th>
<th>含义、作用</th>
</tr>
</thead>
<tbody><tr>
<td>Subject:XXX</td>
<td>当前的这个anr_xx.txt是什么原因被dump出来</td>
</tr>
<tr>
<td>CriticalEventLog</td>
<td>记录在此之前发生过的关键性异常事件（anr等）</td>
</tr>
<tr>
<td>dumping pid XX（关键）</td>
<td>binder交互信息（&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;transactions）</td>
</tr>
<tr>
<td>Cmd line: 进程名	（关键）</td>
<td>对应进程的各个线程的堆栈信息</td>
</tr>
<tr>
<td>Waiting Channels: pid XX</td>
<td>XX进程各线程的内核函数接口</td>
</tr>
<tr>
<td>等等</td>
<td></td>
</tr>
</tbody></table>
<p>分析问题时我们主要关注Binder 交互信息以及各进程的各线程的堆栈信息。</p>
<h3 id="4-2-3-trace-文件解读-线程堆栈信息"><a href="#4-2-3-trace-文件解读-线程堆栈信息" class="headerlink" title="4.2.3 trace 文件解读-线程堆栈信息"></a>4.2.3 trace 文件解读-线程堆栈信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;ReferenceQueueDaemon&quot;</span> daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">tid</span>=6 Waiting<br>  | <span class="hljs-attribute">group</span>=<span class="hljs-string">&quot;system&quot;</span> <span class="hljs-attribute">sCount</span>=1 <span class="hljs-attribute">ucsCount</span>=0 <span class="hljs-attribute">flags</span>=1 <span class="hljs-attribute">obj</span>=0x20030b8 <span class="hljs-attribute">self</span>=0x730000598a472000<br>  | <span class="hljs-attribute">sysTid</span>=1557 <span class="hljs-attribute">nice</span>=4 <span class="hljs-attribute">cgrp</span>=foreground <span class="hljs-attribute">sched</span>=0/0 <span class="hljs-attribute">handle</span>=0x70496d0730<br>  | <span class="hljs-attribute">state</span>=S schedstat=( 1359509621 111263835 448 ) <span class="hljs-attribute">utm</span>=110 <span class="hljs-attribute">stm</span>=25 <span class="hljs-attribute">core</span>=6 <span class="hljs-attribute">HZ</span>=100<br>  | <span class="hljs-attribute">stack</span>=0x70495cd000-0x70495cf000 <span class="hljs-attribute">stackSize</span>=1037KB<br>  | held mutexes=<br>  at java.lang.Object.wait(Native method)<br>  - waiting on &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Object.wait(Object.java:405)<br>  at java.lang.Object.wait(Object.java:543)<br>  at java.lang.Daemons<span class="hljs-variable">$ReferenceQueueDaemon</span>.runInternal(Daemons.java:260)<br>  - locked &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Daemons<span class="hljs-variable">$Daemon</span>.<span class="hljs-built_in">run</span>(Daemons.java:132)<br>  at java.lang.Thread.<span class="hljs-built_in">run</span>(Thread.java:1119)<br>DumpLatencyMs: 90.8357<br></code></pre></td></tr></table></figure>
<ul>
<li>第1行：<ul>
<li><strong>线程名</strong>：ReferenceQueueDaemon</li>
<li><strong>daemon</strong>：有此则代表守护线程（生命周期和进程的生命周期一样长）</li>
<li><strong>prio</strong>：（Priority）线程优先级</li>
<li><strong>tid</strong>：线程在进程内的序号（主线程tid&#x3D;1，其他线程依次递增）</li>
<li><strong>Waiting</strong>：线程状态（Java层面）常见还有Native、TimedWaiting、Sleeping、Blocked、Runnable。</li>
</ul>
</li>
<li>第2行：<ul>
<li><strong>group</strong>：线程所属的线程组，Java代码遗漏下来的，没有什么实际作用。</li>
<li><strong>sCount</strong>：Suspend Count 线程挂起次数（这里是art runtime 垃圾回收中的概念：GC时，要将线程挂起，执行GC操作）。</li>
<li><strong>ucsCount</strong>：用户主动使用代码导致线程挂起的次数（区别于sCount，这里主动调用代码挂起，前者是ART机制）。</li>
<li><strong>obj</strong>：保存着当前线程关联Java线程的对象地址（在虚拟机中从线程是以native的形式c++层thread存在，native线程要想访问java对象必须先保存Java线程对象的地址）。</li>
<li><strong>self</strong>：当前线程的地址</li>
</ul>
</li>
<li>第3行：<ul>
<li><strong>sysTid</strong>：线程号</li>
<li><strong>nice</strong>：调度优先级</li>
<li><strong>cgrp&#x3D;foreground</strong>：cgroup中进程所属调度组(常见有：foreground、top-app等)</li>
<li><strong>sched&#x3D;0&#x2F;0</strong>：调度策略（0 ：SCHED_NORMAL（也叫 SCHED_OTHER，普通时间共享，最常见）1 ：SCHED_FIFO（实时，先入先出）2 ：SCHED_RR（实时，轮询）3 ：SCHED_BATCH（批量）5 ：SCHED_IDLE（空闲线程）6 ：SCHED_DEADLINE（实时 deadline））。</li>
<li><strong>handle</strong>：native线程句柄</li>
</ul>
</li>
<li>第4行：<ul>
<li><strong>state&#x3D;S</strong> ：线程内核级别的调度状态（区别于运行时的线程状态，常见：Z：僵尸、D：不可中断休眠、S：可中断休眠、R：运行、T：停止）。</li>
<li><strong>schedstat</strong>&#x3D;( 1359509621 111263835 448 )：CPU调度时间统计（Running运行时间、Runable等待调度时间、SwitchCPU调度切换次数）， 见<code>proc/[pid]/task/[tid]/schedstat</code>.。在分析两份trace文件堆栈前后是否一致，是否卡死到同一位置，我们可以拿这几个值作为参考。</li>
<li><strong>utm</strong>&#x3D;110 ：线程在用户态所执行的时间</li>
<li><strong>stm</strong>&#x3D;25 ：线程在内核态所执行的时间</li>
<li><strong>core</strong>&#x3D;6 ：线程最后运行所在CPU的核</li>
<li><strong>HZ</strong>&#x3D;100：时钟频率</li>
</ul>
</li>
<li>第5行：<ul>
<li><strong>stack</strong>&#x3D;0x70495cd000-0x70495cf000：线程栈的地址空间</li>
<li><strong>stackSize</strong>&#x3D;1037KB：栈大小</li>
</ul>
</li>
<li>第6行：<strong>held mutexes</strong>：线程持有的mutexes</li>
<li>第7行：往下就是线程的调用堆栈：</li>
</ul>
<p>从问题排查的角度我们第一眼主要看到的是线程的状态（运行时）</p>
<ul>
<li><strong>Native</strong>：运行native层代码</li>
<li><strong>Waiting</strong>：线程等待</li>
<li><strong>TimedWaiting</strong>：线程定时等待</li>
<li><strong>Sleeping</strong>：线程主动Sleep</li>
<li><strong>Blocked</strong>：等待锁资源释放</li>
<li>…</li>
</ul>
<p>根据状态再看线程的调用栈，来确认是否是该线程中执行的代码逻辑有问题。</p>
<p>线程的调用堆栈反应线程此时在执行什么代码，那么在一个良好运作的系统中，线程的调用堆栈是什么样的呢？<br>在Android系统中和线程图中描述的一样并没有那么复杂,有一些基础功能的线程,有Binder线程,有普通的线程池线程。总体来说，除了一些基础功能的守护线程之外，其他<strong>线程模型</strong>主要有两种：</p>
<ul>
<li>通过<code>epoll</code>机制监测fd封装的线程模型。</li>
<li>Binder线程循环通过系统调用ioctl不断从Binder驱动读取消息线程模型。</li>
<li>其他</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//epoll 机制线程模型--正常等待新消息的到来</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5ff8  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+<span class="hljs-number">8</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 00018c2c  /system/lib64/libutils.so (android::Looper::pollInner+<span class="hljs-number">188</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 00018b0c  /system/lib64/libutils.so (android::Looper::pollOnce+<span class="hljs-number">124</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 0018b67c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce+<span class="hljs-number">44</span>) <br>  at android.os.MessageQueue.nativePollOnce(Native method)<br>  at android.os.MessageQueue.next(MessageQueue.java:<span class="hljs-number">335</span>)<br>  at android.os.Looper.loopOnce(Looper.java:<span class="hljs-number">194</span>)<br>  at android.os.Looper.loop(Looper.java:<span class="hljs-number">338</span>)<br>  at android.os.HandlerThread.run(HandlerThread.java:<span class="hljs-number">67</span>)<br> <span class="hljs-comment">//Binder 线程模型--正常读取Binder驱动消息</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5038  /apex/com.android.runtime/lib64/bionic/libc.so (__ioctl+<span class="hljs-number">8</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 000670ac  /apex/com.android.runtime/lib64/bionic/libc.so (ioctl+<span class="hljs-number">156</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 0005f4e4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver+<span class="hljs-number">292</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 000600c8  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">04</span> pc 00060cfc  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool+<span class="hljs-number">732</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">05</span> pc 0006ae08  /system/lib64/libbinder.so (android::PoolThread::threadLoop+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">06</span> pc 000144dc  /system/lib64/libutils.so (android::Thread::_threadLoop+<span class="hljs-number">284</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">07</span> pc 000ec29c  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell+<span class="hljs-number">140</span>)<br>  <span class="hljs-keyword">native</span>: #08 pc 000c9fd0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start+<span class="hljs-number">208</span>)<br>  <span class="hljs-keyword">native</span>: #09 pc 0005dd90  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+<span class="hljs-number">64</span>) <br>  <br></code></pre></td></tr></table></figure>
<p>我们看到上面两种线程模型的堆栈信息，就是正常的运行形态。对于Binder线程来说，如果线程在等对端返回，通常在talkWithDriver往前的堆栈会调用到涉及对端的一些代码。<br>例如：<br><img src="/blog_imgs/2_watchdog_2/wait_binder_target.jpg" srcset="/img/loading.gif" lazyload alt="20c9a7104ccafe356245a1b4c2680e8d.jpeg"></p>
<h3 id="4-2-4-Binder日志解读"><a href="#4-2-4-Binder日志解读" class="headerlink" title="4.2.4 Binder日志解读"></a>4.2.4 Binder日志解读</h3><p><strong>1.binder transaction信息</strong><br>在我们查看Binder交互log中，我们经常看到的就是<code>incoming transaction</code>和<code>outgoing transaction</code>，他们的含义是什么呢？<br>这其实内Binder驱动中Binder交互事务的描述。</p>
<ul>
<li><strong>outgoing transaction</strong>–客户端保存，客户端向服务端发起的binder事务请求。</li>
<li><strong>incoming transaction</strong>–服务端保存，服务端返回给客户端的binder事情请求。</li>
</ul>
<p>他们均指向一个binder_transaction，他们均能保存到线程指向的信息。<br>如下例子:<br>无论是<code>outgoing transaction</code>还是<code>incoming transaction</code>，他们都是指向<strong>7640493</strong>这个是kernel中<code>binder_transaction</code>的标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端进程</span><br>proc <span class="hljs-number">27226</span><br>context binder<br>  thread <span class="hljs-number">27226</span>: l <span class="hljs-number">10</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    outgoing transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms<br><br><span class="hljs-comment">//服务端进程</span><br>proc <span class="hljs-number">1467</span><br>context binder<br>  thread <span class="hljs-number">3206</span>: l <span class="hljs-number">01</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    incoming transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms <br></code></pre></td></tr></table></figure>
<ul>
<li><code>from 27226:27226 to 1467:3206</code> –<strong>from</strong>:进程27226中线程27226作为客户端访问， <strong>to</strong>:服务端进程1467线程3206线程。</li>
<li><strong>elapsed</strong>: 访问阻塞时间。</li>
<li>还有很多其他信息，后面我们剖析Binder驱动再做说明。</li>
</ul>
<p><strong>2.kernel中的binder: release</strong></p>
<p>从上面信息我们知道<code>binder_transaction</code>中保存着线程指向信息，那么拿到这个信息就可以知道线程指向。我们可以在kernel log中看到这样的打印，也能找到对端信息。<br>当客户端进程<code>27226</code>被kill后，binder驱动会将对应的<code>binder_transaction</code>释放掉，所以检索<code>transaction</code>的id(7640493)就能找到binder对端线程为: <code>1467_16</code>即:<code>sysTid=3206</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">147603.943970</span>] [T1726663] kworker/<span class="hljs-number">7</span>:<span class="hljs-number">2</span>: binder: release <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> transaction <span class="hljs-number">7640493</span> out, still active<br>[<span class="hljs-number">147603.949150</span>] [T1003206] binder:<span class="hljs-number">1467_16</span>: binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">7640493</span>, target dead<br><br><span class="hljs-string">&quot;binder:1467_16&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">223</span> Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> ucsCount=<span class="hljs-number">0</span> flags=<span class="hljs-number">1</span> obj=<span class="hljs-number">0x3217730</span> self=<span class="hljs-number">0xb1000050bcbc4000</span><br>  | sysTid=<span class="hljs-number">3206</span> nice=<span class="hljs-number">0</span> cgrp=foreground sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x729ebd3730</span><br>  | state=S schedstat=( <span class="hljs-number">3960678864</span> <span class="hljs-number">3521264239</span> <span class="hljs-number">5438</span> ) utm=<span class="hljs-number">298</span> stm=<span class="hljs-number">97</span> core=<span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x729eadc000</span>-<span class="hljs-number">0x729eade000</span> stackSize=989KB<br>  | held mutexes=<br>....<br></code></pre></td></tr></table></figure>
<p>以上就是输出log的一些解析。</p>
<h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5. 案例"></a>5. 案例</h2><p>以下是一些分析解决过的问题案例log。</p>
<h3 id="5-1-system-server线程死锁"><a href="#5-1-system-server线程死锁" class="headerlink" title="5.1 system_server线程死锁"></a>5.1 system_server线程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%AD%BB%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="f37b16c23b8661fdc4c3a57ee02744bf.png"><br>该例子中两次trace持锁情况如下，排查代码为客制化代码错误移到<code>synchronized (mGlobalLock) {...}</code>中导致。</p>
<table>
<thead>
<tr>
<th>lock</th>
<th>tid&#x3D;203</th>
<th>tid&#x3D;296</th>
</tr>
</thead>
<tbody><tr>
<td>0x0ee759b0</td>
<td>waiting lock &lt;0x0ee759b0&gt;</td>
<td>locked &lt;0x0ee759b0&gt;</td>
</tr>
<tr>
<td>0x058d9a40</td>
<td>locked &lt;0x058d9a40&gt;</td>
<td>waiting lock &lt;0x058d9a40&gt;</td>
</tr>
<tr>
<td>上面表格锁的情况刚好形成一个死循环称为死锁。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="5-2-system-server和phone进程死锁"><a href="#5-2-system-server和phone进程死锁" class="headerlink" title="5.2 system_server和phone进程死锁"></a>5.2 system_server和phone进程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_2.png" srcset="/img/loading.gif" lazyload alt="bbea9be66130474cc77063873c1410ca.png"><br><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_1.png" srcset="/img/loading.gif" lazyload alt="6fa59e552028af4c7b70f459d662440d.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//binder log</span><br>outgoing transaction <span class="hljs-number">25633452</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">2937</span>:<span class="hljs-number">2937</span> to <span class="hljs-number">1937</span>:<span class="hljs-number">5077</span> code 3a flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1<br><br>binder: release <span class="hljs-number">1937</span>:<span class="hljs-number">3234</span> transaction <span class="hljs-number">25632946</span> out, still active <br>binder: release <span class="hljs-number">2937</span>:<span class="hljs-number">3605</span> transaction <span class="hljs-number">25632946</span> in, still active <br>binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">25632946</span>, target dead<br></code></pre></td></tr></table></figure>
<p>该例中两份trace文件均如此。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>system_server</td>
<td>binder:1937_16线程(sysTid&#x3D;5077)</td>
<td>等待→</td>
<td>binder:1937_E线程(tid&#x3D;290)sysTid&#x3D;3234</td>
</tr>
<tr>
<td></td>
<td>↑等待</td>
<td></td>
<td>↓等待</td>
</tr>
<tr>
<td>phone进程</td>
<td>main线程(sysTid&#x3D;2937)</td>
<td>←等待</td>
<td>binder:2937_A线程(tid&#x3D;70)sysTid&#x3D;3605</td>
</tr>
</tbody></table>
<h3 id="5-3-audio进程和system-server进程间死锁"><a href="#5-3-audio进程和system-server进程间死锁" class="headerlink" title="5.3 audio进程和system_server进程间死锁"></a>5.3 audio进程和system_server进程间死锁</h3><p>audio进程和system_server进程死锁导致Binder线程阻塞在其中出现Binder线程耗尽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">----------------------时间:<span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45</span> system_server进程 binder线程不够用 ---最早出现的时间<br><span class="hljs-number">10</span>-<span class="hljs-number">17</span> <span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45.931</span> <span class="hljs-number">1619</span> <span class="hljs-number">1805</span> W IPCThreadState: Waiting <span class="hljs-keyword">for</span> thread to be free. mExecutingThreadsCount=<span class="hljs-number">32</span> mMaxThreads=<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure>
<p>排查发现trace中所有Binder线程均在等待WMS服务的锁:<code>WindowManagerGlobalLock</code>((蓝色部分)，对应4633线程持有该锁在访问Audio模块的 <code>isStreamActive</code> 方法。<br><img src="/blog_imgs/2_watchdog_2/audio00.png" srcset="/img/loading.gif" lazyload alt="a4ab3a355233116247152306a33e326a.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[ <span class="hljs-number">95.581437</span>] [T600160] binder: release <span class="hljs-number">855</span>:<span class="hljs-number">984</span> transaction <span class="hljs-number">93929</span> in, still active [ <span class="hljs-number">95.581471</span>] [T600160] binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">93929</span> to <span class="hljs-number">1619</span>:<span class="hljs-number">4633</span><br></code></pre></td></tr></table></figure>
<p>进一步排查发现,audio发生了NE(在audio中有binder超时监测机制，当超时到达超时直接会直接NE，进程重启)。<br>在main log的audio打印中日志中发现audio进程中的984线程执行 <code>isStreamActive</code> 似乎在等锁 <code>Mutex::Autolock _l(mLock)</code>。<br><img src="/blog_imgs/2_watchdog_2/audio0.png" srcset="/img/loading.gif" lazyload alt="087a02a8d769c50e35c1d3b6db5abd1f.png"><br>进一步我们发现main log中audio模块还有相关持有 <code>Mutex::Autolock _l(mLock)</code> 的堆栈信息,audio进程中的2945线程执行listAudioPorts 方法持锁 <code>Mutex::Autolock _l(mLock)</code> 并通过 <code>mustAnonymizeBluetoothAddress</code> 需要进一步访问system_server的权限管理服务。<br><img src="/blog_imgs/2_watchdog_2/audio1.png" srcset="/img/loading.gif" lazyload alt="ee0a7b9093c50afcc7e28d845eba818e.png"></p>
<p>上述流程存在audio和system_server进程间死锁情况。</p>
<h3 id="5-4-堆栈看似相同实则不同-耗时异常"><a href="#5-4-堆栈看似相同实则不同-耗时异常" class="headerlink" title="5.4 堆栈看似相同实则不同,耗时异常"></a>5.4 堆栈看似相同实则不同,耗时异常</h3><p>前后两次dump的trace文件阻塞点,粗略看一致(绿色部分)，仔细看堆栈不一致(其他颜色部分)， 客制化代码耗时导致。<br><img src="/blog_imgs/2_watchdog_2/same_backtrace.png" srcset="/img/loading.gif" lazyload alt="7815c48c6755fe0070ac293716aeb34c.png"></p>
<h3 id="5-5-三把锁导致的死锁"><a href="#5-5-三把锁导致的死锁" class="headerlink" title="5.5 三把锁导致的死锁"></a>5.5 三把锁导致的死锁</h3><p>主线程<code>tid=1</code>等待线程<code>378</code>紫色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_1.png" srcset="/img/loading.gif" lazyload alt="6602a76a3aaa54e8b7291478da2fcf5d.png"><br>线程<code>378</code>等待线程<code>369</code>红色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_3.png" srcset="/img/loading.gif" lazyload alt="c1bec46d21e004b379bad921350057c9.png"><br>线程<code>369</code>等待线程<code>1</code>蓝色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_2.png" srcset="/img/loading.gif" lazyload alt="1f7667b560ce6178895cb74ab032499e.png"></p>
<h3 id="5-6-kernel模块异常"><a href="#5-6-kernel模块异常" class="headerlink" title="5.6 kernel模块异常"></a>5.6 kernel模块异常</h3><p><code>system_server</code>中动画线程等待<code>Binder</code>对端返回,从代码来看对端未SF进程。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_1.png" srcset="/img/loading.gif" lazyload alt="af25851c06a8d990a61d3c1d3e8cd1ab.png"><br>查看对应接口,发现SF线程<code>1247</code>等待主线程<code>775</code>。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_2.png" srcset="/img/loading.gif" lazyload alt="6e6d0c5df46ec6d82c85ed552ec8a363.png"><br>SF主线程等待<code>Binder</code>对端返回对端为<code>728</code>线程,查看堆栈,发现未能dump出来。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_3.png" srcset="/img/loading.gif" lazyload alt="1e83be08823e434a2be7d8126e130390.png"><br>最后查看kernellog中dump出来的kernel异常D状态进程信息,发现728存在D状态阻塞在模块A,需要<strong>模块A</strong>排查异常。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_4.png" srcset="/img/loading.gif" lazyload alt="fad3207864cbc9f3900d939ecdc7f479.png"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过两篇文章，SWT问题中的watchdog原理我们基本上已经梳理清楚。文章开始围绕着system_server中存在的两个问题开始讲起，以及到后面的不断补充完善，提及输入的日志，分析了输出的日志信息，并且根据日志提供了遇到过的一些SWT案例分析日志来阐述system_server中的watchdog原理。总结为以下几点：</p>
<ul>
<li>问题一细化</li>
<li>问题二细化</li>
<li>日志讲解</li>
<li>案例分析</li>
</ul>
<p>最后再提出一个问题：<br>system_server中存在的问题，使用一个watchdog线程来做监控，大家有没有想过万一watchdog线程异常了怎么办（虽然概率小，但还是存在）？watchdog线程监控功能不就失效了吗？手机还是会一直卡死。那么怎么解决这个新问题或者怎么监控这个问题？</p>
<blockquote>
<p>难道我们我们再使用一个system_server中的线程A来监测吗？万一线程A又异常了怎么办？使用线程B…C…<br>虽然问题概率低，并且上面的方式不行，但是我们还是得监控。我们能否使用一个内核的进程&#x2F;模块来监控它呢？<br>——可行，MTK:Hang_detect机制、展锐：Native_Hang机制</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9C%BA%E5%88%B6/" class="category-chain-item">机制</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%9C%BA%E5%88%B6/SWT/" class="category-chain-item">SWT</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86/" class="print-no-link">#系统概念原理</a>
      
        <a href="/tags/SWT/" class="print-no-link">#SWT</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/16/hello-world2/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/23/1_watchdog_%E4%B8%8A/" title="Android system_server中watchdog机制介绍（上）">
                        <span class="hidden-mobile">Android system_server中watchdog机制介绍（上）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
