

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CubeHuang">
  <meta name="keywords" content="">
  
    <meta name="description" content="[TOC] 1. system_server进程存在哪些问题？在整个Android系统中最为重要的一个进程就是system_server进程，对于应用程序来说system_server进程提供应用进程所需的一切，system_server进程的正常工作是整个手机系统正常运行的保障，这样用户才能够顺利使用手机。  问题一：在我们开发者的眼中，一个复杂功能的进程中往往包含了各个线程，并且将复杂功能拆分">
<meta property="og:type" content="article">
<meta property="og:title" content="Android system_server中watchdog机制介绍（上）">
<meta property="og:url" content="http://example.com/2025/03/23/1/">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 1. system_server进程存在哪些问题？在整个Android系统中最为重要的一个进程就是system_server进程，对于应用程序来说system_server进程提供应用进程所需的一切，system_server进程的正常工作是整个手机系统正常运行的保障，这样用户才能够顺利使用手机。  问题一：在我们开发者的眼中，一个复杂功能的进程中往往包含了各个线程，并且将复杂功能拆分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_1.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_2.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_3.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_4.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_5.png">
<meta property="og:image" content="http://example.com/blog_imgs/1/Image_6.png">
<meta property="article:published_time" content="2025-03-23T12:46:25.000Z">
<meta property="article:modified_time" content="2025-11-23T12:46:25.000Z">
<meta property="article:author" content="CubeHuang">
<meta property="article:tag" content="SWT">
<meta property="article:tag" content="系统概念原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/blog_imgs/1/Image.png">
  
  
  
  <title>Android system_server中watchdog机制介绍（上） - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CubeHuang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/main_wallpapers/wp_1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Android system_server中watchdog机制介绍（上）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-23 20:46" pubdate>
          2025年3月23日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android system_server中watchdog机制介绍（上）</h1>
            
            
              <div class="markdown-body">
                
                <p>[TOC]</p>
<h2 id="1-system-server进程存在哪些问题？"><a href="#1-system-server进程存在哪些问题？" class="headerlink" title="1. system_server进程存在哪些问题？"></a>1. system_server进程存在哪些问题？</h2><p>在整个<code>Android</code>系统中最为重要的一个进程就是<code>system_server</code>进程，对于应用程序来说<code>system_server</code>进程提供应用进程所需的一切，<code>system_server</code>进程的正常工作是整个手机系统正常运行的保障，这样用户才能够顺利使用手机。</p>
<ul>
<li><p><strong>问题一</strong>：<br>在我们开发者的眼中，一个复杂功能的进程中往往包含了各个线程，并且将复杂功能拆分成各个模块，使用各个线程运行各个功能模块的逻辑，将各个功能联动起来。<code>system_server</code>进程的功能非常复杂，使用的线程也非常多。各个功能被抽象成一个个服务，例如和应用程序界面显示相关的<code>WMS</code>（WindowManagerService）服务，和应用组件相关的<code>AMS</code>（ActivityManagerService）服务等，这些服务在<code>system_server</code>进程中以一个个对象实例的形式存在（单例）。从设计的角度来讲，这些服务也是分等级的，有些服务稍显得没那么重要，有些服务例如和窗口显示相关的WMS服务、和应用组件相关的AMS服务等都是比较重要的。<code>system_server</code>进程作为其他进程的数据处理中心，基本所有进程都访问<code>system_server</code>中的各个服务，如果两个应用进程同时访问<code>system_server</code>中的同一个服务，因为服务本身只有一个不可能让所有进程都同时访问到，那么只能排队访问，一个一个访问。那么<code>system_server</code>如何让他们轮着访问呢？答案就是使用锁-对象锁，每个服务都有自己对象锁，使用锁的形式来保证顺序访问。<br><strong>举例</strong>:当进程A来访问<code>system_server</code>中的<code>AMS</code>服务时候那么就先持有<code>AMS</code>实例的对象锁。访问完则释放给其他进程使用，这样又有了新的问题：万一<code>AMS锁</code>被某个流程长期的占用一直不释放怎么办，出现长时间持锁，另外一个情况就是多线程的使用，当各模块服务之间交互的时候就可能出现死锁异常，所以目前可能会出现的两个问题就是：代码流程耗时、逻辑出现死锁。两个问题引起线程长时间持锁的异常，造成<code>system_server</code>卡死，其他进程就无法根本无法使用访问到对应服务，这样系统不就长时间卡死了吗？那么我们要如何解决这个问题呢？</p>
</li>
<li><p><strong>问题二</strong>：<br>其次，这些服务逻辑功能的实现离不开各个线程的运行，在<code>system_server</code>中线程也是分作用和功能的，有负责整个<code>system_server</code>进程初始化工作的主线程：<code>main</code>线程，显示相关的<code>android.display</code>线程，动画相关的<code>android.anim</code>线程，用来处理各个客户端应用进程的逻辑的31个<code>binder线程</code>等等。由于线程的分工不一样，他们的重要性就不一样，像<code>main</code>、<code>ui</code>、<code>display</code> 等这些关键的线程处理事务时候是不能出现长时间卡死的，不能长时间只处理一个事务。这样在用户体验上就是极度的顿卡，那么我们如何解决这样的问题呢？</p>
</li>
</ul>
<h3 id="1-1-需要解决的问题"><a href="#1-1-需要解决的问题" class="headerlink" title="1.1 需要解决的问题"></a>1.1 需要解决的问题</h3><p>针对上面的描述目前我们要解决的问题：</p>
<ul>
<li>各个关键服务（<code>AMS</code>、<code>WMS</code>、<code>IMS</code>等）不能被某一逻辑长时间占用，即关键服务的对象锁不能被某些线程长时间的持有（死锁，逻辑异常等）</li>
<li>各个关键线程（<code>main</code>、<code>i/o</code>、<code>ui</code>、<code>display</code>等）不能出现耗时，即关键线程的消息要及时处理完</li>
</ul>
<h2 id="2-思考如何解决问题"><a href="#2-思考如何解决问题" class="headerlink" title="2. 思考如何解决问题"></a>2. 思考如何解决问题</h2><p>所以我们要怎么解决这两个问题呢？</p>
<blockquote>
<p>答案： 程序员优化代码逻辑。额。。。但情况确实就是这样的，但是起码要让程序员知道哪些逻辑是异常的，所以从<code>system_server</code>的角度来讲我们要对上面问题场景进行监测，当监测到问题时我们将所需日志完整的输出出来，交给程序员解决。</p>
</blockquote>
<p>这也就引出了我们今天的主题：<code>system_server</code>进程中的<code>watchdog监测机制</code>。<br>（请注意它是个监测机制，基本上所有的稳定性问题都有对应的监测机制，要分析稳定性问题就要先熟悉对应的监测机制）</p>
<p>在<code>system_server</code>中我们采取的策略是：我们使用一个新的线程（<code>watchdog线程</code>）来监测上面两个问题，当问题发生时我们将日志保留下来，提供给程序员分析解决异常点（当然这里使用一个线程来进行监测也会有问题，例如<code>watchdog线程</code>卡死了怎么办，难道再使用一个线程来监控吗？这又可以引出另外一个专题，暂时先不多展开）。</p>
<p>当然这是从我们程序员的角度来看，我们只需要查看日志并解决问题即可。但是从用户体验的角度上来看，出现问题时手机将会长时间顿卡，当问题包含死锁等情况时候，手机可能会一直卡死。在使用可拆卸电池手机的年代，我们用户可以将电池拆下来，直接断电重启可以解决问题。而今电池和手机是封装在一块的，出现这种问题就只能等待手机电量耗尽手机重启才能恢复，这对于用户来说是体验很糟糕的，所以我们要在<code>watchdog机制</code>中制定一个标准，通过手机卡住的时间来衡量问题的严重性，卡住的时间超过用户能忍受的时间直接触发手机重启，让用户能够恢复手机的使用。</p>
<p>所以目前<code>watchdog机制</code>要解决的问题进一步细化：</p>
<ul>
<li>检测关键服务的对象锁是否被某线程长时间占用（死锁、逻辑耗时阻塞），异常情况输出日志</li>
<li>检测关键线程运行逻辑是否阻塞，异常情况输出日志</li>
<li>根据异常的时间长短，划分异常的严重性，长时间异常则重启手机，短时间异常则尽可能输出日志让程序员能够知道问题的原因</li>
</ul>
<p>针对这上面提出的三个点我们需要怎么样设计代码</p>
<h2 id="3-如何设计Watchdog机制？"><a href="#3-如何设计Watchdog机制？" class="headerlink" title="3. 如何设计Watchdog机制？"></a>3. 如何设计Watchdog机制？</h2><p>因为我们无法真正从代码设计者的角度去剖析这个代码的由来（因为代码不是我们设计的，但是我们可以通过读代码来反推作者可能这样设计的原因，我查阅了历史watchdog的源码，发现现有Android 15的Watchdog框架延续的是android-4.4.4_r1的watchdog版本,历经10多个版本框架原理基本没有改变，和android-4.4.4_r1以前的watchdog框架基本截然不同，说明android-4.4.4_r1的watchdog代码很健壮）</p>
<h3 id="3-1-system-server的功能和线程情况"><a href="#3-1-system-server的功能和线程情况" class="headerlink" title="3.1 system_server的功能和线程情况"></a>3.1 system_server的功能和线程情况</h3><p>在此之前我们需要了解一下system_server的功能以及线程的情况，才能更好的结合问题点来设计解决问题的方案。<br>（dump出<code>system_server</code>中启动所有binder服务：<code>adb shell dumpsys system_server_dumper</code>）</p>
<p><img src="/blog_imgs/1/Image.png" srcset="/img/loading.gif" lazyload alt="bc8d1d931735e23f805b22208bb33b6b.png"></p>
<p>不完全统计可能有100+个服务运行在system_server进程之上，我们要监控比较重要的服务对象：<br>考虑的点（猜测）：和用户进程交互比较频繁的服务，功能比较复杂比较多的服务，功能越多越复杂，线程交叉使用得多越容易死锁，例如如下这些服务：</p>
<ul>
<li>StorageManagerService</li>
<li>MediaProjectionManagerService</li>
<li>MediaRouterService</li>
<li>InputManagerService</li>
<li>PowerManagerService</li>
<li>WindowManagerService</li>
<li>ActivityManagerService</li>
</ul>
<p>各个服务模块逻辑的实现离不开<code>system_server</code>的各个线程，主要包含下面的一些线程（不完全功能按照来进行划分，粗略统计线程数量300+）</p>
<p><img src="/blog_imgs/1/Image_1.png" srcset="/img/loading.gif" lazyload alt="95a32af7d527a1dfb76b3f20ed66f62c.png"></p>
<ul>
<li>橘黄色框图：各个服务模块的线程，线程名和模块相关</li>
<li>绿色框图：重要的系统线程，按照线程处理的事务类型来进行划分，说白了就是<strong>公共线程</strong>，其他模块要是要处理的事务符合对应线程处理的事务类型，他就可以使用该线程来处理自己的事务。</li>
<li>橙色框图：Binder线程，用于和其他进程交互</li>
<li>蓝色框图：基础线程，每个Android应用进程都基本配备的线程</li>
<li>紫灰色框图：起辅助作用普通线程，线程池线程，和Hal层服务交互的HWBinder线程</li>
</ul>
<p>整个<code>system_server</code>进程从功能和线程的角度来看就上图的描述那样。<br>简单介绍如下线程</p>
<ol>
<li><p>基础线程（apk进程也是如此）<br>1.1 <strong>基础线程：main</strong>： 主线程初始化工作，<br>1.2 <strong>基础线程：守护线程</strong>:<br>1.2.1 <code>ReferenceQueueDaemon</code> 垃圾回收相关：清理Java引用对象，<br>1.2.2 <code>FinalizerDaemon</code> 垃圾回收相关：清理重写finalize()的对象，<br>1.2.3 <code>FinalizerWatchdogDaemon</code>：垃圾回收相关：监测 FinalizerDaemon线程，<br>1.2.4 <code>Signal Catcher</code>：信号处理函数，堆栈dump工作<br>1.2.5 <code>HeapTaskDaemon</code>：垃圾回收相关：堆内存<br>1.2.6 <code>Profile Saver Android</code> 混合编译相关<br>1.2.7  <code>Jit thread pool worker thread</code>:JIT即时编译相关</p>
</li>
<li><p><strong>Binder线程</strong>：和Binder驱动紧密相连，是其他进程和system_server进程交互的重要桥梁<br>2.1 binder:Pid_N(1-20,A-F,1A-1F) &#x3D; 20+6+6&#x3D;32个，包含1个binder主线程和31个binder普通线程<br>2.2 HwBinder</p>
</li>
<li><p><strong>普通线程</strong>：<br>3.1 pool-X-thread-Y: 线程池产生的线程,可复用<br>2.2 Thread-N：普通线程，不可复用</p>
</li>
<li><p><strong>各服务功能线程</strong>：线程名和功能相关</p>
</li>
<li><p><strong>系统公共线程</strong>：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Name</th>
<th>priority</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>android.fg</td>
<td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td>
<td>前台公共线程，该线程设计的特别之处就是当处理的消息有超时的情况就会打印出来，它要求处理的消息要快，我们在system log能看到：Slow delivery XX等等log就是这里设置的</td>
</tr>
<tr>
<td>android.ui</td>
<td>THREAD_PRIORITY_FOREGROUND &#x3D; -2</td>
<td>处理系统进程UI相关的事务，它是一个fg线程（有消息超时会打印日志），和上面的fg线程不同的是它属于一个进程的Group中（THREAD_GROUP_TOP_APP &#x3D; 5），因为显示UI要进行额外的加速处理和CPU调度策略相关</td>
</tr>
<tr>
<td>android.io</td>
<td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td>
<td>文件读写相关的事务，无耗时监控</td>
</tr>
<tr>
<td>android.display</td>
<td>THREAD_PRIORITY_DISPLAY +1&#x3D; -4  +1 &#x3D;-3</td>
<td>处理系统显示事务相关（WindowManager，DisplayManager，InputManager使用），拥有较高线程优先级，无耗时监控</td>
</tr>
<tr>
<td>android.anim</td>
<td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td>
<td>处理系统动画相关的事务（窗口动画，启动动画等），线程优先级 ，无耗时监控</td>
</tr>
<tr>
<td>android.anim.lf</td>
<td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td>
<td>处理系统动画相关的事务和Vsync相关，线程优先级</td>
</tr>
<tr>
<td>android.bg</td>
<td>THREAD_PRIORITY_BACKGROUND &#x3D; 10</td>
<td>后台线程，公共使用，有耗时监控</td>
</tr>
<tr>
<td>android.perm</td>
<td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td>
<td>权限处理相关公共线程，有耗时监控</td>
</tr>
<tr>
<td>android.usagestats</td>
<td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td>
<td>usagestatus数据处理相关 ，有耗时监控</td>
</tr>
</tbody></table>
<p><strong>watchdog监控的线程</strong>：处理逻辑较多，和用户体验挂钩，窗口显示，动画，UI显示.</p>
<h3 id="3-2-如何进行监控？"><a href="#3-2-如何进行监控？" class="headerlink" title="3.2 如何进行监控？"></a>3.2 如何进行监控？</h3><ul>
<li><strong>监测重要线程</strong>：只需要通过<code>watchdog</code>监控线程给对应线程发送一条消息，看对应线程在对应时间能不能处理完就行，不能执行完成，则可能线程出现阻塞</li>
<li><strong>监测重要对象</strong>：只需要通过<code>watchdog</code>监控线程去使用一次对应对象，即获取一下对象锁能不能获取得到，不能获取到，则对象被某一线程长时间占用，可能线程出现阻塞.目前<code>watchdog</code>设置的时间是<strong>30s</strong>去检测一次（为什么是<strong>30s</strong>，这个我暂时无从考证，可能是由于一分钟&#x3D;60s&#x3D;2个30s）</li>
</ul>
<p>第一点较容易实现，<code>watchdog线程</code>向各个线程发送一条消息，在规定时间内是否及时响应。</p>
<p>第二点稍微难一点，我们的实现方式是：各个重要服务对象都实现一个持锁的方法即可，方法主动使用<code>synchronized</code> (自身服务对象锁)获取一次锁，规定时间内是否能及时获取到。</p>
<p>目前我们可以根据问题得到下图，<code>watchdog线程</code>给每个重要的线程发消息</p>
<p><img src="/blog_imgs/1/Image_2.png" srcset="/img/loading.gif" lazyload alt="34d72c510426dd1ed301261c8ddc39ab.png"></p>
<p>对于第二点，需要都调用各个重要服务的该方法来完成一次检查，这里和第一点有相似之处的实现逻辑：都是需要去检查是否出现耗时，所以第二点逻辑实现上我们可以抽象一下（Java中面向对象）：使用单独一个线程去做获取各个重要服务对象锁这件事情。</p>
<p>那么目前得到下图，我们新增加了一个线程：<code>watchdog:monitor</code>,watchdog线程的事情就变成：给包括<code>watchdog.monitor</code>在内的重要线程发送一条消息，如果消息不能定时处理完成则异常，否则正常。</p>
<p><img src="/blog_imgs/1/Image_3.png" srcset="/img/loading.gif" lazyload alt="b60af6764cd22190019181812416f28d.png"></p>
<p>以上就是<code>watchdog框架</code>的树干部分，从现在我们就可以去梳理代码，将细枝末节的树叶补充完整。(我会先提出问题再回答这种形式来逐个将细节呈现出来)</p>
<h3 id="3-3-代码实现一：问题的抽象"><a href="#3-3-代码实现一：问题的抽象" class="headerlink" title="3.3 代码实现一：问题的抽象"></a>3.3 代码实现一：问题的抽象</h3><p>对于上述的图片中我们大概框架已经显现出来了<br>问题：对于我们<code>watchdog线程</code>只需要做的事情就是隔一段时间就发个消息去监测一下各个重要线程（新增加的<code>watchdog.monitor</code>&#x2F;<code>main</code>&#x2F;<code>android.fg</code>&#x2F;<code>android.ui</code>等）是否阻塞就行，那么我们使用什么数据结构来保存这些重要线程呢？或者我们是否重新将这些线程和其他因素考虑在一起封装成一个新的对象呢？<br>考虑因素：</p>
<ul>
<li>对于<code>watchdog线程</code>发消息去<code>check</code>各个线程这个事情，了解<code>Android线程模型</code>的的都知道，其实本质就是获取对应线程的handler调用<code>mHandler.postAtFrontOfQueue</code>发送消息即可，即通过<code>Handler</code>去<code>check</code>各个线程是否阻塞–&gt;<strong>HandlerChecker</strong><ul>
<li><code>(main)Handler.postAtFrontOfQueue</code></li>
<li>…</li>
<li><code>(android.fg)Handler.postAtFrontOfQueue</code></li>
</ul>
</li>
<li>假如我们现在有一个模块线程想要被watchdog线程监测，但是我只想watchdog来检测我的时候，由于我模块功能的特殊性检测时候只要我线程10s内不阻塞就行，因此需要提供一个客制化超时时间的方法—&gt;<strong>AndTimeout</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;HandlerCheckerAndTimeout&gt; mHandlerCheckers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()<br></code></pre></td></tr></table></figure>
<p>所以<code>HandlerCheckerAndTimeout</code>实际上就是要保存各个检测线程的<code>handler</code>，以及特别定制化的超时时间<code>timeout</code>。所以我们进一步看<code>HandlerCheckerAndTimeout</code>的成员有<code>mHandler</code>以及客制化超时时间<code>mCustomTimeoutMillis</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Holds a checker and its timeout. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerCheckerAndTimeout</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HandlerChecker mHandler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;Long&gt; mCustomTimeoutMillis;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HandlerCheckerAndTimeout</span><span class="hljs-params">(HandlerChecker checker, Optional&lt;Long&gt; timeoutMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mHandler = checker;<br>        <span class="hljs-built_in">this</span>.mCustomTimeoutMillis = timeoutMillis;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">//其他方法容易理解类似get/set这样的方法故省略</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们使用一个<code>ArrayList</code> 来保存各个检测的对象，所以在<code>watchdog</code>初始化时候会将<code>mHandlerCheckers</code>填满，将各个检测对象<code>add</code>到对应成员中，这里大家可以看一下<code>watchdog</code>的构造函数即可。</p>
<ul>
<li>运行<code>watchdog线程</code></li>
<li>将新的<code>watchdog.monitor线程</code>运行起来并加入监测列表中</li>
<li>将其他重要监测线程加入到监测列表中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>    mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::run, <span class="hljs-string">&quot;watchdog&quot;</span>);<br>    <br>    <span class="hljs-type">ServiceThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceThread</span>(<span class="hljs-string">&quot;watchdog.monitor&quot;</span>,<br>            android.os.Process.THREAD_PRIORITY_DEFAULT, <span class="hljs-literal">true</span> <span class="hljs-comment">/*allowIo*/</span>);<br>    t.start();<br>    mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(t.getLooper()), <span class="hljs-string">&quot;monitor thread&quot;</span>, mLock);<br>    mHandlerCheckers.add(withDefaultTimeout(mMonitorChecker));<br><br>    mHandlerCheckers.add(<br>            withDefaultTimeout(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(), <span class="hljs-string">&quot;foreground thread&quot;</span>, mLock)));<br>    <span class="hljs-comment">//...相似实现</span><br><br>    <span class="hljs-comment">// Initialize monitor for Binder threads.</span><br>    addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>());<span class="hljs-comment">//后面在提</span><br>&#125;<br></code></pre></td></tr></table></figure>


<p>回到图四，我们虽然抽象出了<code>HandlerCheckerAndTimeout</code>（<code>handler</code>和<code>客制化timeout</code>），但是我们想一下，我们<code>watchdog.monitor线程</code>检查工作和其他线程（例如<code>main线程</code>）检查工作完全不一样，其他线程只需要调用<code>Handler.postAtFrontOfQueue</code>即可，<code>watchdog.monitor线程</code> 需要逐个便利各个服务对象实例的方法去进行持锁检查。为了功能的实现我们当然分开去实现，但是为了代码统一，减少额外的代码，我们能否将将两个<code>check事项</code>抽象为一个新的类？</p>
<p>可以，我们将两个事项进一步抽象<code>HandlerChecker</code>，并且在<code>HandlerChecker</code>中将两个<code>check事项</code>区分开来就行。<br>我们将<code>watchdog.monitor线程</code>需要<code>check</code>的一个个重要服务称为一个个<code>monitor</code>，对应每个重要服务都实现对应的方法来完成自身模块是否异常的逻辑（对于monitor()方法的实现,大多数模块直接获取当前模块的同步锁对象即可，一些特殊的模块可以根据模块自定义实现例如：StorageManagerService 服务则直接调用Vold进程的相关方法来判断自身模块的阻塞情况）<br>（我们可以在源码搜<code>Watchdog.Monitor</code>关键字就可以知道watchdog.monitor线程一共监测这多少个重要服务他们分别是什么）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象接口继承此接口即可实现自己服务的耗时逻辑监控</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Monitor</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>所以HandlerChecker中我们要使用一个数据结构来保存watchdog.monitor的监测对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Monitor&gt;();<span class="hljs-comment">//保存watchdog.monitor线程的监测对象:各个重要服务对象的实例</span><br><br>    <span class="hljs-comment">//watchdog线程触发的接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">(<span class="hljs-type">long</span> handlerCheckerTimeoutMillis)</span> &#123;<br>        ...<br>        mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//message具体检查事务逻辑细节:</span><br>    <span class="hljs-comment">//也是watchdog.monitor和其他main，android.ui等HandlerCheckers区别的关键</span><br>    <span class="hljs-comment">//* HandlerCheckers:watchdog.monitor 循环遍历各个monitor调用对应的monitor方法持锁排查</span><br>    <span class="hljs-comment">//* HandlerCheckers:main/android.ui/android.fg等，写一个标志位代表我的线程已经按时执行完成了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//下面这个循环主要是watchdog.monitor线程执行调用，只有HandlerCheckers：watchdog.monitor有monitor成员</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mMonitors.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCurrentMonitor = mMonitors.get(i);<br>            &#125;<br>            mCurrentMonitor.monitor();<br>        &#125;<br>        <span class="hljs-comment">// 所有的HandlerCheckers都写一个标志位，代表我的线程已经顺利完成检查工作</span><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>            mCurrentMonitor = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码中我们能看到使用list来保持monitor对象。以及发送的message的实现（run()）<br>所以目前我们<code>watchdog框架</code>中的<code>HandlerCheckers</code>梳理框架图如下图：</p>
<p><img src="/blog_imgs/1/Image_4.png" srcset="/img/loading.gif" lazyload alt="eddf82180df94170ee26ec6641f059cb.png"></p>
<p>在mHandlerCheckers中保存了众多的HandlerChecker，仔细分类可以分为：Monitor Checker和Hander Checker</p>
<ul>
<li><strong>Monitor Checker</strong>，用于检查是Monitor对象可能发生的”卡死“, <code>AMS</code>, <code>PKMS</code>, <code>WMS</code>等核心的系统服务都是<code>Monitor</code>对象，通过<code>watchdog.monitor</code>线程来检查。</li>
<li><strong>Handler Checker</strong>, 纯粹意义上的HandlerChecker,主要检测各个线程消息处理是否阻塞</li>
</ul>
<p><strong>补充</strong>：Binder线程是其他进程和system_server进程交互的通道，一共32个线程，当这32个线程出现阻塞，或者都繁忙无法继续处理来自其他进程的交互，这个时候会导致异常，系统也会出现卡死。我们需要对这种异常进行监控，所以添加一个monitor：<code>BinderThreadMonitor</code>交给<code>watchdog.monitor</code>线程来监控，所以我们在玫红色框图中看懂一个灰色的<code>monitor</code>成员。所以对于<code>Monitor Checker</code>进一步区分分为：<strong>普通服务监控monitor</strong>和<strong>binder线程监控monitor</strong></p>
<p>根本上这两类HandlerChecker就是对应着文章开头提出的两个问题1和问题2。（这两个概念比较重要，对于SWT问题的分析特别重要）</p>
<h3 id="3-4-代码实现二：异常的衡量"><a href="#3-4-代码实现二：异常的衡量" class="headerlink" title="3.4 代码实现二：异常的衡量"></a>3.4 代码实现二：异常的衡量</h3><p>上面的<code>check项</code>，我们都已经抽象完成。那么我们的一个<code>HandlerChecker</code>出现卡死究竟<strong>卡死多久才算异常呢？有没有一个衡量标准？</strong></p>
<p>阻塞卡死都归结到<code>HandlerChecker</code>是否正常，我们给每个<code>HandlerChecker</code>都设置一个状态值：state，代表<code>HandlerChecker</code>的阻塞程度</p>
<p>默认的标准是这样的：</p>
<table>
<thead>
<tr>
<th>state 状态</th>
<th>timeout</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>COMPLETED</td>
<td>timeout &#x3D;0</td>
<td>当HandlerChecker正常情况下不阻塞，线程能够瞬间的完成message的事务，状态良好</td>
</tr>
<tr>
<td>WAITING</td>
<td>0&lt;timeout &lt;30s</td>
<td>当HandlerChecker出现阻塞，线程能够30s内完成message的事务，稍微耗时可能能恢复</td>
</tr>
<tr>
<td>WAITED_HALF</td>
<td>30s&lt;timeout &lt;60s</td>
<td>当HandlerChecker出现阻塞，线程能够30s-60s内完成message的事务，耗时以及过半了，可能阻塞恢复不了了</td>
</tr>
<tr>
<td>OVERDUE</td>
<td>60s&lt;timeout</td>
<td>当HandlerChecker出现阻塞，线程能够60s都完成不了message的事务，耗时超过1分钟，完了，用户现在可能极度不满</td>
</tr>
</tbody></table>
<p><img src="/blog_imgs/1/Image_5.png" srcset="/img/loading.gif" lazyload alt="ec73f97d532c22b08cbc129770c49e68.png"></p>
<p>判断系统卡死的事情基本解决完毕,<strong>那么我们需要什么时机输出日志呢?以及需要输出那些日志呢?</strong></p>
<p><code>watchdog线程</code>使用一个死循环,每隔<code>30s</code>去<code>check</code>一次各个<code>HandlerChecker</code>,获取各个<code>HandlerChecker</code>的状态是否正常.</p>
<ul>
<li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>COMPLETED,WAITING</code>),卡<strong>0-30s</strong>内我们认为可以接受,等下一个<code>30s</code>再去检查一次</li>
<li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>WAITING_HALF</code>),卡<strong>30s-60s</strong>系统可能存在问题了,需要dump一些log,再等下一个<code>30s</code>去检查一次</li>
<li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>OVERDUE)</code>,卡<strong>大于60s</strong>,系统已经出现问题,用户以及无法使用手机超过1分钟了,可能死锁了等严重阻塞问题,我们需要dump所有必要的日志,重启手机,让用户能恢复使用</li>
</ul>
<p>伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">run() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>        <span class="hljs-comment">//step2:休眠30s</span><br>        <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>android-4.4.4_r1的watchdog的部分检查代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                hc.scheduleCheckLocked();<br>            &#125;<br>            <span class="hljs-comment">//step2:休眠30s</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(timeout);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Log.wtf(TAG, e);<br>                &#125;<br>                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);<br>            &#125;<br>            <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>            <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                <span class="hljs-comment">// 情况良好,下次继续检查</span><br>                waitedHalf = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                <span class="hljs-comment">// 可能存在阻塞,时间可控,下次继续检查</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                <span class="hljs-comment">// 存在阻塞,时间超过30s,dump日志,下次继续检查</span><br>                <span class="hljs-keyword">if</span> (!waitedHalf) &#123;<br>                    ArrayList&lt;Integer&gt; pids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                    pids.add(Process.myPid());<br>                    ActivityManagerService.dumpStackTraces(<span class="hljs-literal">true</span>, pids, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                            NATIVE_STACKS_OF_INTEREST);<br>                    waitedHalf = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//存在阻塞,时间超过60s,系统存在问题,用户体验糟糕,尽可能收集日志,重启收集</span><br>            <span class="hljs-comment">// something is overdue!</span><br>            blockedCheckers = getBlockedCheckersLocked();<br>            subject = describeCheckersLocked(blockedCheckers);<br>            allowRestart = mAllowRestart;<br>        &#125;<br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>执行所有的<code>Checker</code>的监控方法<code>scheduleCheckLocked()</code><ol>
<li>是否完成检测，完成则将mMonitorQueue队列中的monitor全部加入mMonitor中；</li>
<li>对于HandlerChecker来说,如果目标线程空闲,则不用进一步检测,则设置mCompleted &#x3D; true，返回；</li>
<li>当上次check还没有完成, 则直接返回；</li>
<li>Watchdog线程向各个线程发送消息，看消息能否按时完成。</li>
</ol>
</li>
<li>等待30s后, 再调用<code>evaluateCheckerCompletionLocked</code>来评估各<code>HandlerChecker</code>状态;</li>
<li>根据<code>waitState</code>状态来执行不同的操作:<ol>
<li>当COMPLETED或WAITING,则正常，继续检查;</li>
<li>当WAITED_HALF(超过30s)且为首次, 则输出system_server和3个Native进程的traces;</li>
<li>当OVERDUE, 则输出更多信息,并重启系统。</li>
</ol>
</li>
</ol>
<p>综合上之前的信息，我们目前可以得到下面这个框架图</p>
<p><img src="/blog_imgs/1/Image_6.png" srcset="/img/loading.gif" lazyload alt="acd22c37acbbe0d5dc72720bcc72ffe3.png"></p>
<h2 id="4-日志收集"><a href="#4-日志收集" class="headerlink" title="4. 日志收集"></a>4. 日志收集</h2><p>我们需要收集哪些日志呢？<br>因为我们无法得知和<code>HandlerChecker</code>卡住的具体原因，我们只能<code>dump</code>和<code>system_server</code>有交集的各个进程，特别涉及和<code>system_server</code>模块服务有相关交集的进程。<br>例如</p>
<ul>
<li>StorageManagerService–<strong>vold</strong>（volume daemon）进程</li>
<li>WindowManagerService–<strong>SurfaceFlinger</strong> 进程</li>
<li>等等以及<code>Hal</code>的服务进程<br>首先第一步<code>system_server</code>自身进程的各个线程堆栈信息要<code>dump</code>出来。<br>其次和system_server 交互的其他关系紧密的进程的堆栈也需要dump出来，这里直接给出的进程有：</li>
</ul>
<table>
<thead>
<tr>
<th>Name</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>system_server</td>
<td>自身进程</td>
</tr>
<tr>
<td>com.android.phone</td>
<td>由于phone进程作为一个应用层级的Binder服务，依托system_server将接口中转给其他进程使用，（遇到过phone进程system_server形成死锁的案例 ）</td>
</tr>
<tr>
<td>com.google.android.providers.media.module</td>
<td>同上，也有遇到过类似案例</td>
</tr>
<tr>
<td>media相关进程</td>
<td></td>
</tr>
<tr>
<td>surfaceflinger</td>
<td></td>
</tr>
<tr>
<td>netd</td>
<td></td>
</tr>
<tr>
<td>…30+</td>
<td>这里主要涉及在开发过程中遇到问题，不断添加完善的过程</td>
</tr>
</tbody></table>
<p>日志输出：</p>
<ul>
<li>当阻塞超过30s后进行一次日志输出：用户态进程堆栈，日志包含上面的用户态各个进程的各个现场现场的堆栈信息（目录   <code>data/anr/anr_日期.txt</code>）</li>
<li>当阻塞超过60s后进行最后一次日志输出<strong>用户态进程堆栈</strong>+<strong>kernel异常信息</strong>，这个时候系统是真的卡死了，很可能是由于<code>kernel</code> 卡死导致（内核线程死锁，阻塞，文件系统异常，内存异常，驱动模块异常等），所以我们要输出一下kernel中状态异常的进程信息<ul>
<li>使用 <strong>&#x2F;proc&#x2F;sysrq-trigger</strong> 节点</li>
<li><code>echo l &gt; /proc/sysrq-trigger</code>： 显示所有活动cpu的堆栈信息</li>
<li><code>echo w &gt; /proc/sysrq-trigger</code>： 将进入 <code>uninterrupted 状态</code>的任务信息 dump 出来</li>
<li><code>echo c &gt; /proc/sysrq-trigger</code>： 使系统崩溃，如果配置了<code>crashdump</code>，崩溃后会生成 <code>dump 文件</code><br>  (kernel-6.6&#x2F;Documentation&#x2F;admin-guide&#x2F;sysrq.rst )<br>关于dump出来的日志是一个比较复杂的内容，等后面在进一步解释。</li>
</ul>
</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文通过文字结合代码结合图片形式来讲述Watchdog机制的由来，讲的内容是粒度较大的，可能还存在部分错误，但是总统是个不断完善的过程。<br>文中比较重要的就是代码上对于两个问题的抽象是比较重要的，对于这两个概念的理解是后面分析SWT问题的基础，读者务必了解清楚。<br>文章的不足：代码部分往往很难使用语言来描述到极度详细，需要一定的代码阅读能力。<br>文章的用途：主要是用于记录自己学习watchdog机制的记录，一方面通过比较口语化的形式记录，方便后续查阅。<br>后期待办：完善问题分析例子</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Sports/" class="category-chain-item">Sports</a>
  
  
    <span>></span>
    
  <a href="/categories/Sports/Baseball/" class="category-chain-item">Baseball</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86/" class="print-no-link">#系统概念原理</a>
      
        <a href="/tags/SWT/" class="print-no-link">#SWT</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/16/hello-world1/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
