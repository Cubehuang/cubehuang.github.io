<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/16/hello-world1/"/>
    <url>/2025/12/16/hello-world1/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/16/hello-world2/"/>
    <url>/2025/12/16/hello-world2/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android system_server中watchdog机制介绍（下）</title>
    <link href="/2025/09/02/2_watchdog_%E4%B8%8B/"/>
    <url>/2025/09/02/2_watchdog_%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]<br><strong>回顾</strong>：<br>从上篇文章中，我们主要从问题角度描述了我们<code>system_server</code>中<code>watchdog</code>的原理，粒度是很粗糙的。简单可以概括为下面三点：</p><ul><li><strong>关键服务</strong>对象锁不能被某线程异常长时间占用——<strong>问题1</strong></li><li><strong>系统关键线程</strong>不能长时间只执行一个单一逻辑，避免后面的消息阻塞——<strong>问题2</strong></li><li>当监测到上面异常时，我们根据异常时间长短来决策是否重启手机，并且根据异常时间我们针对性的输出日志，让程序员根据log解决异常。</li></ul><p>本篇文章，我们再进一步将上述三点内容，进一步细化以及列举一些常见的案例。</p><h2 id="1-关键线程异常"><a href="#1-关键线程异常" class="headerlink" title="1. 关键线程异常"></a>1. 关键线程异常</h2><p><code>system_server</code>中的众多模块功能，离不开<code>system_server</code>中各个线程的执行，<code>system_server</code>中线程组成如下：</p><p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_6_%E9%A1%B5.png" alt="dce0c8d48bb5f707c303f5c305476bad.png"></p><p>如上虚线框内的线程中我们主要关注<strong>关键线程</strong>（<strong>绿色部分线程</strong>），他们的职能如同名字一样，服务模块如果处理例如io，显示等职能事务，可以将事务专门交给这些关键线程。而不是将所有事务都交给模块线程来处理。这些关键线程就像我们生活中的公共交通工具火车、地铁、公交一样在system_server中扮演着重要的作用。</p><h3 id="1-1-关键线程具体有哪些"><a href="#1-1-关键线程具体有哪些" class="headerlink" title="1.1 关键线程具体有哪些?"></a>1.1 关键线程具体有哪些?</h3><p>我们通过系统源码查看可以查看，我们主要监测着下面表格中这些线程：</p><table><thead><tr><th>关键线程名</th><th>作用</th></tr></thead><tbody><tr><td>main</td><td>主线程（优先级：-2）</td></tr><tr><td>android.ui</td><td>处理系统进程UI相关的事务（优先级：-2）</td></tr><tr><td>android.io</td><td>文件读写相关的事务（优先级：0）</td></tr><tr><td>android.display</td><td>处理系统显示事务相关（优先级：-3）</td></tr><tr><td>android.anim</td><td>处理系统动画相关的事务（优先级：-4）</td></tr><tr><td>android.anim.lf</td><td>处理系统动画相关和Vsync相关（优先级：-4）</td></tr><tr><td>android.fg</td><td>前台公共线程（优先级：0）</td></tr><tr><td>android.bg</td><td>后台公共线程（优先级：10）</td></tr><tr><td>watchdog.monitor</td><td>用来check关键服务锁情况（优先级：0）</td></tr><tr><td>服务模块线程</td><td>服务模块逻辑线程</td></tr><tr><td>ActivityManager:starter</td><td>AMS进程创建相关线程</td></tr><tr><td>RollbackManagerServiceHandler</td><td>回滚相关线程</td></tr><tr><td>PermissionManager</td><td>权限管理线程</td></tr><tr><td>PowerManagerService</td><td>电量&#x2F;源管理服务线程</td></tr><tr><td>PackageManagerService</td><td>包管理服务线程</td></tr><tr><td>可根据问题自主添加</td><td></td></tr></tbody></table><h3 id="1-2-watchdog中添加线程监控方法："><a href="#1-2-watchdog中添加线程监控方法：" class="headerlink" title="1.2 watchdog中添加线程监控方法："></a>1.2 watchdog中添加线程监控方法：</h3><p>模块代码中使用<br><code>Watchdog.getInstance().addThread(..)</code></p><h2 id="2-关键服务异常"><a href="#2-关键服务异常" class="headerlink" title="2. 关键服务异常"></a>2. 关键服务异常</h2><p>具体的监测服务如下，100多个服务为什么选择这几个服务呢？这里我们不得而知，但是可想而知的是，随之系统的迭代以及项目的不断开发，系统中会遇到各种各样的问题，会根据问题的分类，增加新的监测模块。</p><ul><li>StorageManagerService</li><li>MediaProjectionManagerService</li><li>MediaRouterService</li><li>InputManagerService</li><li>PowerManagerService</li><li>WindowManagerService</li><li>ActivityManagerService</li><li>BatteryStatsService</li><li>BinderThreadMonitor(补充)<br>目前系统中监测的服务为上面的这些服务，当然如果我们往system_server中添加新的重要服务，我们也可以将该服务添加到监控中去。</li></ul><h3 id="2-1-监控关键服务的方法："><a href="#2-1-监控关键服务的方法：" class="headerlink" title="2.1 监控关键服务的方法："></a>2.1 监控关键服务的方法：</h3><p>我们添加重要的模块&#x2F;服务到<code>system_server</code>中，可以通过以下方法添加到<code>watchdog</code>监控中去。</p><ol><li>实现<code>Watchdog.Monitor</code>接口中的 <code>monitor()</code> 方法，方法中实现本模块认为异常的监测逻辑。</li><li>模块代码调用  <code>Watchdog.getInstance().addMonitor(this)</code>。</li></ol><h3 id="2-2-Binder线程监测补充"><a href="#2-2-Binder线程监测补充" class="headerlink" title="2.2 Binder线程监测补充"></a>2.2 Binder线程监测补充</h3><p>在<code>system_server</code>中<code>Binder线程</code>（下图橙色部分）作为应用进程和<code>system_server</code>交互的桥梁，并且<code>system_server</code>作为整个Android系统中Binder线程数量最多的进程，<strong>Binder线程资源多并且十分重要</strong>。</p><p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%82%E4%B9%B1.png" alt="052ad1ef0eee091636769b3f2f1e0166.png"></p><p><strong>问题</strong>：<u>会不会出现所有Binder线程都阻塞到某个逻辑，导致其他应用进程访问system_server却没有Binder线程处理事务？</u></p><blockquote><p>是会这样的，所有要对这种异常情况进行监控。我们就可以使用上面的 2.1 中方法添加到watchdog监控中去。</p></blockquote><p>我们可以根据2.1的步骤可以看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br>   <span class="hljs-number">1.</span> 现Watchdog.Monitor接口中的 `monitor()` 方法，方法中实现本模块认为异常的监测逻辑<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderThreadMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>           Binder.blockUntilThreadAvailable();<br>       &#125;<br>   &#125;<br><span class="hljs-number">2.</span> 模块代码调用  `Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>)`<br>addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>())<br></code></pre></td></tr></table></figure><p> <code>monitor</code>方法具体实现：<br> 如果所有Binder线程都在阻塞（正常来说不可能所有Binder线程都长时间阻塞的），那么打印异常日志并且一直等待阻塞，阻塞将会被<code>watchdog</code>监测到，持续异常将触发重启。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> IPCThreadState::blockUntilThreadAvailable()<br>&#123;<br>    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);<br>    mProcess-&gt;mWaitingForThreads++;<br>    <span class="hljs-keyword">while</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads) &#123;<br>        ALOGW(<span class="hljs-string">&quot;Waiting for thread to be free. mExecutingThreadsCount=%lu mMaxThreads=%lu\n&quot;</span>,<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mExecutingThreadsCount),<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mMaxThreads));<br>        pthread_cond_wait(&amp;mProcess-&gt;mThreadCountDecrement, &amp;mProcess-&gt;mThreadCountLock);<br>    &#125;<br>    mProcess-&gt;mWaitingForThreads--;<br>    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="3-异常监测的衡量"><a href="#3-异常监测的衡量" class="headerlink" title="3. 异常监测的衡量"></a>3. 异常监测的衡量</h2><p>在对于问题1、2的详细阐述后我们可以得到下面这个图片：<br><img src="/blog_imgs/2_watchdog_2/binder_montor.png" alt="6422d9568c21b454540ae3349dfc1487.png"></p><p><code>watchdog线程</code>给各个关键线程发送一条消息，各个关键线程在规定时间内处理完该消息，那么<code>watchdog线程</code>认为系统正常。如果规定时间内无法处理完该消息，那么认为系统异常。</p><p><strong>问题</strong>： <u>那么这个规定时间是多少呢？</u></p><blockquote><p>答案是：30s，每隔30s发送一条消息，如果超过30s各个关键线程没有处理完消息，系统将会打印对应的日志。</p></blockquote><p><strong>问题</strong>：假如system_server异常后不能长时间卡住，用户无法忍受，如何处理？</p><blockquote><p>超过第二个30s（即一分钟），消息还未被处理完成，重启系统，让用户能恢复手机使用。</p></blockquote><p>当然有人会问为什么是30s？</p><blockquote><p>这里无从考证，个人猜测一方面可能是用户的体验不能卡住太久，另一方面是时间一分钟&#x3D;60s&#x3D;两个30s，便于编码。</p></blockquote><p>经过第三点的补充后我们得到了下面完整的框架图片：<br>![a6625f96485e3a8391ecba9a419a7ec5.png](&#x2F;blog_imgs&#x2F;2_watchdog_2&#x2F;watchdog_1-第_5 页.png)</p><p>图片解读:</p><ol><li><code>system_server</code>中watchdog线程每隔30s给各个<strong>关键线程</strong>发送一条消息，消息内容：设置一个<strong>标志位</strong>，代表处理完成。</li><li>Binder线程是否空余，以及各个关键服务的对象锁是否被异常持有，由<code>watchdog.monitor线程</code>进行检测，检测方式：逐一调用各个模块实现的<code>monitor方法</code>即可，<code>monitor接口</code>是否阻塞则决定各个模块是否异常。</li><li>如果&gt;<strong>30s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中。</li><li>如果&gt;<strong>60s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中，并且<strong>重启system_server进程</strong>。</li></ol><h2 id="4-日志的输出"><a href="#4-日志的输出" class="headerlink" title="4. 日志的输出"></a>4. 日志的输出</h2><p>在超时30s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条log：<br><code>07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG</code><br>在在超时60s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条相似的log：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure><p>光凭借这点log我们程序员可无法准确的定位出问题，我们的目的只有一个:输出log要能让程序员定位到问题。</p><h3 id="4-1-问题：-我们还需要输出哪些log？"><a href="#4-1-问题：-我们还需要输出哪些log？" class="headerlink" title="4.1 问题： 我们还需要输出哪些log？"></a>4.1 问题： 我们还需要输出哪些log？</h3><p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E6%9D%82%E4%B9%B1.png" alt="d098fbc833faeda9532b15223a5b1e37.png"></p><h4 id="4-1-1-system-server-自身堆栈信息"><a href="#4-1-1-system-server-自身堆栈信息" class="headerlink" title="4.1.1 system_server 自身堆栈信息"></a>4.1.1 system_server 自身堆栈信息</h4><p><strong>system_server</strong> 中存在的问题很可能就是上图的情况，可能还比上图更为杂乱，各个线程间相互等待，相互等锁等等，我们最直观能看到问题点就是将<code>system_server</code>中各个的线程的堆栈dump出来，通过堆栈找出问题点。</p><ul><li><strong>输出日志</strong>：dump出 <strong>system_server中各个线程的堆栈信息</strong></li></ul><h4 id="4-1-2-system-server-关联进程堆栈信息"><a href="#4-1-2-system-server-关联进程堆栈信息" class="headerlink" title="4.1.2 system_server 关联进程堆栈信息"></a>4.1.2 system_server 关联进程堆栈信息</h4><p><img src="/blog_imgs/2_watchdog_2/%E9%87%8D%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E.png" alt="2cf19497de20cf3bb9abca5d6f585923.png"></p><p>对于<code>system_server</code>进程而言，除了自身进程之外，<code>system_server</code>进程还会和其他进程交互，这里尤其指的是服务模块进程，万一我们<code>system_server</code>中的线程阻塞在这些其他进程上怎么办？</p><blockquote><p>所以我们需要dump出和<code>system_server</code>交互频繁的这些服务进程的线程堆栈。native 层服务进程，以及hal层服务进程，以及Java层的匿名Binder服务进程等等：</p></blockquote><ul><li><p>例如：<strong>native&#x2F;hal层服务进程</strong> : <code>SF</code>、<code>Netd</code>、<code>audio模块</code>、<code>sensor模块</code>等。</p></li><li><p>例如：<strong>Java层匿名Binder服务进程</strong>: <code>com.android.phone</code>、<code>com.google.android.providers.media.module</code>等。</p></li><li><p><strong>输出日志</strong>： dump出<strong>和system_server交互频繁的服务进程的线程堆栈</strong></p></li></ul><p>我们能从watchdog代码中看到下面的这些需要dump的进程的信息：<br><img src="/blog_imgs/2_watchdog_2/dump_%E8%BF%9B%E7%A8%8B.jpg" alt="3f81357d1ea62e19f0c7346a7826a61c.jpeg"><br>这里的信息也是随着项目产品不断迭代，出现问题后，不断往上添加的一个过程。例如你在项目中遇到问题指向某个服务进程并且排查问题时候这个服务进程没有被dump出来，你就可以在上面代码中添加。</p><h4 id="4-1-3-kernel异常进程信息"><a href="#4-1-3-kernel异常进程信息" class="headerlink" title="4.1.3 kernel异常进程信息"></a>4.1.3 kernel异常进程信息</h4><p>上面我们主要dump的都是用户态的堆栈信息，但是我们还需要想一个点——问题：<strong>内核模块会不会异常</strong>？<br>会的，我们还是从上上个图中来看，底层的一些重要的服务是依赖于kernel中的一些驱动模块的，除了我们常知道内存、cpu、gpu等还有tp&#x2F;屏显&#x2F;sensor等等一些内核模块，也是会出现异常的进而间接会影响到system_server中的模块。所以我们需要dump出内核模块中异常的堆栈信息。</p><p><strong>但是怎么判断内核异常模块进程呢</strong>？</p><ul><li><code>TASK_UNINTERRUPTIBLE</code>：不可中断休眠，长时间的不可中断休眠状态的线程则很容易出现阻塞问题，进而引发SWT问题</li><li>进程状态：<strong>D状态</strong></li></ul><p><strong>不可中断休眠状态进程的特点</strong>：</p><ul><li>不接受中断（软&#x2F;硬）signal信号等，只等待想等待的事情完成。</li><li>常见场景：有 Swap 读数据、信号量机制、mutex 锁、内存慢路径回收等场景。<br>(参考：<a href="https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE">https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE</a>)</li></ul><p><strong>dump方式</strong>：<code>echo w &gt; /proc/sysrq-trigger</code><br>类似：<br><img src="/blog_imgs/2_watchdog_2/kernel_D_log.jpg" alt="a1d88ec87f02b6fef4adbc78c8c06aee.jpeg"></p><h4 id="4-1-4-小结"><a href="#4-1-4-小结" class="headerlink" title="4.1.4 小结"></a>4.1.4 小结</h4><p>上述就是我们需要dump出来的log信息，但是还缺一样log，在Android系统中服务进程间通信方式使用的的是Binder通信，所以我们要知道A进程中的A1线程和B进程中B1线程是否存在通信的关系，我们需要dump Binder通信的log信息。<br>位置：<code>/dev/binderfs/binder_logs/transactions</code>或者<code>/sys/kernel/debug/binder</code>目录下。<br>所需的日志如下：</p><ul><li><strong>system_server自身线程堆栈信息</strong></li><li><strong>与system_server关联其他服务端进程信息</strong></li><li><strong>kernel异常状态进程堆栈信息</strong></li><li><strong>Binder进程间交互信息</strong></li></ul><p>如下图：<br><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC10_%E9%A1%B5.png" alt="a8b702225974fac1cf9d81af66fe25cf.png"></p><h3 id="4-2-日志解读"><a href="#4-2-日志解读" class="headerlink" title="4.2 日志解读"></a>4.2 日志解读</h3><p>我们在分析SWT 问题时候，通常来说是按照下面的log进行分析的：</p><ul><li><strong>红色部分日志</strong>：先从events system 这些log中确定system_server中遭遇了哪类问题？是<strong>问题一</strong>还是<strong>问题二</strong>。</li><li><strong>蓝色部分日志</strong>：进而从dump的堆栈信息（不管是kernel还是用户态其他进程）分析异常模块。</li><li><strong>绿色日志</strong>：Binder交互信息作为辅助，借助交互信息可以得知各个阻塞模块的联系。</li></ul><p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC11_%E9%A1%B5.png" alt="e955d2a63ccbd59a8f085e159a603a35.png"></p><h3 id="4-2-1-events-system-日志解读"><a href="#4-2-1-events-system-日志解读" class="headerlink" title="4.2.1 events system 日志解读"></a>4.2.1 events system 日志解读</h3><p><code>events log</code>中下面两条log分别是在异常大于30s，大于60s两个时间节点输出</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG<br>07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure><p><strong>第二条log</strong>会直接指出出现的异常是那种类型，也就是我们之前分析的问题一或者问题二，当前的log表明，<code>watchdog.monitor</code> 线程想要去获取<code>ActivityManagerService</code>的对象锁，很遗憾超过60s都没有获取到，说明问题点是：AMS这个模块中的对象锁被某个线程异常长时间持有，有可能是线程逻辑阻塞，也有可能是线程死锁。</p><p>上述的第二条log信息是比较重要的，直接为为我们指明了排查方向，第二条log还有其他好几种形式，但是log的模板基本上只有两种，因为我们要检测的问题基本上就两个：</p><ul><li><code>Blocked in handler on</code> 关键线程名 <code>thread</code> (关键线程)——<strong>问题2</strong></li><li><code>Blocked in monitor</code> 关键服务对象 <code>on monitor thread (watchdog.monitor)</code>——<strong>问题1</strong></li></ul><table><thead><tr><th>关键线程名</th><th>关键服务对象</th></tr></thead><tbody><tr><td>线程名</td><td>关键服务对象</td></tr><tr><td>main</td><td>StorageManagerService</td></tr><tr><td>android.ui</td><td>MediaRouterService</td></tr><tr><td>android.io</td><td>InputManagerService</td></tr><tr><td>android.display</td><td>WindowManagerService</td></tr><tr><td>android.anim</td><td>ActivityManagerService</td></tr><tr><td>android.anim.lf</td><td>BatteryStatsService</td></tr><tr><td>android.fg</td><td>BinderThreadMonitor</td></tr><tr><td>android.bg</td><td>…</td></tr><tr><td>watchdog.monitor</td><td></td></tr><tr><td>ActivityManager:starter，RollbackManagerServiceHandler，PermissionManager，PowerManagerService，PackageManagerService</td><td></td></tr></tbody></table><p>打印的log只是上面表格中列出来的一种或者多种组合。<br>例如：下面的日志中所有问题都囊括了</p><ul><li>关键服务AMS服务的对象锁被异常持有。</li><li>关键线程 <code>android.fg</code>、<code>main</code>、<code>android.io</code>、<code>android.display</code>、<code>android.anim</code>阻塞</li><li>没有空闲Binder线程。</li></ul><p><img src="/blog_imgs/2_watchdog_2/log_red.PNG" alt="d1c8f2a81b6c7825f864369bc3ec638d.png"></p><p>排查的时候我们使用一条线索往下排查就行，往往是各个问题相互杂糅相互影响的（目前没有遇到过几个问题点是分开的这种问题）。</p><p>在system log 中会打印下面这样的log：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br>W Watchdog: watchdog.monitor annotated stack trace:<br>W Watchdog:     at com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>W Watchdog:     - waiting to lock &lt;0x0bcefae9&gt; (a com.android.server.am.ActivityManagerService)<br>W Watchdog:     at com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<br>W Watchdog:     at android.os.Handler.handleCallback(Handler.java:959)<br>W Watchdog:     at android.os.Handler.dispatchMessage(Handler.java:100)<br>W Watchdog:     at android.os.Looper.loopOnce(Looper.java:232)<br>W Watchdog:     at android.os.Looper.loop(Looper.java:317)<br>W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:85)<br>W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:46)<br>W Watchdog: *** GOODBYE!<br></code></pre></td></tr></table></figure><p>log会打印出阻塞的关键线程的堆栈信息（有时候受负载影响可能不准，但是可以作为参考），如上能看到AMS对象锁的地址，会打印出<strong>GOODBYE</strong>关键字。<br>除此之外在system log中还会打印出现SWT先后dump两次trace文件的名称，给我们指明下一步排查的文件的位置（这里比较关键，有的伙伴分析问题直接就随便点开一个anr_xx就开始排查，可能看的trace文件都不对，这会影响问题的分析结果）。<br><code>ActivityManager: Dumping to /data/anr/anr_2025-07-26-09-32-16-000</code> （可以在system log中检索<code>Dumping to</code> 这个关键字，anr问题的分析也是如此）。</p><h3 id="4-2-2-trace-文件概要解读"><a href="#4-2-2-trace-文件概要解读" class="headerlink" title="4.2.2 trace 文件概要解读"></a>4.2.2 trace 文件概要解读</h3><p><code>SWT</code>以及<code>ANR</code>问题都会将进程的线程堆栈信息dump出来，文件保存到<code>data/anr</code>目录下面。区别在于SWT问题trace文件dump的进程较多，ANR问题dump的trace文件进程较少（通常只是ANR进程本身以及system_server进程）。<br>通常来说<strong>trace文件</strong>主要包括以下几部分内容：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Subject: Blocked in monitor com.android.server.am.ActivityManagerService on monitor thread (watchdog.monitor) <span class="hljs-keyword">for</span> <span class="hljs-number">15</span>s<br>--- CriticalEventLog ---<br>capacity: <span class="hljs-number">20</span><br>timestamp_ms: <span class="hljs-number">1753493489805</span><br>window_ms: <span class="hljs-number">300000</span><br><br>----- dumping <span class="hljs-keyword">pid</span>: <span class="hljs-number">1453</span> at <span class="hljs-number">156092124</span><br><span class="hljs-keyword">proc</span> 1453<span class="hljs-title"></span><br><span class="hljs-title">context</span> binder<span class="hljs-title"></span><br><span class="hljs-title">  thread</span> 2538:<span class="hljs-title"> l</span> 01<span class="hljs-title"> need_return</span> 0<span class="hljs-title"> tr</span> 0<span class="hljs-title"></span><br><span class="hljs-title">    incoming</span> transaction 8113988: 0000000000000000<span class="hljs-title"> from</span> 16729:16729<span class="hljs-title"> to</span> 1453:2538<span class="hljs-title"> code</span> 5f434d44<span class="hljs-title"> flags</span> 10<span class="hljs-title"> pri</span> 0:120<span class="hljs-title"> r1</span> elapsed 29819ms<span class="hljs-title"> node</span> 5247<span class="hljs-title"> size</span> 148:40<span class="hljs-title"> offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">  buffer</span> 8113988: 0<span class="hljs-title"> size</span> 148:40:0<span class="hljs-title"> active</span><br><br>-----<span class="hljs-title"> pid</span> 1453<span class="hljs-title"> at</span> 2025-07-26 09:31:33.233489611+0800 -----<span class="hljs-title"></span><br><span class="hljs-title">Cmd</span> line:<span class="hljs-title"> system_server</span><br>Build<span class="hljs-title"> fingerprint:</span> xxxx<span class="hljs-title"></span><br><span class="hljs-title">ABI:</span> &#x27;arm64&#x27;<span class="hljs-title"></span><br><span class="hljs-title">Build</span> type:<span class="hljs-title"> optimized</span><br>Debug<span class="hljs-title"> Store:</span> 1,0,156092154::<span class="hljs-title"></span><br><span class="hljs-title">suspend</span> all<span class="hljs-title"> histogram:</span>Sum: 64.207ms 99%<span class="hljs-title"> C.I.</span> 3us-7449.600us<span class="hljs-title"> Avg:</span> 369.005us<span class="hljs-title"> Max:</span> 22931us<span class="hljs-title"></span><br><span class="hljs-title">DALVIK</span> THREADS (226):<br>&quot;watchdog.monitor&quot;<span class="hljs-title"> prio=5</span> tid=12<span class="hljs-title"> Blocked</span><br>  |<span class="hljs-title"> group=&quot;main&quot;</span> sCount=1<span class="hljs-title"> ucsCount=0</span> flags=1<span class="hljs-title"> obj=0x2016da8</span> self=0x8b0000598a4b8000<br>  |<span class="hljs-title"> sysTid=1570</span> nice=-2<span class="hljs-title"> cgrp=foreground</span> sched=0/0<span class="hljs-title"> handle=0x7001af0730</span><br>  |<span class="hljs-title"> state=S</span> schedstat=( 14628587427 2412564438 42408 )<span class="hljs-title"> utm=581</span> stm=880<span class="hljs-title"> core=0</span> HZ=100<br>  |<span class="hljs-title"> stack=0x70019ed000-0x70019ef000</span> stackSize=1037KB<br>  |<span class="hljs-title"> held</span> mutexes=<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>  -<span class="hljs-title"> waiting</span> to<span class="hljs-title"> lock</span> &lt;0x0bcefae9&gt; (a<span class="hljs-title"> com.android.server.am.ActivityManagerService)</span> held<span class="hljs-title"> by</span> thread 57<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.handleCallback(Handler.java:959)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.dispatchMessage(Handler.java:100)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loopOnce(Looper.java:232)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loop(Looper.java:317)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.HandlerThread.run(HandlerThread.java:85)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.ServiceThread.run(ServiceThread.java:46)<span class="hljs-title"></span><br><span class="hljs-title">DumpLatencyMs:</span> 102.166<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>anr_XXX.txt 包含log</th><th>含义、作用</th></tr></thead><tbody><tr><td>Subject:XXX</td><td>当前的这个anr_xx.txt是什么原因被dump出来</td></tr><tr><td>CriticalEventLog</td><td>记录在此之前发生过的关键性异常事件（anr等）</td></tr><tr><td>dumping pid XX（关键）</td><td>binder交互信息（&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;transactions）</td></tr><tr><td>Cmd line: 进程名（关键）</td><td>对应进程的各个线程的堆栈信息</td></tr><tr><td>Waiting Channels: pid XX</td><td>XX进程各线程的内核函数接口</td></tr><tr><td>等等</td><td></td></tr></tbody></table><p>分析问题时我们主要关注Binder 交互信息以及各进程的各线程的堆栈信息。</p><h3 id="4-2-3-trace-文件解读-线程堆栈信息"><a href="#4-2-3-trace-文件解读-线程堆栈信息" class="headerlink" title="4.2.3 trace 文件解读-线程堆栈信息"></a>4.2.3 trace 文件解读-线程堆栈信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;ReferenceQueueDaemon&quot;</span> daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">tid</span>=6 Waiting<br>  | <span class="hljs-attribute">group</span>=<span class="hljs-string">&quot;system&quot;</span> <span class="hljs-attribute">sCount</span>=1 <span class="hljs-attribute">ucsCount</span>=0 <span class="hljs-attribute">flags</span>=1 <span class="hljs-attribute">obj</span>=0x20030b8 <span class="hljs-attribute">self</span>=0x730000598a472000<br>  | <span class="hljs-attribute">sysTid</span>=1557 <span class="hljs-attribute">nice</span>=4 <span class="hljs-attribute">cgrp</span>=foreground <span class="hljs-attribute">sched</span>=0/0 <span class="hljs-attribute">handle</span>=0x70496d0730<br>  | <span class="hljs-attribute">state</span>=S schedstat=( 1359509621 111263835 448 ) <span class="hljs-attribute">utm</span>=110 <span class="hljs-attribute">stm</span>=25 <span class="hljs-attribute">core</span>=6 <span class="hljs-attribute">HZ</span>=100<br>  | <span class="hljs-attribute">stack</span>=0x70495cd000-0x70495cf000 <span class="hljs-attribute">stackSize</span>=1037KB<br>  | held mutexes=<br>  at java.lang.Object.wait(Native method)<br>  - waiting on &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Object.wait(Object.java:405)<br>  at java.lang.Object.wait(Object.java:543)<br>  at java.lang.Daemons<span class="hljs-variable">$ReferenceQueueDaemon</span>.runInternal(Daemons.java:260)<br>  - locked &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Daemons<span class="hljs-variable">$Daemon</span>.<span class="hljs-built_in">run</span>(Daemons.java:132)<br>  at java.lang.Thread.<span class="hljs-built_in">run</span>(Thread.java:1119)<br>DumpLatencyMs: 90.8357<br></code></pre></td></tr></table></figure><ul><li>第1行：<ul><li><strong>线程名</strong>：ReferenceQueueDaemon</li><li><strong>daemon</strong>：有此则代表守护线程（生命周期和进程的生命周期一样长）</li><li><strong>prio</strong>：（Priority）线程优先级</li><li><strong>tid</strong>：线程在进程内的序号（主线程tid&#x3D;1，其他线程依次递增）</li><li><strong>Waiting</strong>：线程状态（Java层面）常见还有Native、TimedWaiting、Sleeping、Blocked、Runnable。</li></ul></li><li>第2行：<ul><li><strong>group</strong>：线程所属的线程组，Java代码遗漏下来的，没有什么实际作用。</li><li><strong>sCount</strong>：Suspend Count 线程挂起次数（这里是art runtime 垃圾回收中的概念：GC时，要将线程挂起，执行GC操作）。</li><li><strong>ucsCount</strong>：用户主动使用代码导致线程挂起的次数（区别于sCount，这里主动调用代码挂起，前者是ART机制）。</li><li><strong>obj</strong>：保存着当前线程关联Java线程的对象地址（在虚拟机中从线程是以native的形式c++层thread存在，native线程要想访问java对象必须先保存Java线程对象的地址）。</li><li><strong>self</strong>：当前线程的地址</li></ul></li><li>第3行：<ul><li><strong>sysTid</strong>：线程号</li><li><strong>nice</strong>：调度优先级</li><li><strong>cgrp&#x3D;foreground</strong>：cgroup中进程所属调度组(常见有：foreground、top-app等)</li><li><strong>sched&#x3D;0&#x2F;0</strong>：调度策略（0 ：SCHED_NORMAL（也叫 SCHED_OTHER，普通时间共享，最常见）1 ：SCHED_FIFO（实时，先入先出）2 ：SCHED_RR（实时，轮询）3 ：SCHED_BATCH（批量）5 ：SCHED_IDLE（空闲线程）6 ：SCHED_DEADLINE（实时 deadline））。</li><li><strong>handle</strong>：native线程句柄</li></ul></li><li>第4行：<ul><li><strong>state&#x3D;S</strong> ：线程内核级别的调度状态（区别于运行时的线程状态，常见：Z：僵尸、D：不可中断休眠、S：可中断休眠、R：运行、T：停止）。</li><li><strong>schedstat</strong>&#x3D;( 1359509621 111263835 448 )：CPU调度时间统计（Running运行时间、Runable等待调度时间、SwitchCPU调度切换次数）， 见<code>proc/[pid]/task/[tid]/schedstat</code>.。在分析两份trace文件堆栈前后是否一致，是否卡死到同一位置，我们可以拿这几个值作为参考。</li><li><strong>utm</strong>&#x3D;110 ：线程在用户态所执行的时间</li><li><strong>stm</strong>&#x3D;25 ：线程在内核态所执行的时间</li><li><strong>core</strong>&#x3D;6 ：线程最后运行所在CPU的核</li><li><strong>HZ</strong>&#x3D;100：时钟频率</li></ul></li><li>第5行：<ul><li><strong>stack</strong>&#x3D;0x70495cd000-0x70495cf000：线程栈的地址空间</li><li><strong>stackSize</strong>&#x3D;1037KB：栈大小</li></ul></li><li>第6行：<strong>held mutexes</strong>：线程持有的mutexes</li><li>第7行：往下就是线程的调用堆栈：</li></ul><p>从问题排查的角度我们第一眼主要看到的是线程的状态（运行时）</p><ul><li><strong>Native</strong>：运行native层代码</li><li><strong>Waiting</strong>：线程等待</li><li><strong>TimedWaiting</strong>：线程定时等待</li><li><strong>Sleeping</strong>：线程主动Sleep</li><li><strong>Blocked</strong>：等待锁资源释放</li><li>…</li></ul><p>根据状态再看线程的调用栈，来确认是否是该线程中执行的代码逻辑有问题。</p><p>线程的调用堆栈反应线程此时在执行什么代码，那么在一个良好运作的系统中，线程的调用堆栈是什么样的呢？<br>在Android系统中和线程图中描述的一样并没有那么复杂,有一些基础功能的线程,有Binder线程,有普通的线程池线程。总体来说，除了一些基础功能的守护线程之外，其他<strong>线程模型</strong>主要有两种：</p><ul><li>通过<code>epoll</code>机制监测fd封装的线程模型。</li><li>Binder线程循环通过系统调用ioctl不断从Binder驱动读取消息线程模型。</li><li>其他</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//epoll 机制线程模型--正常等待新消息的到来</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5ff8  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+<span class="hljs-number">8</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 00018c2c  /system/lib64/libutils.so (android::Looper::pollInner+<span class="hljs-number">188</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 00018b0c  /system/lib64/libutils.so (android::Looper::pollOnce+<span class="hljs-number">124</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 0018b67c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce+<span class="hljs-number">44</span>) <br>  at android.os.MessageQueue.nativePollOnce(Native method)<br>  at android.os.MessageQueue.next(MessageQueue.java:<span class="hljs-number">335</span>)<br>  at android.os.Looper.loopOnce(Looper.java:<span class="hljs-number">194</span>)<br>  at android.os.Looper.loop(Looper.java:<span class="hljs-number">338</span>)<br>  at android.os.HandlerThread.run(HandlerThread.java:<span class="hljs-number">67</span>)<br> <span class="hljs-comment">//Binder 线程模型--正常读取Binder驱动消息</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5038  /apex/com.android.runtime/lib64/bionic/libc.so (__ioctl+<span class="hljs-number">8</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 000670ac  /apex/com.android.runtime/lib64/bionic/libc.so (ioctl+<span class="hljs-number">156</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 0005f4e4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver+<span class="hljs-number">292</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 000600c8  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">04</span> pc 00060cfc  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool+<span class="hljs-number">732</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">05</span> pc 0006ae08  /system/lib64/libbinder.so (android::PoolThread::threadLoop+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">06</span> pc 000144dc  /system/lib64/libutils.so (android::Thread::_threadLoop+<span class="hljs-number">284</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">07</span> pc 000ec29c  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell+<span class="hljs-number">140</span>)<br>  <span class="hljs-keyword">native</span>: #08 pc 000c9fd0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start+<span class="hljs-number">208</span>)<br>  <span class="hljs-keyword">native</span>: #09 pc 0005dd90  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+<span class="hljs-number">64</span>) <br>  <br></code></pre></td></tr></table></figure><p>我们看到上面两种线程模型的堆栈信息，就是正常的运行形态。对于Binder线程来说，如果线程在等对端返回，通常在talkWithDriver往前的堆栈会调用到涉及对端的一些代码。<br>例如：<br><img src="/blog_imgs/2_watchdog_2/wait_binder_target.jpg" alt="20c9a7104ccafe356245a1b4c2680e8d.jpeg"></p><h3 id="4-2-4-Binder日志解读"><a href="#4-2-4-Binder日志解读" class="headerlink" title="4.2.4 Binder日志解读"></a>4.2.4 Binder日志解读</h3><p><strong>1.binder transaction信息</strong><br>在我们查看Binder交互log中，我们经常看到的就是<code>incoming transaction</code>和<code>outgoing transaction</code>，他们的含义是什么呢？<br>这其实内Binder驱动中Binder交互事务的描述。</p><ul><li><strong>outgoing transaction</strong>–客户端保存，客户端向服务端发起的binder事务请求。</li><li><strong>incoming transaction</strong>–服务端保存，服务端返回给客户端的binder事情请求。</li></ul><p>他们均指向一个binder_transaction，他们均能保存到线程指向的信息。<br>如下例子:<br>无论是<code>outgoing transaction</code>还是<code>incoming transaction</code>，他们都是指向<strong>7640493</strong>这个是kernel中<code>binder_transaction</code>的标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端进程</span><br>proc <span class="hljs-number">27226</span><br>context binder<br>  thread <span class="hljs-number">27226</span>: l <span class="hljs-number">10</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    outgoing transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms<br><br><span class="hljs-comment">//服务端进程</span><br>proc <span class="hljs-number">1467</span><br>context binder<br>  thread <span class="hljs-number">3206</span>: l <span class="hljs-number">01</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    incoming transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms <br></code></pre></td></tr></table></figure><ul><li><code>from 27226:27226 to 1467:3206</code> –<strong>from</strong>:进程27226中线程27226作为客户端访问， <strong>to</strong>:服务端进程1467线程3206线程。</li><li><strong>elapsed</strong>: 访问阻塞时间。</li><li>还有很多其他信息，后面我们剖析Binder驱动再做说明。</li></ul><p><strong>2.kernel中的binder: release</strong></p><p>从上面信息我们知道<code>binder_transaction</code>中保存着线程指向信息，那么拿到这个信息就可以知道线程指向。我们可以在kernel log中看到这样的打印，也能找到对端信息。<br>当客户端进程<code>27226</code>被kill后，binder驱动会将对应的<code>binder_transaction</code>释放掉，所以检索<code>transaction</code>的id(7640493)就能找到binder对端线程为: <code>1467_16</code>即:<code>sysTid=3206</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">147603.943970</span>] [T1726663] kworker/<span class="hljs-number">7</span>:<span class="hljs-number">2</span>: binder: release <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> transaction <span class="hljs-number">7640493</span> out, still active<br>[<span class="hljs-number">147603.949150</span>] [T1003206] binder:<span class="hljs-number">1467_16</span>: binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">7640493</span>, target dead<br><br><span class="hljs-string">&quot;binder:1467_16&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">223</span> Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> ucsCount=<span class="hljs-number">0</span> flags=<span class="hljs-number">1</span> obj=<span class="hljs-number">0x3217730</span> self=<span class="hljs-number">0xb1000050bcbc4000</span><br>  | sysTid=<span class="hljs-number">3206</span> nice=<span class="hljs-number">0</span> cgrp=foreground sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x729ebd3730</span><br>  | state=S schedstat=( <span class="hljs-number">3960678864</span> <span class="hljs-number">3521264239</span> <span class="hljs-number">5438</span> ) utm=<span class="hljs-number">298</span> stm=<span class="hljs-number">97</span> core=<span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x729eadc000</span>-<span class="hljs-number">0x729eade000</span> stackSize=989KB<br>  | held mutexes=<br>....<br></code></pre></td></tr></table></figure><p>以上就是输出log的一些解析。</p><h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5. 案例"></a>5. 案例</h2><p>以下是一些分析解决过的问题案例log。</p><h3 id="5-1-system-server线程死锁"><a href="#5-1-system-server线程死锁" class="headerlink" title="5.1 system_server线程死锁"></a>5.1 system_server线程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%AD%BB%E9%94%81.png" alt="f37b16c23b8661fdc4c3a57ee02744bf.png"><br>该例子中两次trace持锁情况如下，排查代码为客制化代码错误移到<code>synchronized (mGlobalLock) {...}</code>中导致。</p><table><thead><tr><th>lock</th><th>tid&#x3D;203</th><th>tid&#x3D;296</th></tr></thead><tbody><tr><td>0x0ee759b0</td><td>waiting lock &lt;0x0ee759b0&gt;</td><td>locked &lt;0x0ee759b0&gt;</td></tr><tr><td>0x058d9a40</td><td>locked &lt;0x058d9a40&gt;</td><td>waiting lock &lt;0x058d9a40&gt;</td></tr><tr><td>上面表格锁的情况刚好形成一个死循环称为死锁。</td><td></td><td></td></tr></tbody></table><h3 id="5-2-system-server和phone进程死锁"><a href="#5-2-system-server和phone进程死锁" class="headerlink" title="5.2 system_server和phone进程死锁"></a>5.2 system_server和phone进程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_2.png" alt="bbea9be66130474cc77063873c1410ca.png"><br><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_1.png" alt="6fa59e552028af4c7b70f459d662440d.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//binder log</span><br>outgoing transaction <span class="hljs-number">25633452</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">2937</span>:<span class="hljs-number">2937</span> to <span class="hljs-number">1937</span>:<span class="hljs-number">5077</span> code 3a flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1<br><br>binder: release <span class="hljs-number">1937</span>:<span class="hljs-number">3234</span> transaction <span class="hljs-number">25632946</span> out, still active <br>binder: release <span class="hljs-number">2937</span>:<span class="hljs-number">3605</span> transaction <span class="hljs-number">25632946</span> in, still active <br>binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">25632946</span>, target dead<br></code></pre></td></tr></table></figure><p>该例中两份trace文件均如此。</p><table><thead><tr><th>进程</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>system_server</td><td>binder:1937_16线程(sysTid&#x3D;5077)</td><td>等待→</td><td>binder:1937_E线程(tid&#x3D;290)sysTid&#x3D;3234</td></tr><tr><td></td><td>↑等待</td><td></td><td>↓等待</td></tr><tr><td>phone进程</td><td>main线程(sysTid&#x3D;2937)</td><td>←等待</td><td>binder:2937_A线程(tid&#x3D;70)sysTid&#x3D;3605</td></tr></tbody></table><h3 id="5-3-audio进程和system-server进程间死锁"><a href="#5-3-audio进程和system-server进程间死锁" class="headerlink" title="5.3 audio进程和system_server进程间死锁"></a>5.3 audio进程和system_server进程间死锁</h3><p>audio进程和system_server进程死锁导致Binder线程阻塞在其中出现Binder线程耗尽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">----------------------时间:<span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45</span> system_server进程 binder线程不够用 ---最早出现的时间<br><span class="hljs-number">10</span>-<span class="hljs-number">17</span> <span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45.931</span> <span class="hljs-number">1619</span> <span class="hljs-number">1805</span> W IPCThreadState: Waiting <span class="hljs-keyword">for</span> thread to be free. mExecutingThreadsCount=<span class="hljs-number">32</span> mMaxThreads=<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure><p>排查发现trace中所有Binder线程均在等待WMS服务的锁:<code>WindowManagerGlobalLock</code>((蓝色部分)，对应4633线程持有该锁在访问Audio模块的 <code>isStreamActive</code> 方法。<br><img src="/blog_imgs/2_watchdog_2/audio00.png" alt="a4ab3a355233116247152306a33e326a.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[ <span class="hljs-number">95.581437</span>] [T600160] binder: release <span class="hljs-number">855</span>:<span class="hljs-number">984</span> transaction <span class="hljs-number">93929</span> in, still active [ <span class="hljs-number">95.581471</span>] [T600160] binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">93929</span> to <span class="hljs-number">1619</span>:<span class="hljs-number">4633</span><br></code></pre></td></tr></table></figure><p>进一步排查发现,audio发生了NE(在audio中有binder超时监测机制，当超时到达超时直接会直接NE，进程重启)。<br>在main log的audio打印中日志中发现audio进程中的984线程执行 <code>isStreamActive</code> 似乎在等锁 <code>Mutex::Autolock _l(mLock)</code>。<br><img src="/blog_imgs/2_watchdog_2/audio0.png" alt="087a02a8d769c50e35c1d3b6db5abd1f.png"><br>进一步我们发现main log中audio模块还有相关持有 <code>Mutex::Autolock _l(mLock)</code> 的堆栈信息,audio进程中的2945线程执行listAudioPorts 方法持锁 <code>Mutex::Autolock _l(mLock)</code> 并通过 <code>mustAnonymizeBluetoothAddress</code> 需要进一步访问system_server的权限管理服务。<br><img src="/blog_imgs/2_watchdog_2/audio1.png" alt="ee0a7b9093c50afcc7e28d845eba818e.png"></p><p>上述流程存在audio和system_server进程间死锁情况。</p><h3 id="5-4-堆栈看似相同实则不同-耗时异常"><a href="#5-4-堆栈看似相同实则不同-耗时异常" class="headerlink" title="5.4 堆栈看似相同实则不同,耗时异常"></a>5.4 堆栈看似相同实则不同,耗时异常</h3><p>前后两次dump的trace文件阻塞点,粗略看一致(绿色部分)，仔细看堆栈不一致(其他颜色部分)， 客制化代码耗时导致。<br><img src="/blog_imgs/2_watchdog_2/same_backtrace.png" alt="7815c48c6755fe0070ac293716aeb34c.png"></p><h3 id="5-5-三把锁导致的死锁"><a href="#5-5-三把锁导致的死锁" class="headerlink" title="5.5 三把锁导致的死锁"></a>5.5 三把锁导致的死锁</h3><p>主线程<code>tid=1</code>等待线程<code>378</code>紫色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_1.png" alt="6602a76a3aaa54e8b7291478da2fcf5d.png"><br>线程<code>378</code>等待线程<code>369</code>红色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_3.png" alt="c1bec46d21e004b379bad921350057c9.png"><br>线程<code>369</code>等待线程<code>1</code>蓝色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_2.png" alt="1f7667b560ce6178895cb74ab032499e.png"></p><h3 id="5-6-kernel模块异常"><a href="#5-6-kernel模块异常" class="headerlink" title="5.6 kernel模块异常"></a>5.6 kernel模块异常</h3><p><code>system_server</code>中动画线程等待<code>Binder</code>对端返回,从代码来看对端未SF进程。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_1.png" alt="af25851c06a8d990a61d3c1d3e8cd1ab.png"><br>查看对应接口,发现SF线程<code>1247</code>等待主线程<code>775</code>。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_2.png" alt="6e6d0c5df46ec6d82c85ed552ec8a363.png"><br>SF主线程等待<code>Binder</code>对端返回对端为<code>728</code>线程,查看堆栈,发现未能dump出来。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_3.png" alt="1e83be08823e434a2be7d8126e130390.png"><br>最后查看kernellog中dump出来的kernel异常D状态进程信息,发现728存在D状态阻塞在模块A,需要<strong>模块A</strong>排查异常。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_4.png" alt="fad3207864cbc9f3900d939ecdc7f479.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过两篇文章，SWT问题中的watchdog原理我们基本上已经梳理清楚。文章开始围绕着system_server中存在的两个问题开始讲起，以及到后面的不断补充完善，提及输入的日志，分析了输出的日志信息，并且根据日志提供了遇到过的一些SWT案例分析日志来阐述system_server中的watchdog原理。总结为以下几点：</p><ul><li>问题一细化</li><li>问题二细化</li><li>日志讲解</li><li>案例分析</li></ul><p>最后再提出一个问题：<br>system_server中存在的问题，使用一个watchdog线程来做监控，大家有没有想过万一watchdog线程异常了怎么办（虽然概率小，但还是存在）？watchdog线程监控功能不就失效了吗？手机还是会一直卡死。那么怎么解决这个新问题或者怎么监控这个问题？</p><blockquote><p>难道我们我们再使用一个system_server中的线程A来监测吗？万一线程A又异常了怎么办？使用线程B…C…<br>虽然问题概率低，并且上面的方式不行，但是我们还是得监控。我们能否使用一个内核的进程&#x2F;模块来监控它呢？<br>——可行，MTK:Hang_detect机制、展锐：Native_Hang机制</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Sports</category>
      
      <category>Baseball</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>SWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android system_server中watchdog机制介绍（上）</title>
    <link href="/2025/03/23/1_watchdog_%E4%B8%8A/"/>
    <url>/2025/03/23/1_watchdog_%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-system-server进程存在哪些问题？"><a href="#1-system-server进程存在哪些问题？" class="headerlink" title="1. system_server进程存在哪些问题？"></a>1. system_server进程存在哪些问题？</h2><p>在整个<code>Android</code>系统中最为重要的一个进程就是<code>system_server</code>进程，对于应用程序来说<code>system_server</code>进程提供应用进程所需的一切，<code>system_server</code>进程的正常工作是整个手机系统正常运行的保障，这样用户才能够顺利使用手机。</p><ul><li><p><strong>问题一</strong>：<br>在我们开发者的眼中，一个复杂功能的进程中往往包含了各个线程，并且将复杂功能拆分成各个模块，使用各个线程运行各个功能模块的逻辑，将各个功能联动起来。<code>system_server</code>进程的功能非常复杂，使用的线程也非常多。各个功能被抽象成一个个服务，例如和应用程序界面显示相关的<code>WMS</code>（WindowManagerService）服务，和应用组件相关的<code>AMS</code>（ActivityManagerService）服务等，这些服务在<code>system_server</code>进程中以一个个对象实例的形式存在（单例）。从设计的角度来讲，这些服务也是分等级的，有些服务稍显得没那么重要，有些服务例如和窗口显示相关的WMS服务、和应用组件相关的AMS服务等都是比较重要的。<code>system_server</code>进程作为其他进程的数据处理中心，基本所有进程都访问<code>system_server</code>中的各个服务，如果两个应用进程同时访问<code>system_server</code>中的同一个服务，因为服务本身只有一个不可能让所有进程都同时访问到，那么只能排队访问，一个一个访问。那么<code>system_server</code>如何让他们轮着访问呢？答案就是使用锁-对象锁，每个服务都有自己对象锁，使用锁的形式来保证顺序访问。<br><strong>举例</strong>:当进程A来访问<code>system_server</code>中的<code>AMS</code>服务时候那么就先持有<code>AMS</code>实例的对象锁。访问完则释放给其他进程使用，这样又有了新的问题：万一<code>AMS锁</code>被某个流程长期的占用一直不释放怎么办，出现长时间持锁，另外一个情况就是多线程的使用，当各模块服务之间交互的时候就可能出现死锁异常，所以目前可能会出现的两个问题就是：代码流程耗时、逻辑出现死锁。两个问题引起线程长时间持锁的异常，造成<code>system_server</code>卡死，其他进程就无法根本无法使用访问到对应服务，这样系统不就长时间卡死了吗？那么我们要如何解决这个问题呢？</p></li><li><p><strong>问题二</strong>：<br>其次，这些服务逻辑功能的实现离不开各个线程的运行，在<code>system_server</code>中线程也是分作用和功能的，有负责整个<code>system_server</code>进程初始化工作的主线程：<code>main</code>线程，显示相关的<code>android.display</code>线程，动画相关的<code>android.anim</code>线程，用来处理各个客户端应用进程的逻辑的31个<code>binder线程</code>等等。由于线程的分工不一样，他们的重要性就不一样，像<code>main</code>、<code>ui</code>、<code>display</code> 等这些关键的线程处理事务时候是不能出现长时间卡死的，不能长时间只处理一个事务。这样在用户体验上就是极度的顿卡，那么我们如何解决这样的问题呢？</p></li></ul><h3 id="1-1-需要解决的问题"><a href="#1-1-需要解决的问题" class="headerlink" title="1.1 需要解决的问题"></a>1.1 需要解决的问题</h3><p>针对上面的描述目前我们要解决的问题：</p><ul><li>各个关键服务（<code>AMS</code>、<code>WMS</code>、<code>IMS</code>等）不能被某一逻辑长时间占用，即关键服务的对象锁不能被某些线程长时间的持有（死锁，逻辑异常等）</li><li>各个关键线程（<code>main</code>、<code>i/o</code>、<code>ui</code>、<code>display</code>等）不能出现耗时，即关键线程的消息要及时处理完</li></ul><h2 id="2-思考如何解决问题"><a href="#2-思考如何解决问题" class="headerlink" title="2. 思考如何解决问题"></a>2. 思考如何解决问题</h2><p>所以我们要怎么解决这两个问题呢？</p><blockquote><p>答案： 程序员优化代码逻辑。额。。。但情况确实就是这样的，但是起码要让程序员知道哪些逻辑是异常的，所以从<code>system_server</code>的角度来讲我们要对上面问题场景进行监测，当监测到问题时我们将所需日志完整的输出出来，交给程序员解决。</p></blockquote><p>这也就引出了我们今天的主题：<code>system_server</code>进程中的<code>watchdog监测机制</code>。<br>（请注意它是个监测机制，基本上所有的稳定性问题都有对应的监测机制，要分析稳定性问题就要先熟悉对应的监测机制）</p><p>在<code>system_server</code>中我们采取的策略是：我们使用一个新的线程（<code>watchdog线程</code>）来监测上面两个问题，当问题发生时我们将日志保留下来，提供给程序员分析解决异常点（当然这里使用一个线程来进行监测也会有问题，例如<code>watchdog线程</code>卡死了怎么办，难道再使用一个线程来监控吗？这又可以引出另外一个专题，暂时先不多展开）。</p><p>当然这是从我们程序员的角度来看，我们只需要查看日志并解决问题即可。但是从用户体验的角度上来看，出现问题时手机将会长时间顿卡，当问题包含死锁等情况时候，手机可能会一直卡死。在使用可拆卸电池手机的年代，我们用户可以将电池拆下来，直接断电重启可以解决问题。而今电池和手机是封装在一块的，出现这种问题就只能等待手机电量耗尽手机重启才能恢复，这对于用户来说是体验很糟糕的，所以我们要在<code>watchdog机制</code>中制定一个标准，通过手机卡住的时间来衡量问题的严重性，卡住的时间超过用户能忍受的时间直接触发手机重启，让用户能够恢复手机的使用。</p><p>所以目前<code>watchdog机制</code>要解决的问题进一步细化：</p><ul><li>检测关键服务的对象锁是否被某线程长时间占用（死锁、逻辑耗时阻塞），异常情况输出日志</li><li>检测关键线程运行逻辑是否阻塞，异常情况输出日志</li><li>根据异常的时间长短，划分异常的严重性，长时间异常则重启手机，短时间异常则尽可能输出日志让程序员能够知道问题的原因</li></ul><p>针对这上面提出的三个点我们需要怎么样设计代码</p><h2 id="3-如何设计Watchdog机制？"><a href="#3-如何设计Watchdog机制？" class="headerlink" title="3. 如何设计Watchdog机制？"></a>3. 如何设计Watchdog机制？</h2><p>因为我们无法真正从代码设计者的角度去剖析这个代码的由来（因为代码不是我们设计的，但是我们可以通过读代码来反推作者可能这样设计的原因，我查阅了历史watchdog的源码，发现现有Android 15的Watchdog框架延续的是android-4.4.4_r1的watchdog版本,历经10多个版本框架原理基本没有改变，和android-4.4.4_r1以前的watchdog框架基本截然不同，说明android-4.4.4_r1的watchdog代码很健壮）</p><h3 id="3-1-system-server的功能和线程情况"><a href="#3-1-system-server的功能和线程情况" class="headerlink" title="3.1 system_server的功能和线程情况"></a>3.1 system_server的功能和线程情况</h3><p>在此之前我们需要了解一下system_server的功能以及线程的情况，才能更好的结合问题点来设计解决问题的方案。<br>（dump出<code>system_server</code>中启动所有binder服务：<code>adb shell dumpsys system_server_dumper</code>）</p><p><img src="/blog_imgs/1_watchdog_1/Image.png" alt="bc8d1d931735e23f805b22208bb33b6b.png"></p><p>不完全统计可能有100+个服务运行在system_server进程之上，我们要监控比较重要的服务对象：<br>考虑的点（猜测）：和用户进程交互比较频繁的服务，功能比较复杂比较多的服务，功能越多越复杂，线程交叉使用得多越容易死锁，例如如下这些服务：</p><ul><li>StorageManagerService</li><li>MediaProjectionManagerService</li><li>MediaRouterService</li><li>InputManagerService</li><li>PowerManagerService</li><li>WindowManagerService</li><li>ActivityManagerService</li></ul><p>各个服务模块逻辑的实现离不开<code>system_server</code>的各个线程，主要包含下面的一些线程（不完全功能按照来进行划分，粗略统计线程数量300+）</p><p><img src="/blog_imgs/1_watchdog_1/Image_1.png" alt="95a32af7d527a1dfb76b3f20ed66f62c.png"></p><ul><li>橘黄色框图：各个服务模块的线程，线程名和模块相关</li><li>绿色框图：重要的系统线程，按照线程处理的事务类型来进行划分，说白了就是<strong>公共线程</strong>，其他模块要是要处理的事务符合对应线程处理的事务类型，他就可以使用该线程来处理自己的事务。</li><li>橙色框图：Binder线程，用于和其他进程交互</li><li>蓝色框图：基础线程，每个Android应用进程都基本配备的线程</li><li>紫灰色框图：起辅助作用普通线程，线程池线程，和Hal层服务交互的HWBinder线程</li></ul><p>整个<code>system_server</code>进程从功能和线程的角度来看就上图的描述那样。<br>简单介绍如下线程</p><ol><li><p>基础线程（apk进程也是如此）<br>1.1 <strong>基础线程：main</strong>： 主线程初始化工作，<br>1.2 <strong>基础线程：守护线程</strong>:<br>1.2.1 <code>ReferenceQueueDaemon</code> 垃圾回收相关：清理Java引用对象，<br>1.2.2 <code>FinalizerDaemon</code> 垃圾回收相关：清理重写finalize()的对象，<br>1.2.3 <code>FinalizerWatchdogDaemon</code>：垃圾回收相关：监测 FinalizerDaemon线程，<br>1.2.4 <code>Signal Catcher</code>：信号处理函数，堆栈dump工作<br>1.2.5 <code>HeapTaskDaemon</code>：垃圾回收相关：堆内存<br>1.2.6 <code>Profile Saver Android</code> 混合编译相关<br>1.2.7  <code>Jit thread pool worker thread</code>:JIT即时编译相关</p></li><li><p><strong>Binder线程</strong>：和Binder驱动紧密相连，是其他进程和system_server进程交互的重要桥梁<br>2.1 binder:Pid_N(1-20,A-F,1A-1F) &#x3D; 20+6+6&#x3D;32个，包含1个binder主线程和31个binder普通线程<br>2.2 HwBinder</p></li><li><p><strong>普通线程</strong>：<br>3.1 pool-X-thread-Y: 线程池产生的线程,可复用<br>2.2 Thread-N：普通线程，不可复用</p></li><li><p><strong>各服务功能线程</strong>：线程名和功能相关</p></li><li><p><strong>系统公共线程</strong>：</p></li></ol><table><thead><tr><th>Name</th><th>priority</th><th>作用</th></tr></thead><tbody><tr><td>android.fg</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>前台公共线程，该线程设计的特别之处就是当处理的消息有超时的情况就会打印出来，它要求处理的消息要快，我们在system log能看到：Slow delivery XX等等log就是这里设置的</td></tr><tr><td>android.ui</td><td>THREAD_PRIORITY_FOREGROUND &#x3D; -2</td><td>处理系统进程UI相关的事务，它是一个fg线程（有消息超时会打印日志），和上面的fg线程不同的是它属于一个进程的Group中（THREAD_GROUP_TOP_APP &#x3D; 5），因为显示UI要进行额外的加速处理和CPU调度策略相关</td></tr><tr><td>android.io</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>文件读写相关的事务，无耗时监控</td></tr><tr><td>android.display</td><td>THREAD_PRIORITY_DISPLAY +1&#x3D; -4  +1 &#x3D;-3</td><td>处理系统显示事务相关（WindowManager，DisplayManager，InputManager使用），拥有较高线程优先级，无耗时监控</td></tr><tr><td>android.anim</td><td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td><td>处理系统动画相关的事务（窗口动画，启动动画等），线程优先级 ，无耗时监控</td></tr><tr><td>android.anim.lf</td><td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td><td>处理系统动画相关的事务和Vsync相关，线程优先级</td></tr><tr><td>android.bg</td><td>THREAD_PRIORITY_BACKGROUND &#x3D; 10</td><td>后台线程，公共使用，有耗时监控</td></tr><tr><td>android.perm</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>权限处理相关公共线程，有耗时监控</td></tr><tr><td>android.usagestats</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>usagestatus数据处理相关 ，有耗时监控</td></tr></tbody></table><p><strong>watchdog监控的线程</strong>：处理逻辑较多，和用户体验挂钩，窗口显示，动画，UI显示.</p><h3 id="3-2-如何进行监控？"><a href="#3-2-如何进行监控？" class="headerlink" title="3.2 如何进行监控？"></a>3.2 如何进行监控？</h3><ul><li><strong>监测重要线程</strong>：只需要通过<code>watchdog</code>监控线程给对应线程发送一条消息，看对应线程在对应时间能不能处理完就行，不能执行完成，则可能线程出现阻塞</li><li><strong>监测重要对象</strong>：只需要通过<code>watchdog</code>监控线程去使用一次对应对象，即获取一下对象锁能不能获取得到，不能获取到，则对象被某一线程长时间占用，可能线程出现阻塞.目前<code>watchdog</code>设置的时间是<strong>30s</strong>去检测一次（为什么是<strong>30s</strong>，这个我暂时无从考证，可能是由于一分钟&#x3D;60s&#x3D;2个30s）</li></ul><p>第一点较容易实现，<code>watchdog线程</code>向各个线程发送一条消息，在规定时间内是否及时响应。</p><p>第二点稍微难一点，我们的实现方式是：各个重要服务对象都实现一个持锁的方法即可，方法主动使用<code>synchronized</code> (自身服务对象锁)获取一次锁，规定时间内是否能及时获取到。</p><p>目前我们可以根据问题得到下图，<code>watchdog线程</code>给每个重要的线程发消息</p><p><img src="/blog_imgs/1_watchdog_1/Image_2.png" alt="34d72c510426dd1ed301261c8ddc39ab.png"></p><p>对于第二点，需要都调用各个重要服务的该方法来完成一次检查，这里和第一点有相似之处的实现逻辑：都是需要去检查是否出现耗时，所以第二点逻辑实现上我们可以抽象一下（Java中面向对象）：使用单独一个线程去做获取各个重要服务对象锁这件事情。</p><p>那么目前得到下图，我们新增加了一个线程：<code>watchdog:monitor</code>,watchdog线程的事情就变成：给包括<code>watchdog.monitor</code>在内的重要线程发送一条消息，如果消息不能定时处理完成则异常，否则正常。</p><p><img src="/blog_imgs/1_watchdog_1/Image_3.png" alt="b60af6764cd22190019181812416f28d.png"></p><p>以上就是<code>watchdog框架</code>的树干部分，从现在我们就可以去梳理代码，将细枝末节的树叶补充完整。(我会先提出问题再回答这种形式来逐个将细节呈现出来)</p><h3 id="3-3-代码实现一：问题的抽象"><a href="#3-3-代码实现一：问题的抽象" class="headerlink" title="3.3 代码实现一：问题的抽象"></a>3.3 代码实现一：问题的抽象</h3><p>对于上述的图片中我们大概框架已经显现出来了<br>问题：对于我们<code>watchdog线程</code>只需要做的事情就是隔一段时间就发个消息去监测一下各个重要线程（新增加的<code>watchdog.monitor</code>&#x2F;<code>main</code>&#x2F;<code>android.fg</code>&#x2F;<code>android.ui</code>等）是否阻塞就行，那么我们使用什么数据结构来保存这些重要线程呢？或者我们是否重新将这些线程和其他因素考虑在一起封装成一个新的对象呢？<br>考虑因素：</p><ul><li>对于<code>watchdog线程</code>发消息去<code>check</code>各个线程这个事情，了解<code>Android线程模型</code>的的都知道，其实本质就是获取对应线程的handler调用<code>mHandler.postAtFrontOfQueue</code>发送消息即可，即通过<code>Handler</code>去<code>check</code>各个线程是否阻塞–&gt;<strong>HandlerChecker</strong><ul><li><code>(main)Handler.postAtFrontOfQueue</code></li><li>…</li><li><code>(android.fg)Handler.postAtFrontOfQueue</code></li></ul></li><li>假如我们现在有一个模块线程想要被watchdog线程监测，但是我只想watchdog来检测我的时候，由于我模块功能的特殊性检测时候只要我线程10s内不阻塞就行，因此需要提供一个客制化超时时间的方法—&gt;<strong>AndTimeout</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;HandlerCheckerAndTimeout&gt; mHandlerCheckers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()<br></code></pre></td></tr></table></figure><p>所以<code>HandlerCheckerAndTimeout</code>实际上就是要保存各个检测线程的<code>handler</code>，以及特别定制化的超时时间<code>timeout</code>。所以我们进一步看<code>HandlerCheckerAndTimeout</code>的成员有<code>mHandler</code>以及客制化超时时间<code>mCustomTimeoutMillis</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Holds a checker and its timeout. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerCheckerAndTimeout</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HandlerChecker mHandler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;Long&gt; mCustomTimeoutMillis;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HandlerCheckerAndTimeout</span><span class="hljs-params">(HandlerChecker checker, Optional&lt;Long&gt; timeoutMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mHandler = checker;<br>        <span class="hljs-built_in">this</span>.mCustomTimeoutMillis = timeoutMillis;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">//其他方法容易理解类似get/set这样的方法故省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用一个<code>ArrayList</code> 来保存各个检测的对象，所以在<code>watchdog</code>初始化时候会将<code>mHandlerCheckers</code>填满，将各个检测对象<code>add</code>到对应成员中，这里大家可以看一下<code>watchdog</code>的构造函数即可。</p><ul><li>运行<code>watchdog线程</code></li><li>将新的<code>watchdog.monitor线程</code>运行起来并加入监测列表中</li><li>将其他重要监测线程加入到监测列表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>    mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::run, <span class="hljs-string">&quot;watchdog&quot;</span>);<br>    <br>    <span class="hljs-type">ServiceThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceThread</span>(<span class="hljs-string">&quot;watchdog.monitor&quot;</span>,<br>            android.os.Process.THREAD_PRIORITY_DEFAULT, <span class="hljs-literal">true</span> <span class="hljs-comment">/*allowIo*/</span>);<br>    t.start();<br>    mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(t.getLooper()), <span class="hljs-string">&quot;monitor thread&quot;</span>, mLock);<br>    mHandlerCheckers.add(withDefaultTimeout(mMonitorChecker));<br><br>    mHandlerCheckers.add(<br>            withDefaultTimeout(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(), <span class="hljs-string">&quot;foreground thread&quot;</span>, mLock)));<br>    <span class="hljs-comment">//...相似实现</span><br><br>    <span class="hljs-comment">// Initialize monitor for Binder threads.</span><br>    addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>());<span class="hljs-comment">//后面在提</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到图四，我们虽然抽象出了<code>HandlerCheckerAndTimeout</code>（<code>handler</code>和<code>客制化timeout</code>），但是我们想一下，我们<code>watchdog.monitor线程</code>检查工作和其他线程（例如<code>main线程</code>）检查工作完全不一样，其他线程只需要调用<code>Handler.postAtFrontOfQueue</code>即可，<code>watchdog.monitor线程</code> 需要逐个便利各个服务对象实例的方法去进行持锁检查。为了功能的实现我们当然分开去实现，但是为了代码统一，减少额外的代码，我们能否将将两个<code>check事项</code>抽象为一个新的类？</p><p>可以，我们将两个事项进一步抽象<code>HandlerChecker</code>，并且在<code>HandlerChecker</code>中将两个<code>check事项</code>区分开来就行。<br>我们将<code>watchdog.monitor线程</code>需要<code>check</code>的一个个重要服务称为一个个<code>monitor</code>，对应每个重要服务都实现对应的方法来完成自身模块是否异常的逻辑（对于monitor()方法的实现,大多数模块直接获取当前模块的同步锁对象即可，一些特殊的模块可以根据模块自定义实现例如：StorageManagerService 服务则直接调用Vold进程的相关方法来判断自身模块的阻塞情况）<br>（我们可以在源码搜<code>Watchdog.Monitor</code>关键字就可以知道watchdog.monitor线程一共监测这多少个重要服务他们分别是什么）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象接口继承此接口即可实现自己服务的耗时逻辑监控</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Monitor</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>所以HandlerChecker中我们要使用一个数据结构来保存watchdog.monitor的监测对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Monitor&gt;();<span class="hljs-comment">//保存watchdog.monitor线程的监测对象:各个重要服务对象的实例</span><br><br>    <span class="hljs-comment">//watchdog线程触发的接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">(<span class="hljs-type">long</span> handlerCheckerTimeoutMillis)</span> &#123;<br>        ...<br>        mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//message具体检查事务逻辑细节:</span><br>    <span class="hljs-comment">//也是watchdog.monitor和其他main，android.ui等HandlerCheckers区别的关键</span><br>    <span class="hljs-comment">//* HandlerCheckers:watchdog.monitor 循环遍历各个monitor调用对应的monitor方法持锁排查</span><br>    <span class="hljs-comment">//* HandlerCheckers:main/android.ui/android.fg等，写一个标志位代表我的线程已经按时执行完成了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//下面这个循环主要是watchdog.monitor线程执行调用，只有HandlerCheckers：watchdog.monitor有monitor成员</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mMonitors.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCurrentMonitor = mMonitors.get(i);<br>            &#125;<br>            mCurrentMonitor.monitor();<br>        &#125;<br>        <span class="hljs-comment">// 所有的HandlerCheckers都写一个标志位，代表我的线程已经顺利完成检查工作</span><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>            mCurrentMonitor = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中我们能看到使用list来保持monitor对象。以及发送的message的实现（run()）<br>所以目前我们<code>watchdog框架</code>中的<code>HandlerCheckers</code>梳理框架图如下图：</p><p><img src="/blog_imgs/1_watchdog_1/Image_4.png" alt="eddf82180df94170ee26ec6641f059cb.png"></p><p>在mHandlerCheckers中保存了众多的HandlerChecker，仔细分类可以分为：Monitor Checker和Hander Checker</p><ul><li><strong>Monitor Checker</strong>，用于检查是Monitor对象可能发生的”卡死“, <code>AMS</code>, <code>PKMS</code>, <code>WMS</code>等核心的系统服务都是<code>Monitor</code>对象，通过<code>watchdog.monitor</code>线程来检查。</li><li><strong>Handler Checker</strong>, 纯粹意义上的HandlerChecker,主要检测各个线程消息处理是否阻塞</li></ul><p><strong>补充</strong>：Binder线程是其他进程和system_server进程交互的通道，一共32个线程，当这32个线程出现阻塞，或者都繁忙无法继续处理来自其他进程的交互，这个时候会导致异常，系统也会出现卡死。我们需要对这种异常进行监控，所以添加一个monitor：<code>BinderThreadMonitor</code>交给<code>watchdog.monitor</code>线程来监控，所以我们在玫红色框图中看懂一个灰色的<code>monitor</code>成员。所以对于<code>Monitor Checker</code>进一步区分分为：<strong>普通服务监控monitor</strong>和<strong>binder线程监控monitor</strong></p><p>根本上这两类HandlerChecker就是对应着文章开头提出的两个问题1和问题2。（这两个概念比较重要，对于SWT问题的分析特别重要）</p><h3 id="3-4-代码实现二：异常的衡量"><a href="#3-4-代码实现二：异常的衡量" class="headerlink" title="3.4 代码实现二：异常的衡量"></a>3.4 代码实现二：异常的衡量</h3><p>上面的<code>check项</code>，我们都已经抽象完成。那么我们的一个<code>HandlerChecker</code>出现卡死究竟<strong>卡死多久才算异常呢？有没有一个衡量标准？</strong></p><p>阻塞卡死都归结到<code>HandlerChecker</code>是否正常，我们给每个<code>HandlerChecker</code>都设置一个状态值：state，代表<code>HandlerChecker</code>的阻塞程度</p><p>默认的标准是这样的：</p><table><thead><tr><th>state 状态</th><th>timeout</th><th>作用</th></tr></thead><tbody><tr><td>COMPLETED</td><td>timeout &#x3D;0</td><td>当HandlerChecker正常情况下不阻塞，线程能够瞬间的完成message的事务，状态良好</td></tr><tr><td>WAITING</td><td>0&lt;timeout &lt;30s</td><td>当HandlerChecker出现阻塞，线程能够30s内完成message的事务，稍微耗时可能能恢复</td></tr><tr><td>WAITED_HALF</td><td>30s&lt;timeout &lt;60s</td><td>当HandlerChecker出现阻塞，线程能够30s-60s内完成message的事务，耗时以及过半了，可能阻塞恢复不了了</td></tr><tr><td>OVERDUE</td><td>60s&lt;timeout</td><td>当HandlerChecker出现阻塞，线程能够60s都完成不了message的事务，耗时超过1分钟，完了，用户现在可能极度不满</td></tr></tbody></table><p><img src="/blog_imgs/1_watchdog_1/Image_5.png" alt="ec73f97d532c22b08cbc129770c49e68.png"></p><p>判断系统卡死的事情基本解决完毕,<strong>那么我们需要什么时机输出日志呢?以及需要输出那些日志呢?</strong></p><p><code>watchdog线程</code>使用一个死循环,每隔<code>30s</code>去<code>check</code>一次各个<code>HandlerChecker</code>,获取各个<code>HandlerChecker</code>的状态是否正常.</p><ul><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>COMPLETED,WAITING</code>),卡<strong>0-30s</strong>内我们认为可以接受,等下一个<code>30s</code>再去检查一次</li><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>WAITING_HALF</code>),卡<strong>30s-60s</strong>系统可能存在问题了,需要dump一些log,再等下一个<code>30s</code>去检查一次</li><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>OVERDUE)</code>,卡<strong>大于60s</strong>,系统已经出现问题,用户以及无法使用手机超过1分钟了,可能死锁了等严重阻塞问题,我们需要dump所有必要的日志,重启手机,让用户能恢复使用</li></ul><p>伪代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">run() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>        <span class="hljs-comment">//step2:休眠30s</span><br>        <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>android-4.4.4_r1的watchdog的部分检查代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                hc.scheduleCheckLocked();<br>            &#125;<br>            <span class="hljs-comment">//step2:休眠30s</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(timeout);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Log.wtf(TAG, e);<br>                &#125;<br>                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);<br>            &#125;<br>            <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>            <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                <span class="hljs-comment">// 情况良好,下次继续检查</span><br>                waitedHalf = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                <span class="hljs-comment">// 可能存在阻塞,时间可控,下次继续检查</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                <span class="hljs-comment">// 存在阻塞,时间超过30s,dump日志,下次继续检查</span><br>                <span class="hljs-keyword">if</span> (!waitedHalf) &#123;<br>                    ArrayList&lt;Integer&gt; pids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                    pids.add(Process.myPid());<br>                    ActivityManagerService.dumpStackTraces(<span class="hljs-literal">true</span>, pids, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                            NATIVE_STACKS_OF_INTEREST);<br>                    waitedHalf = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//存在阻塞,时间超过60s,系统存在问题,用户体验糟糕,尽可能收集日志,重启收集</span><br>            <span class="hljs-comment">// something is overdue!</span><br>            blockedCheckers = getBlockedCheckersLocked();<br>            subject = describeCheckersLocked(blockedCheckers);<br>            allowRestart = mAllowRestart;<br>        &#125;<br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行所有的<code>Checker</code>的监控方法<code>scheduleCheckLocked()</code><ol><li>是否完成检测，完成则将mMonitorQueue队列中的monitor全部加入mMonitor中；</li><li>对于HandlerChecker来说,如果目标线程空闲,则不用进一步检测,则设置mCompleted &#x3D; true，返回；</li><li>当上次check还没有完成, 则直接返回；</li><li>Watchdog线程向各个线程发送消息，看消息能否按时完成。</li></ol></li><li>等待30s后, 再调用<code>evaluateCheckerCompletionLocked</code>来评估各<code>HandlerChecker</code>状态;</li><li>根据<code>waitState</code>状态来执行不同的操作:<ol><li>当COMPLETED或WAITING,则正常，继续检查;</li><li>当WAITED_HALF(超过30s)且为首次, 则输出system_server和3个Native进程的traces;</li><li>当OVERDUE, 则输出更多信息,并重启系统。</li></ol></li></ol><p>综合上之前的信息，我们目前可以得到下面这个框架图</p><p><img src="/blog_imgs/1_watchdog_1/Image_6.png" alt="acd22c37acbbe0d5dc72720bcc72ffe3.png"></p><h2 id="4-日志收集"><a href="#4-日志收集" class="headerlink" title="4. 日志收集"></a>4. 日志收集</h2><p>我们需要收集哪些日志呢？<br>因为我们无法得知和<code>HandlerChecker</code>卡住的具体原因，我们只能<code>dump</code>和<code>system_server</code>有交集的各个进程，特别涉及和<code>system_server</code>模块服务有相关交集的进程。<br>例如</p><ul><li>StorageManagerService–<strong>vold</strong>（volume daemon）进程</li><li>WindowManagerService–<strong>SurfaceFlinger</strong> 进程</li><li>等等以及<code>Hal</code>的服务进程<br>首先第一步<code>system_server</code>自身进程的各个线程堆栈信息要<code>dump</code>出来。<br>其次和system_server 交互的其他关系紧密的进程的堆栈也需要dump出来，这里直接给出的进程有：</li></ul><table><thead><tr><th>Name</th><th>说明</th></tr></thead><tbody><tr><td>system_server</td><td>自身进程</td></tr><tr><td>com.android.phone</td><td>由于phone进程作为一个应用层级的Binder服务，依托system_server将接口中转给其他进程使用，（遇到过phone进程system_server形成死锁的案例 ）</td></tr><tr><td>com.google.android.providers.media.module</td><td>同上，也有遇到过类似案例</td></tr><tr><td>media相关进程</td><td></td></tr><tr><td>surfaceflinger</td><td></td></tr><tr><td>netd</td><td></td></tr><tr><td>…30+</td><td>这里主要涉及在开发过程中遇到问题，不断添加完善的过程</td></tr></tbody></table><p>日志输出：</p><ul><li>当阻塞超过30s后进行一次日志输出：用户态进程堆栈，日志包含上面的用户态各个进程的各个现场现场的堆栈信息（目录   <code>data/anr/anr_日期.txt</code>）</li><li>当阻塞超过60s后进行最后一次日志输出<strong>用户态进程堆栈</strong>+<strong>kernel异常信息</strong>，这个时候系统是真的卡死了，很可能是由于<code>kernel</code> 卡死导致（内核线程死锁，阻塞，文件系统异常，内存异常，驱动模块异常等），所以我们要输出一下kernel中状态异常的进程信息<ul><li>使用 <strong>&#x2F;proc&#x2F;sysrq-trigger</strong> 节点</li><li><code>echo l &gt; /proc/sysrq-trigger</code>： 显示所有活动cpu的堆栈信息</li><li><code>echo w &gt; /proc/sysrq-trigger</code>： 将进入 <code>uninterrupted 状态</code>的任务信息 dump 出来</li><li><code>echo c &gt; /proc/sysrq-trigger</code>： 使系统崩溃，如果配置了<code>crashdump</code>，崩溃后会生成 <code>dump 文件</code><br>  (kernel-6.6&#x2F;Documentation&#x2F;admin-guide&#x2F;sysrq.rst )<br>关于dump出来的日志是一个比较复杂的内容，等后面在进一步解释。</li></ul></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文通过文字结合代码结合图片形式来讲述Watchdog机制的由来，讲的内容是粒度较大的，可能还存在部分错误，但是总统是个不断完善的过程。<br>文中比较重要的就是代码上对于两个问题的抽象是比较重要的，对于这两个概念的理解是后面分析SWT问题的基础，读者务必了解清楚。<br>文章的不足：代码部分往往很难使用语言来描述到极度详细，需要一定的代码阅读能力。<br>文章的用途：主要是用于记录自己学习watchdog机制的记录，一方面通过比较口语化的形式记录，方便后续查阅。<br>后期待办：完善问题分析例子</p>]]></content>
    
    
    <categories>
      
      <category>Sports</category>
      
      <category>Baseball</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>SWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
