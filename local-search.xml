<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android system_server-watchdog机制介绍（下）</title>
    <link href="/2025/09/02/2_watchdog_%E4%B8%8B/"/>
    <url>/2025/09/02/2_watchdog_%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]<br><strong>回顾</strong>：<br>从上篇文章中，我们主要从问题角度描述了我们<code>system_server</code>中<code>watchdog</code>的原理，粒度是很粗糙的。简单可以概括为下面三点：</p><ul><li><strong>关键服务</strong>对象锁不能被某线程异常长时间占用——<strong>问题1</strong></li><li><strong>系统关键线程</strong>不能长时间只执行一个单一逻辑，避免后面的消息阻塞——<strong>问题2</strong></li><li>当监测到上面异常时，我们根据异常时间长短来决策是否重启手机，并且根据异常时间我们针对性的输出日志，让程序员根据log解决异常。</li></ul><p>本篇文章，我们再进一步将上述三点内容，进一步细化以及列举一些常见的案例。</p><h2 id="1-关键线程异常"><a href="#1-关键线程异常" class="headerlink" title="1. 关键线程异常"></a>1. 关键线程异常</h2><p><code>system_server</code>中的众多模块功能，离不开<code>system_server</code>中各个线程的执行，<code>system_server</code>中线程组成如下：</p><p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_6_%E9%A1%B5.png" alt="dce0c8d48bb5f707c303f5c305476bad.png"></p><p>如上虚线框内的线程中我们主要关注<strong>关键线程</strong>（<strong>绿色部分线程</strong>），他们的职能如同名字一样，服务模块如果处理例如io，显示等职能事务，可以将事务专门交给这些关键线程。而不是将所有事务都交给模块线程来处理。这些关键线程就像我们生活中的公共交通工具火车、地铁、公交一样在system_server中扮演着重要的作用。</p><h3 id="1-1-关键线程具体有哪些"><a href="#1-1-关键线程具体有哪些" class="headerlink" title="1.1 关键线程具体有哪些?"></a>1.1 关键线程具体有哪些?</h3><p>我们通过系统源码查看可以查看，我们主要监测着下面表格中这些线程：</p><table><thead><tr><th>关键线程名</th><th>作用</th></tr></thead><tbody><tr><td>main</td><td>主线程（优先级：-2）</td></tr><tr><td>android.ui</td><td>处理系统进程UI相关的事务（优先级：-2）</td></tr><tr><td>android.io</td><td>文件读写相关的事务（优先级：0）</td></tr><tr><td>android.display</td><td>处理系统显示事务相关（优先级：-3）</td></tr><tr><td>android.anim</td><td>处理系统动画相关的事务（优先级：-4）</td></tr><tr><td>android.anim.lf</td><td>处理系统动画相关和Vsync相关（优先级：-4）</td></tr><tr><td>android.fg</td><td>前台公共线程（优先级：0）</td></tr><tr><td>android.bg</td><td>后台公共线程（优先级：10）</td></tr><tr><td>watchdog.monitor</td><td>用来check关键服务锁情况（优先级：0）</td></tr><tr><td>服务模块线程</td><td>服务模块逻辑线程</td></tr><tr><td>ActivityManager:starter</td><td>AMS进程创建相关线程</td></tr><tr><td>RollbackManagerServiceHandler</td><td>回滚相关线程</td></tr><tr><td>PermissionManager</td><td>权限管理线程</td></tr><tr><td>PowerManagerService</td><td>电量&#x2F;源管理服务线程</td></tr><tr><td>PackageManagerService</td><td>包管理服务线程</td></tr><tr><td>可根据问题自主添加</td><td></td></tr></tbody></table><h3 id="1-2-watchdog中添加线程监控方法："><a href="#1-2-watchdog中添加线程监控方法：" class="headerlink" title="1.2 watchdog中添加线程监控方法："></a>1.2 watchdog中添加线程监控方法：</h3><p>模块代码中使用<br><code>Watchdog.getInstance().addThread(..)</code></p><h2 id="2-关键服务异常"><a href="#2-关键服务异常" class="headerlink" title="2. 关键服务异常"></a>2. 关键服务异常</h2><p>具体的监测服务如下，100多个服务为什么选择这几个服务呢？这里我们不得而知，但是可想而知的是，随之系统的迭代以及项目的不断开发，系统中会遇到各种各样的问题，会根据问题的分类，增加新的监测模块。</p><ul><li>StorageManagerService</li><li>MediaProjectionManagerService</li><li>MediaRouterService</li><li>InputManagerService</li><li>PowerManagerService</li><li>WindowManagerService</li><li>ActivityManagerService</li><li>BatteryStatsService</li><li>BinderThreadMonitor(补充)<br>目前系统中监测的服务为上面的这些服务，当然如果我们往system_server中添加新的重要服务，我们也可以将该服务添加到监控中去。</li></ul><h3 id="2-1-监控关键服务的方法："><a href="#2-1-监控关键服务的方法：" class="headerlink" title="2.1 监控关键服务的方法："></a>2.1 监控关键服务的方法：</h3><p>我们添加重要的模块&#x2F;服务到<code>system_server</code>中，可以通过以下方法添加到<code>watchdog</code>监控中去。</p><ol><li>实现<code>Watchdog.Monitor</code>接口中的 <code>monitor()</code> 方法，方法中实现本模块认为异常的监测逻辑。</li><li>模块代码调用  <code>Watchdog.getInstance().addMonitor(this)</code>。</li></ol><h3 id="2-2-Binder线程监测补充"><a href="#2-2-Binder线程监测补充" class="headerlink" title="2.2 Binder线程监测补充"></a>2.2 Binder线程监测补充</h3><p>在<code>system_server</code>中<code>Binder线程</code>（下图橙色部分）作为应用进程和<code>system_server</code>交互的桥梁，并且<code>system_server</code>作为整个Android系统中Binder线程数量最多的进程，<strong>Binder线程资源多并且十分重要</strong>。</p><p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%82%E4%B9%B1.png" alt="052ad1ef0eee091636769b3f2f1e0166.png"></p><p><strong>问题</strong>：<u>会不会出现所有Binder线程都阻塞到某个逻辑，导致其他应用进程访问system_server却没有Binder线程处理事务？</u></p><blockquote><p>是会这样的，所有要对这种异常情况进行监控。我们就可以使用上面的 2.1 中方法添加到watchdog监控中去。</p></blockquote><p>我们可以根据2.1的步骤可以看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/Watchdog.java</span><br>   <span class="hljs-number">1.</span> 现Watchdog.Monitor接口中的 `monitor()` 方法，方法中实现本模块认为异常的监测逻辑<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderThreadMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watchdog</span>.Monitor &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span> &#123;<br>           Binder.blockUntilThreadAvailable();<br>       &#125;<br>   &#125;<br><span class="hljs-number">2.</span> 模块代码调用  `Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>)`<br>addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>())<br></code></pre></td></tr></table></figure><p> <code>monitor</code>方法具体实现：<br> 如果所有Binder线程都在阻塞（正常来说不可能所有Binder线程都长时间阻塞的），那么打印异常日志并且一直等待阻塞，阻塞将会被<code>watchdog</code>监测到，持续异常将触发重启。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> IPCThreadState::blockUntilThreadAvailable()<br>&#123;<br>    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);<br>    mProcess-&gt;mWaitingForThreads++;<br>    <span class="hljs-keyword">while</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads) &#123;<br>        ALOGW(<span class="hljs-string">&quot;Waiting for thread to be free. mExecutingThreadsCount=%lu mMaxThreads=%lu\n&quot;</span>,<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mExecutingThreadsCount),<br>                static_cast&lt;unsigned <span class="hljs-type">long</span>&gt;(mProcess-&gt;mMaxThreads));<br>        pthread_cond_wait(&amp;mProcess-&gt;mThreadCountDecrement, &amp;mProcess-&gt;mThreadCountLock);<br>    &#125;<br>    mProcess-&gt;mWaitingForThreads--;<br>    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="3-异常监测的衡量"><a href="#3-异常监测的衡量" class="headerlink" title="3. 异常监测的衡量"></a>3. 异常监测的衡量</h2><p>在对于问题1、2的详细阐述后我们可以得到下面这个图片：<br><img src="/blog_imgs/2_watchdog_2/binder_montor.png" alt="6422d9568c21b454540ae3349dfc1487.png"></p><p><code>watchdog线程</code>给各个关键线程发送一条消息，各个关键线程在规定时间内处理完该消息，那么<code>watchdog线程</code>认为系统正常。如果规定时间内无法处理完该消息，那么认为系统异常。</p><p><strong>问题</strong>： <u>那么这个规定时间是多少呢？</u></p><blockquote><p>答案是：30s，每隔30s发送一条消息，如果超过30s各个关键线程没有处理完消息，系统将会打印对应的日志。</p></blockquote><p><strong>问题</strong>：假如system_server异常后不能长时间卡住，用户无法忍受，如何处理？</p><blockquote><p>超过第二个30s（即一分钟），消息还未被处理完成，重启系统，让用户能恢复手机使用。</p></blockquote><p>当然有人会问为什么是30s？</p><blockquote><p>这里无从考证，个人猜测一方面可能是用户的体验不能卡住太久，另一方面是时间一分钟&#x3D;60s&#x3D;两个30s，便于编码。</p></blockquote><p>经过第三点的补充后我们得到了下面完整的框架图片：<br><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC_5_%E9%A1%B5.png" alt="a6625f96485e3a8391ecba9a419a7ec5.png"></p><p>图片解读:</p><ol><li><code>system_server</code>中watchdog线程每隔30s给各个<strong>关键线程</strong>发送一条消息，消息内容：设置一个<strong>标志位</strong>，代表处理完成。</li><li>Binder线程是否空余，以及各个关键服务的对象锁是否被异常持有，由<code>watchdog.monitor线程</code>进行检测，检测方式：逐一调用各个模块实现的<code>monitor方法</code>即可，<code>monitor接口</code>是否阻塞则决定各个模块是否异常。</li><li>如果&gt;<strong>30s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中。</li><li>如果&gt;<strong>60s</strong> 存在消息没有被处理完，<code>watchdog线程</code>要输出log，将异常点体现在日志中，并且<strong>重启system_server进程</strong>。</li></ol><h2 id="4-日志的输出"><a href="#4-日志的输出" class="headerlink" title="4. 日志的输出"></a>4. 日志的输出</h2><p>在超时30s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条log：<br><code>07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG</code><br>在在超时60s消息没有被处理完，在 <code>events log</code> 我们能看到下面这条相似的log：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure><p>光凭借这点log我们程序员可无法准确的定位出问题，我们的目的只有一个:输出log要能让程序员定位到问题。</p><h3 id="4-1-问题：-我们还需要输出哪些log？"><a href="#4-1-问题：-我们还需要输出哪些log？" class="headerlink" title="4.1 问题： 我们还需要输出哪些log？"></a>4.1 问题： 我们还需要输出哪些log？</h3><p><img src="/blog_imgs/2_watchdog_2/%E7%BA%BF%E7%A8%8B%E6%9D%82%E4%B9%B1.png" alt="d098fbc833faeda9532b15223a5b1e37.png"></p><h4 id="4-1-1-system-server-自身堆栈信息"><a href="#4-1-1-system-server-自身堆栈信息" class="headerlink" title="4.1.1 system_server 自身堆栈信息"></a>4.1.1 system_server 自身堆栈信息</h4><p><strong>system_server</strong> 中存在的问题很可能就是上图的情况，可能还比上图更为杂乱，各个线程间相互等待，相互等锁等等，我们最直观能看到问题点就是将<code>system_server</code>中各个的线程的堆栈dump出来，通过堆栈找出问题点。</p><ul><li><strong>输出日志</strong>：dump出 <strong>system_server中各个线程的堆栈信息</strong></li></ul><h4 id="4-1-2-system-server-关联进程堆栈信息"><a href="#4-1-2-system-server-关联进程堆栈信息" class="headerlink" title="4.1.2 system_server 关联进程堆栈信息"></a>4.1.2 system_server 关联进程堆栈信息</h4><p><img src="/blog_imgs/2_watchdog_2/%E9%87%8D%E8%A6%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E.png" alt="2cf19497de20cf3bb9abca5d6f585923.png"></p><p>对于<code>system_server</code>进程而言，除了自身进程之外，<code>system_server</code>进程还会和其他进程交互，这里尤其指的是服务模块进程，万一我们<code>system_server</code>中的线程阻塞在这些其他进程上怎么办？</p><blockquote><p>所以我们需要dump出和<code>system_server</code>交互频繁的这些服务进程的线程堆栈。native 层服务进程，以及hal层服务进程，以及Java层的匿名Binder服务进程等等：</p></blockquote><ul><li><p>例如：<strong>native&#x2F;hal层服务进程</strong> : <code>SF</code>、<code>Netd</code>、<code>audio模块</code>、<code>sensor模块</code>等。</p></li><li><p>例如：<strong>Java层匿名Binder服务进程</strong>: <code>com.android.phone</code>、<code>com.google.android.providers.media.module</code>等。</p></li><li><p><strong>输出日志</strong>： dump出<strong>和system_server交互频繁的服务进程的线程堆栈</strong></p></li></ul><p>我们能从watchdog代码中看到下面的这些需要dump的进程的信息：<br><img src="/blog_imgs/2_watchdog_2/dump_%E8%BF%9B%E7%A8%8B.jpg" alt="3f81357d1ea62e19f0c7346a7826a61c.jpeg"><br>这里的信息也是随着项目产品不断迭代，出现问题后，不断往上添加的一个过程。例如你在项目中遇到问题指向某个服务进程并且排查问题时候这个服务进程没有被dump出来，你就可以在上面代码中添加。</p><h4 id="4-1-3-kernel异常进程信息"><a href="#4-1-3-kernel异常进程信息" class="headerlink" title="4.1.3 kernel异常进程信息"></a>4.1.3 kernel异常进程信息</h4><p>上面我们主要dump的都是用户态的堆栈信息，但是我们还需要想一个点——问题：<strong>内核模块会不会异常</strong>？<br>会的，我们还是从上上个图中来看，底层的一些重要的服务是依赖于kernel中的一些驱动模块的，除了我们常知道内存、cpu、gpu等还有tp&#x2F;屏显&#x2F;sensor等等一些内核模块，也是会出现异常的进而间接会影响到system_server中的模块。所以我们需要dump出内核模块中异常的堆栈信息。</p><p><strong>但是怎么判断内核异常模块进程呢</strong>？</p><ul><li><code>TASK_UNINTERRUPTIBLE</code>：不可中断休眠，长时间的不可中断休眠状态的线程则很容易出现阻塞问题，进而引发SWT问题</li><li>进程状态：<strong>D状态</strong></li></ul><p><strong>不可中断休眠状态进程的特点</strong>：</p><ul><li>不接受中断（软&#x2F;硬）signal信号等，只等待想等待的事情完成。</li><li>常见场景：有 Swap 读数据、信号量机制、mutex 锁、内存慢路径回收等场景。<br>(参考：<a href="https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE">https://elixir.bootlin.com/linux/v6.16/C/ident/TASK_UNINTERRUPTIBLE</a>)</li></ul><p><strong>dump方式</strong>：<code>echo w &gt; /proc/sysrq-trigger</code><br>类似：<br><img src="/blog_imgs/2_watchdog_2/kernel_D_log.jpg" alt="a1d88ec87f02b6fef4adbc78c8c06aee.jpeg"></p><h4 id="4-1-4-小结"><a href="#4-1-4-小结" class="headerlink" title="4.1.4 小结"></a>4.1.4 小结</h4><p>上述就是我们需要dump出来的log信息，但是还缺一样log，在Android系统中服务进程间通信方式使用的的是Binder通信，所以我们要知道A进程中的A1线程和B进程中B1线程是否存在通信的关系，我们需要dump Binder通信的log信息。<br>位置：<code>/dev/binderfs/binder_logs/transactions</code>或者<code>/sys/kernel/debug/binder</code>目录下。<br>所需的日志如下：</p><ul><li><strong>system_server自身线程堆栈信息</strong></li><li><strong>与system_server关联其他服务端进程信息</strong></li><li><strong>kernel异常状态进程堆栈信息</strong></li><li><strong>Binder进程间交互信息</strong></li></ul><p>如下图：<br><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC10_%E9%A1%B5.png" alt="a8b702225974fac1cf9d81af66fe25cf.png"></p><h3 id="4-2-日志解读"><a href="#4-2-日志解读" class="headerlink" title="4.2 日志解读"></a>4.2 日志解读</h3><p>我们在分析SWT 问题时候，通常来说是按照下面的log进行分析的：</p><ul><li><strong>红色部分日志</strong>：先从events system 这些log中确定system_server中遭遇了哪类问题？是<strong>问题一</strong>还是<strong>问题二</strong>。</li><li><strong>蓝色部分日志</strong>：进而从dump的堆栈信息（不管是kernel还是用户态其他进程）分析异常模块。</li><li><strong>绿色日志</strong>：Binder交互信息作为辅助，借助交互信息可以得知各个阻塞模块的联系。</li></ul><p><img src="/blog_imgs/2_watchdog_2/watchdog_1-%E7%AC%AC11_%E9%A1%B5.png" alt="e955d2a63ccbd59a8f085e159a603a35.png"></p><h3 id="4-2-1-events-system-日志解读"><a href="#4-2-1-events-system-日志解读" class="headerlink" title="4.2.1 events system 日志解读"></a>4.2.1 events system 日志解读</h3><p><code>events log</code>中下面两条log分别是在异常大于30s，大于60s两个时间节点输出</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">07-26 09:31:29.795  1453  1578 I Watchdog: WAITED_UNTIL_PRE_WATCHDOG<br>07-26 09:32:15.586  1453  1578 E Watchdog: **SWT happen **Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br></code></pre></td></tr></table></figure><p><strong>第二条log</strong>会直接指出出现的异常是那种类型，也就是我们之前分析的问题一或者问题二，当前的log表明，<code>watchdog.monitor</code> 线程想要去获取<code>ActivityManagerService</code>的对象锁，很遗憾超过60s都没有获取到，说明问题点是：AMS这个模块中的对象锁被某个线程异常长时间持有，有可能是线程逻辑阻塞，也有可能是线程死锁。</p><p>上述的第二条log信息是比较重要的，直接为为我们指明了排查方向，第二条log还有其他好几种形式，但是log的模板基本上只有两种，因为我们要检测的问题基本上就两个：</p><ul><li><code>Blocked in handler on</code> 关键线程名 <code>thread</code> (关键线程)——<strong>问题2</strong></li><li><code>Blocked in monitor</code> 关键服务对象 <code>on monitor thread (watchdog.monitor)</code>——<strong>问题1</strong></li></ul><table><thead><tr><th>关键线程名</th><th>关键服务对象</th></tr></thead><tbody><tr><td>线程名</td><td>关键服务对象</td></tr><tr><td>main</td><td>StorageManagerService</td></tr><tr><td>android.ui</td><td>MediaRouterService</td></tr><tr><td>android.io</td><td>InputManagerService</td></tr><tr><td>android.display</td><td>WindowManagerService</td></tr><tr><td>android.anim</td><td>ActivityManagerService</td></tr><tr><td>android.anim.lf</td><td>BatteryStatsService</td></tr><tr><td>android.fg</td><td>BinderThreadMonitor</td></tr><tr><td>android.bg</td><td>…</td></tr><tr><td>watchdog.monitor</td><td></td></tr><tr><td>ActivityManager:starter，RollbackManagerServiceHandler，PermissionManager，PowerManagerService，PackageManagerService</td><td></td></tr></tbody></table><p>打印的log只是上面表格中列出来的一种或者多种组合。<br>例如：下面的日志中所有问题都囊括了</p><ul><li>关键服务AMS服务的对象锁被异常持有。</li><li>关键线程 <code>android.fg</code>、<code>main</code>、<code>android.io</code>、<code>android.display</code>、<code>android.anim</code>阻塞</li><li>没有空闲Binder线程。</li></ul><p><img src="/blog_imgs/2_watchdog_2/log_red.PNG" alt="d1c8f2a81b6c7825f864369bc3ec638d.png"></p><p>排查的时候我们使用一条线索往下排查就行，往往是各个问题相互杂糅相互影响的（目前没有遇到过几个问题点是分开的这种问题）。</p><p>在system log 中会打印下面这样的log：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked in<span class="hljs-built_in"> monitor </span>com.android.server.am.ActivityManagerService on<span class="hljs-built_in"> monitor </span>thread (watchdog.monitor) for 60s<br>W Watchdog: watchdog.monitor annotated stack trace:<br>W Watchdog:     at com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>W Watchdog:     - waiting to lock &lt;0x0bcefae9&gt; (a com.android.server.am.ActivityManagerService)<br>W Watchdog:     at com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<br>W Watchdog:     at android.os.Handler.handleCallback(Handler.java:959)<br>W Watchdog:     at android.os.Handler.dispatchMessage(Handler.java:100)<br>W Watchdog:     at android.os.Looper.loopOnce(Looper.java:232)<br>W Watchdog:     at android.os.Looper.loop(Looper.java:317)<br>W Watchdog:     at android.os.HandlerThread.run(HandlerThread.java:85)<br>W Watchdog:     at com.android.server.ServiceThread.run(ServiceThread.java:46)<br>W Watchdog: *** GOODBYE!<br></code></pre></td></tr></table></figure><p>log会打印出阻塞的关键线程的堆栈信息（有时候受负载影响可能不准，但是可以作为参考），如上能看到AMS对象锁的地址，会打印出<strong>GOODBYE</strong>关键字。<br>除此之外在system log中还会打印出现SWT先后dump两次trace文件的名称，给我们指明下一步排查的文件的位置（这里比较关键，有的伙伴分析问题直接就随便点开一个anr_xx就开始排查，可能看的trace文件都不对，这会影响问题的分析结果）。<br><code>ActivityManager: Dumping to /data/anr/anr_2025-07-26-09-32-16-000</code> （可以在system log中检索<code>Dumping to</code> 这个关键字，anr问题的分析也是如此）。</p><h3 id="4-2-2-trace-文件概要解读"><a href="#4-2-2-trace-文件概要解读" class="headerlink" title="4.2.2 trace 文件概要解读"></a>4.2.2 trace 文件概要解读</h3><p><code>SWT</code>以及<code>ANR</code>问题都会将进程的线程堆栈信息dump出来，文件保存到<code>data/anr</code>目录下面。区别在于SWT问题trace文件dump的进程较多，ANR问题dump的trace文件进程较少（通常只是ANR进程本身以及system_server进程）。<br>通常来说<strong>trace文件</strong>主要包括以下几部分内容：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Subject: Blocked in monitor com.android.server.am.ActivityManagerService on monitor thread (watchdog.monitor) <span class="hljs-keyword">for</span> <span class="hljs-number">15</span>s<br>--- CriticalEventLog ---<br>capacity: <span class="hljs-number">20</span><br>timestamp_ms: <span class="hljs-number">1753493489805</span><br>window_ms: <span class="hljs-number">300000</span><br><br>----- dumping <span class="hljs-keyword">pid</span>: <span class="hljs-number">1453</span> at <span class="hljs-number">156092124</span><br><span class="hljs-keyword">proc</span> 1453<span class="hljs-title"></span><br><span class="hljs-title">context</span> binder<span class="hljs-title"></span><br><span class="hljs-title">  thread</span> 2538:<span class="hljs-title"> l</span> 01<span class="hljs-title"> need_return</span> 0<span class="hljs-title"> tr</span> 0<span class="hljs-title"></span><br><span class="hljs-title">    incoming</span> transaction 8113988: 0000000000000000<span class="hljs-title"> from</span> 16729:16729<span class="hljs-title"> to</span> 1453:2538<span class="hljs-title"> code</span> 5f434d44<span class="hljs-title"> flags</span> 10<span class="hljs-title"> pri</span> 0:120<span class="hljs-title"> r1</span> elapsed 29819ms<span class="hljs-title"> node</span> 5247<span class="hljs-title"> size</span> 148:40<span class="hljs-title"> offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">  buffer</span> 8113988: 0<span class="hljs-title"> size</span> 148:40:0<span class="hljs-title"> active</span><br><br>-----<span class="hljs-title"> pid</span> 1453<span class="hljs-title"> at</span> 2025-07-26 09:31:33.233489611+0800 -----<span class="hljs-title"></span><br><span class="hljs-title">Cmd</span> line:<span class="hljs-title"> system_server</span><br>Build<span class="hljs-title"> fingerprint:</span> xxxx<span class="hljs-title"></span><br><span class="hljs-title">ABI:</span> &#x27;arm64&#x27;<span class="hljs-title"></span><br><span class="hljs-title">Build</span> type:<span class="hljs-title"> optimized</span><br>Debug<span class="hljs-title"> Store:</span> 1,0,156092154::<span class="hljs-title"></span><br><span class="hljs-title">suspend</span> all<span class="hljs-title"> histogram:</span>Sum: 64.207ms 99%<span class="hljs-title"> C.I.</span> 3us-7449.600us<span class="hljs-title"> Avg:</span> 369.005us<span class="hljs-title"> Max:</span> 22931us<span class="hljs-title"></span><br><span class="hljs-title">DALVIK</span> THREADS (226):<br>&quot;watchdog.monitor&quot;<span class="hljs-title"> prio=5</span> tid=12<span class="hljs-title"> Blocked</span><br>  |<span class="hljs-title"> group=&quot;main&quot;</span> sCount=1<span class="hljs-title"> ucsCount=0</span> flags=1<span class="hljs-title"> obj=0x2016da8</span> self=0x8b0000598a4b8000<br>  |<span class="hljs-title"> sysTid=1570</span> nice=-2<span class="hljs-title"> cgrp=foreground</span> sched=0/0<span class="hljs-title"> handle=0x7001af0730</span><br>  |<span class="hljs-title"> state=S</span> schedstat=( 14628587427 2412564438 42408 )<span class="hljs-title"> utm=581</span> stm=880<span class="hljs-title"> core=0</span> HZ=100<br>  |<span class="hljs-title"> stack=0x70019ed000-0x70019ef000</span> stackSize=1037KB<br>  |<span class="hljs-title"> held</span> mutexes=<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.am.ActivityManagerService.monitor(ActivityManagerService.java:18216)<br>  -<span class="hljs-title"> waiting</span> to<span class="hljs-title"> lock</span> &lt;0x0bcefae9&gt; (a<span class="hljs-title"> com.android.server.am.ActivityManagerService)</span> held<span class="hljs-title"> by</span> thread 57<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.Watchdog$HandlerChecker.run(Watchdog.java:398)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.handleCallback(Handler.java:959)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Handler.dispatchMessage(Handler.java:100)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loopOnce(Looper.java:232)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.Looper.loop(Looper.java:317)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> android.os.HandlerThread.run(HandlerThread.java:85)<span class="hljs-title"></span><br><span class="hljs-title">  at</span> com.android.server.ServiceThread.run(ServiceThread.java:46)<span class="hljs-title"></span><br><span class="hljs-title">DumpLatencyMs:</span> 102.166<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>anr_XXX.txt 包含log</th><th>含义、作用</th></tr></thead><tbody><tr><td>Subject:XXX</td><td>当前的这个anr_xx.txt是什么原因被dump出来</td></tr><tr><td>CriticalEventLog</td><td>记录在此之前发生过的关键性异常事件（anr等）</td></tr><tr><td>dumping pid XX（关键）</td><td>binder交互信息（&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;transactions）</td></tr><tr><td>Cmd line: 进程名（关键）</td><td>对应进程的各个线程的堆栈信息</td></tr><tr><td>Waiting Channels: pid XX</td><td>XX进程各线程的内核函数接口</td></tr><tr><td>等等</td><td></td></tr></tbody></table><p>分析问题时我们主要关注Binder 交互信息以及各进程的各线程的堆栈信息。</p><h3 id="4-2-3-trace-文件解读-线程堆栈信息"><a href="#4-2-3-trace-文件解读-线程堆栈信息" class="headerlink" title="4.2.3 trace 文件解读-线程堆栈信息"></a>4.2.3 trace 文件解读-线程堆栈信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;ReferenceQueueDaemon&quot;</span> daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">tid</span>=6 Waiting<br>  | <span class="hljs-attribute">group</span>=<span class="hljs-string">&quot;system&quot;</span> <span class="hljs-attribute">sCount</span>=1 <span class="hljs-attribute">ucsCount</span>=0 <span class="hljs-attribute">flags</span>=1 <span class="hljs-attribute">obj</span>=0x20030b8 <span class="hljs-attribute">self</span>=0x730000598a472000<br>  | <span class="hljs-attribute">sysTid</span>=1557 <span class="hljs-attribute">nice</span>=4 <span class="hljs-attribute">cgrp</span>=foreground <span class="hljs-attribute">sched</span>=0/0 <span class="hljs-attribute">handle</span>=0x70496d0730<br>  | <span class="hljs-attribute">state</span>=S schedstat=( 1359509621 111263835 448 ) <span class="hljs-attribute">utm</span>=110 <span class="hljs-attribute">stm</span>=25 <span class="hljs-attribute">core</span>=6 <span class="hljs-attribute">HZ</span>=100<br>  | <span class="hljs-attribute">stack</span>=0x70495cd000-0x70495cf000 <span class="hljs-attribute">stackSize</span>=1037KB<br>  | held mutexes=<br>  at java.lang.Object.wait(Native method)<br>  - waiting on &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Object.wait(Object.java:405)<br>  at java.lang.Object.wait(Object.java:543)<br>  at java.lang.Daemons<span class="hljs-variable">$ReferenceQueueDaemon</span>.runInternal(Daemons.java:260)<br>  - locked &lt;0x0e053311&gt; (a java.lang.Class&lt;java.lang.ref.ReferenceQueue&gt;)<br>  at java.lang.Daemons<span class="hljs-variable">$Daemon</span>.<span class="hljs-built_in">run</span>(Daemons.java:132)<br>  at java.lang.Thread.<span class="hljs-built_in">run</span>(Thread.java:1119)<br>DumpLatencyMs: 90.8357<br></code></pre></td></tr></table></figure><ul><li>第1行：<ul><li><strong>线程名</strong>：ReferenceQueueDaemon</li><li><strong>daemon</strong>：有此则代表守护线程（生命周期和进程的生命周期一样长）</li><li><strong>prio</strong>：（Priority）线程优先级</li><li><strong>tid</strong>：线程在进程内的序号（主线程tid&#x3D;1，其他线程依次递增）</li><li><strong>Waiting</strong>：线程状态（Java层面）常见还有Native、TimedWaiting、Sleeping、Blocked、Runnable。</li></ul></li><li>第2行：<ul><li><strong>group</strong>：线程所属的线程组，Java代码遗漏下来的，没有什么实际作用。</li><li><strong>sCount</strong>：Suspend Count 线程挂起次数（这里是art runtime 垃圾回收中的概念：GC时，要将线程挂起，执行GC操作）。</li><li><strong>ucsCount</strong>：用户主动使用代码导致线程挂起的次数（区别于sCount，这里主动调用代码挂起，前者是ART机制）。</li><li><strong>obj</strong>：保存着当前线程关联Java线程的对象地址（在虚拟机中从线程是以native的形式c++层thread存在，native线程要想访问java对象必须先保存Java线程对象的地址）。</li><li><strong>self</strong>：当前线程的地址</li></ul></li><li>第3行：<ul><li><strong>sysTid</strong>：线程号</li><li><strong>nice</strong>：调度优先级</li><li><strong>cgrp&#x3D;foreground</strong>：cgroup中进程所属调度组(常见有：foreground、top-app等)</li><li><strong>sched&#x3D;0&#x2F;0</strong>：调度策略（0 ：SCHED_NORMAL（也叫 SCHED_OTHER，普通时间共享，最常见）1 ：SCHED_FIFO（实时，先入先出）2 ：SCHED_RR（实时，轮询）3 ：SCHED_BATCH（批量）5 ：SCHED_IDLE（空闲线程）6 ：SCHED_DEADLINE（实时 deadline））。</li><li><strong>handle</strong>：native线程句柄</li></ul></li><li>第4行：<ul><li><strong>state&#x3D;S</strong> ：线程内核级别的调度状态（区别于运行时的线程状态，常见：Z：僵尸、D：不可中断休眠、S：可中断休眠、R：运行、T：停止）。</li><li><strong>schedstat</strong>&#x3D;( 1359509621 111263835 448 )：CPU调度时间统计（Running运行时间、Runable等待调度时间、SwitchCPU调度切换次数）， 见<code>proc/[pid]/task/[tid]/schedstat</code>.。在分析两份trace文件堆栈前后是否一致，是否卡死到同一位置，我们可以拿这几个值作为参考。</li><li><strong>utm</strong>&#x3D;110 ：线程在用户态所执行的时间</li><li><strong>stm</strong>&#x3D;25 ：线程在内核态所执行的时间</li><li><strong>core</strong>&#x3D;6 ：线程最后运行所在CPU的核</li><li><strong>HZ</strong>&#x3D;100：时钟频率</li></ul></li><li>第5行：<ul><li><strong>stack</strong>&#x3D;0x70495cd000-0x70495cf000：线程栈的地址空间</li><li><strong>stackSize</strong>&#x3D;1037KB：栈大小</li></ul></li><li>第6行：<strong>held mutexes</strong>：线程持有的mutexes</li><li>第7行：往下就是线程的调用堆栈：</li></ul><p>从问题排查的角度我们第一眼主要看到的是线程的状态（运行时）</p><ul><li><strong>Native</strong>：运行native层代码</li><li><strong>Waiting</strong>：线程等待</li><li><strong>TimedWaiting</strong>：线程定时等待</li><li><strong>Sleeping</strong>：线程主动Sleep</li><li><strong>Blocked</strong>：等待锁资源释放</li><li>…</li></ul><p>根据状态再看线程的调用栈，来确认是否是该线程中执行的代码逻辑有问题。</p><p>线程的调用堆栈反应线程此时在执行什么代码，那么在一个良好运作的系统中，线程的调用堆栈是什么样的呢？<br>在Android系统中和线程图中描述的一样并没有那么复杂,有一些基础功能的线程,有Binder线程,有普通的线程池线程。总体来说，除了一些基础功能的守护线程之外，其他<strong>线程模型</strong>主要有两种：</p><ul><li>通过<code>epoll</code>机制监测fd封装的线程模型。</li><li>Binder线程循环通过系统调用ioctl不断从Binder驱动读取消息线程模型。</li><li>其他</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//epoll 机制线程模型--正常等待新消息的到来</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5ff8  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+<span class="hljs-number">8</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 00018c2c  /system/lib64/libutils.so (android::Looper::pollInner+<span class="hljs-number">188</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 00018b0c  /system/lib64/libutils.so (android::Looper::pollOnce+<span class="hljs-number">124</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 0018b67c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce+<span class="hljs-number">44</span>) <br>  at android.os.MessageQueue.nativePollOnce(Native method)<br>  at android.os.MessageQueue.next(MessageQueue.java:<span class="hljs-number">335</span>)<br>  at android.os.Looper.loopOnce(Looper.java:<span class="hljs-number">194</span>)<br>  at android.os.Looper.loop(Looper.java:<span class="hljs-number">338</span>)<br>  at android.os.HandlerThread.run(HandlerThread.java:<span class="hljs-number">67</span>)<br> <span class="hljs-comment">//Binder 线程模型--正常读取Binder驱动消息</span><br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">00</span> pc 000b5038  /apex/com.android.runtime/lib64/bionic/libc.so (__ioctl+<span class="hljs-number">8</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">01</span> pc 000670ac  /apex/com.android.runtime/lib64/bionic/libc.so (ioctl+<span class="hljs-number">156</span>)<br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">02</span> pc 0005f4e4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver+<span class="hljs-number">292</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">03</span> pc 000600c8  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">04</span> pc 00060cfc  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool+<span class="hljs-number">732</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">05</span> pc 0006ae08  /system/lib64/libbinder.so (android::PoolThread::threadLoop+<span class="hljs-number">24</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">06</span> pc 000144dc  /system/lib64/libutils.so (android::Thread::_threadLoop+<span class="hljs-number">284</span>) <br>  <span class="hljs-keyword">native</span>: #<span class="hljs-number">07</span> pc 000ec29c  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell+<span class="hljs-number">140</span>)<br>  <span class="hljs-keyword">native</span>: #08 pc 000c9fd0  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start+<span class="hljs-number">208</span>)<br>  <span class="hljs-keyword">native</span>: #09 pc 0005dd90  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+<span class="hljs-number">64</span>) <br>  <br></code></pre></td></tr></table></figure><p>我们看到上面两种线程模型的堆栈信息，就是正常的运行形态。对于Binder线程来说，如果线程在等对端返回，通常在talkWithDriver往前的堆栈会调用到涉及对端的一些代码。<br>例如：<br><img src="/blog_imgs/2_watchdog_2/wait_binder_target.jpg" alt="20c9a7104ccafe356245a1b4c2680e8d.jpeg"></p><h3 id="4-2-4-Binder日志解读"><a href="#4-2-4-Binder日志解读" class="headerlink" title="4.2.4 Binder日志解读"></a>4.2.4 Binder日志解读</h3><p><strong>1.binder transaction信息</strong><br>在我们查看Binder交互log中，我们经常看到的就是<code>incoming transaction</code>和<code>outgoing transaction</code>，他们的含义是什么呢？<br>这其实内Binder驱动中Binder交互事务的描述。</p><ul><li><strong>outgoing transaction</strong>–客户端保存，客户端向服务端发起的binder事务请求。</li><li><strong>incoming transaction</strong>–服务端保存，服务端返回给客户端的binder事情请求。</li></ul><p>他们均指向一个binder_transaction，他们均能保存到线程指向的信息。<br>如下例子:<br>无论是<code>outgoing transaction</code>还是<code>incoming transaction</code>，他们都是指向<strong>7640493</strong>这个是kernel中<code>binder_transaction</code>的标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端进程</span><br>proc <span class="hljs-number">27226</span><br>context binder<br>  thread <span class="hljs-number">27226</span>: l <span class="hljs-number">10</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    outgoing transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms<br><br><span class="hljs-comment">//服务端进程</span><br>proc <span class="hljs-number">1467</span><br>context binder<br>  thread <span class="hljs-number">3206</span>: l <span class="hljs-number">01</span> need_return <span class="hljs-number">0</span> tr <span class="hljs-number">0</span><br>    incoming transaction <span class="hljs-number">7640493</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> to <span class="hljs-number">1467</span>:<span class="hljs-number">3206</span> code 5f434d44 flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1 elapsed 126772ms <br></code></pre></td></tr></table></figure><ul><li><code>from 27226:27226 to 1467:3206</code> –<strong>from</strong>:进程27226中线程27226作为客户端访问， <strong>to</strong>:服务端进程1467线程3206线程。</li><li><strong>elapsed</strong>: 访问阻塞时间。</li><li>还有很多其他信息，后面我们剖析Binder驱动再做说明。</li></ul><p><strong>2.kernel中的binder: release</strong></p><p>从上面信息我们知道<code>binder_transaction</code>中保存着线程指向信息，那么拿到这个信息就可以知道线程指向。我们可以在kernel log中看到这样的打印，也能找到对端信息。<br>当客户端进程<code>27226</code>被kill后，binder驱动会将对应的<code>binder_transaction</code>释放掉，所以检索<code>transaction</code>的id(7640493)就能找到binder对端线程为: <code>1467_16</code>即:<code>sysTid=3206</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">147603.943970</span>] [T1726663] kworker/<span class="hljs-number">7</span>:<span class="hljs-number">2</span>: binder: release <span class="hljs-number">27226</span>:<span class="hljs-number">27226</span> transaction <span class="hljs-number">7640493</span> out, still active<br>[<span class="hljs-number">147603.949150</span>] [T1003206] binder:<span class="hljs-number">1467_16</span>: binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">7640493</span>, target dead<br><br><span class="hljs-string">&quot;binder:1467_16&quot;</span> prio=<span class="hljs-number">5</span> tid=<span class="hljs-number">223</span> Native<br>  | group=<span class="hljs-string">&quot;main&quot;</span> sCount=<span class="hljs-number">1</span> ucsCount=<span class="hljs-number">0</span> flags=<span class="hljs-number">1</span> obj=<span class="hljs-number">0x3217730</span> self=<span class="hljs-number">0xb1000050bcbc4000</span><br>  | sysTid=<span class="hljs-number">3206</span> nice=<span class="hljs-number">0</span> cgrp=foreground sched=<span class="hljs-number">0</span>/<span class="hljs-number">0</span> handle=<span class="hljs-number">0x729ebd3730</span><br>  | state=S schedstat=( <span class="hljs-number">3960678864</span> <span class="hljs-number">3521264239</span> <span class="hljs-number">5438</span> ) utm=<span class="hljs-number">298</span> stm=<span class="hljs-number">97</span> core=<span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span><br>  | stack=<span class="hljs-number">0x729eadc000</span>-<span class="hljs-number">0x729eade000</span> stackSize=989KB<br>  | held mutexes=<br>....<br></code></pre></td></tr></table></figure><p>以上就是输出log的一些解析。</p><h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5. 案例"></a>5. 案例</h2><p>以下是一些分析解决过的问题案例log。</p><h3 id="5-1-system-server线程死锁"><a href="#5-1-system-server线程死锁" class="headerlink" title="5.1 system_server线程死锁"></a>5.1 system_server线程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%AD%BB%E9%94%81.png" alt="f37b16c23b8661fdc4c3a57ee02744bf.png"><br>该例子中两次trace持锁情况如下，排查代码为客制化代码错误移到<code>synchronized (mGlobalLock) {...}</code>中导致。</p><table><thead><tr><th>lock</th><th>tid&#x3D;203</th><th>tid&#x3D;296</th></tr></thead><tbody><tr><td>0x0ee759b0</td><td>waiting lock &lt;0x0ee759b0&gt;</td><td>locked &lt;0x0ee759b0&gt;</td></tr><tr><td>0x058d9a40</td><td>locked &lt;0x058d9a40&gt;</td><td>waiting lock &lt;0x058d9a40&gt;</td></tr><tr><td>上面表格锁的情况刚好形成一个死循环称为死锁。</td><td></td><td></td></tr></tbody></table><h3 id="5-2-system-server和phone进程死锁"><a href="#5-2-system-server和phone进程死锁" class="headerlink" title="5.2 system_server和phone进程死锁"></a>5.2 system_server和phone进程死锁</h3><p><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_2.png" alt="bbea9be66130474cc77063873c1410ca.png"><br><img src="/blog_imgs/2_watchdog_2/system_server_to_phone_1.png" alt="6fa59e552028af4c7b70f459d662440d.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//binder log</span><br>outgoing transaction <span class="hljs-number">25633452</span>: <span class="hljs-number">0000000000000000</span> from <span class="hljs-number">2937</span>:<span class="hljs-number">2937</span> to <span class="hljs-number">1937</span>:<span class="hljs-number">5077</span> code 3a flags <span class="hljs-number">10</span> pri <span class="hljs-number">0</span>:<span class="hljs-number">120</span> r1<br><br>binder: release <span class="hljs-number">1937</span>:<span class="hljs-number">3234</span> transaction <span class="hljs-number">25632946</span> out, still active <br>binder: release <span class="hljs-number">2937</span>:<span class="hljs-number">3605</span> transaction <span class="hljs-number">25632946</span> in, still active <br>binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">25632946</span>, target dead<br></code></pre></td></tr></table></figure><p>该例中两份trace文件均如此。</p><table><thead><tr><th>进程</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>system_server</td><td>binder:1937_16线程(sysTid&#x3D;5077)</td><td>等待→</td><td>binder:1937_E线程(tid&#x3D;290)sysTid&#x3D;3234</td></tr><tr><td></td><td>↑等待</td><td></td><td>↓等待</td></tr><tr><td>phone进程</td><td>main线程(sysTid&#x3D;2937)</td><td>←等待</td><td>binder:2937_A线程(tid&#x3D;70)sysTid&#x3D;3605</td></tr></tbody></table><h3 id="5-3-audio进程和system-server进程间死锁"><a href="#5-3-audio进程和system-server进程间死锁" class="headerlink" title="5.3 audio进程和system_server进程间死锁"></a>5.3 audio进程和system_server进程间死锁</h3><p>audio进程和system_server进程死锁导致Binder线程阻塞在其中出现Binder线程耗尽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">----------------------时间:<span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45</span> system_server进程 binder线程不够用 ---最早出现的时间<br><span class="hljs-number">10</span>-<span class="hljs-number">17</span> <span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45.931</span> <span class="hljs-number">1619</span> <span class="hljs-number">1805</span> W IPCThreadState: Waiting <span class="hljs-keyword">for</span> thread to be free. mExecutingThreadsCount=<span class="hljs-number">32</span> mMaxThreads=<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure><p>排查发现trace中所有Binder线程均在等待WMS服务的锁:<code>WindowManagerGlobalLock</code>((蓝色部分)，对应4633线程持有该锁在访问Audio模块的 <code>isStreamActive</code> 方法。<br><img src="/blog_imgs/2_watchdog_2/audio00.png" alt="a4ab3a355233116247152306a33e326a.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[ <span class="hljs-number">95.581437</span>] [T600160] binder: release <span class="hljs-number">855</span>:<span class="hljs-number">984</span> transaction <span class="hljs-number">93929</span> in, still active [ <span class="hljs-number">95.581471</span>] [T600160] binder: send failed reply <span class="hljs-keyword">for</span> transaction <span class="hljs-number">93929</span> to <span class="hljs-number">1619</span>:<span class="hljs-number">4633</span><br></code></pre></td></tr></table></figure><p>进一步排查发现,audio发生了NE(在audio中有binder超时监测机制，当超时到达超时直接会直接NE，进程重启)。<br>在main log的audio打印中日志中发现audio进程中的984线程执行 <code>isStreamActive</code> 似乎在等锁 <code>Mutex::Autolock _l(mLock)</code>。<br><img src="/blog_imgs/2_watchdog_2/audio0.png" alt="087a02a8d769c50e35c1d3b6db5abd1f.png"><br>进一步我们发现main log中audio模块还有相关持有 <code>Mutex::Autolock _l(mLock)</code> 的堆栈信息,audio进程中的2945线程执行listAudioPorts 方法持锁 <code>Mutex::Autolock _l(mLock)</code> 并通过 <code>mustAnonymizeBluetoothAddress</code> 需要进一步访问system_server的权限管理服务。<br><img src="/blog_imgs/2_watchdog_2/audio1.png" alt="ee0a7b9093c50afcc7e28d845eba818e.png"></p><p>上述流程存在audio和system_server进程间死锁情况。</p><h3 id="5-4-堆栈看似相同实则不同-耗时异常"><a href="#5-4-堆栈看似相同实则不同-耗时异常" class="headerlink" title="5.4 堆栈看似相同实则不同,耗时异常"></a>5.4 堆栈看似相同实则不同,耗时异常</h3><p>前后两次dump的trace文件阻塞点,粗略看一致(绿色部分)，仔细看堆栈不一致(其他颜色部分)， 客制化代码耗时导致。<br><img src="/blog_imgs/2_watchdog_2/same_backtrace.png" alt="7815c48c6755fe0070ac293716aeb34c.png"></p><h3 id="5-5-三把锁导致的死锁"><a href="#5-5-三把锁导致的死锁" class="headerlink" title="5.5 三把锁导致的死锁"></a>5.5 三把锁导致的死锁</h3><p>主线程<code>tid=1</code>等待线程<code>378</code>紫色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_1.png" alt="6602a76a3aaa54e8b7291478da2fcf5d.png"><br>线程<code>378</code>等待线程<code>369</code>红色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_3.png" alt="c1bec46d21e004b379bad921350057c9.png"><br>线程<code>369</code>等待线程<code>1</code>蓝色的锁。<br><img src="/blog_imgs/2_watchdog_2/3_deadlock_2.png" alt="1f7667b560ce6178895cb74ab032499e.png"></p><h3 id="5-6-kernel模块异常"><a href="#5-6-kernel模块异常" class="headerlink" title="5.6 kernel模块异常"></a>5.6 kernel模块异常</h3><p><code>system_server</code>中动画线程等待<code>Binder</code>对端返回,从代码来看对端未SF进程。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_1.png" alt="af25851c06a8d990a61d3c1d3e8cd1ab.png"><br>查看对应接口,发现SF线程<code>1247</code>等待主线程<code>775</code>。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_2.png" alt="6e6d0c5df46ec6d82c85ed552ec8a363.png"><br>SF主线程等待<code>Binder</code>对端返回对端为<code>728</code>线程,查看堆栈,发现未能dump出来。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_3.png" alt="1e83be08823e434a2be7d8126e130390.png"><br>最后查看kernellog中dump出来的kernel异常D状态进程信息,发现728存在D状态阻塞在模块A,需要<strong>模块A</strong>排查异常。<br><img src="/blog_imgs/2_watchdog_2/%E6%A8%A1%E5%9D%97A_4.png" alt="fad3207864cbc9f3900d939ecdc7f479.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通过两篇文章，SWT问题中的watchdog原理我们基本上已经梳理清楚。文章开始围绕着system_server中存在的两个问题开始讲起，以及到后面的不断补充完善，提及输入的日志，分析了输出的日志信息，并且根据日志提供了遇到过的一些SWT案例分析日志来阐述system_server中的watchdog原理。总结为以下几点：</p><ul><li>问题一细化</li><li>问题二细化</li><li>日志讲解</li><li>案例分析</li></ul><p>最后再提出一个问题：<br>system_server中存在的问题，使用一个watchdog线程来做监控，大家有没有想过万一watchdog线程异常了怎么办（虽然概率小，但还是存在）？watchdog线程监控功能不就失效了吗？手机还是会一直卡死。那么怎么解决这个新问题或者怎么监控这个问题？</p><blockquote><p>难道我们我们再使用一个system_server中的线程A来监测吗？万一线程A又异常了怎么办？使用线程B…C…<br>虽然问题概率低，并且上面的方式不行，但是我们还是得监控。我们能否使用一个内核的进程&#x2F;模块来监控它呢？<br>——可行，MTK:Hang_detect机制、展锐：Native_Hang机制</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>SWT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>SWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android system_server-watchdog机制介绍（上）</title>
    <link href="/2025/03/23/1_watchdog_%E4%B8%8A/"/>
    <url>/2025/03/23/1_watchdog_%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-system-server进程存在哪些问题？"><a href="#1-system-server进程存在哪些问题？" class="headerlink" title="1. system_server进程存在哪些问题？"></a>1. system_server进程存在哪些问题？</h2><p>在整个<code>Android</code>系统中最为重要的一个进程就是<code>system_server</code>进程，对于应用程序来说<code>system_server</code>进程提供应用进程所需的一切，<code>system_server</code>进程的正常工作是整个手机系统正常运行的保障，这样用户才能够顺利使用手机。</p><ul><li><p><strong>问题一</strong>：<br>在我们开发者的眼中，一个复杂功能的进程中往往包含了各个线程，并且将复杂功能拆分成各个模块，使用各个线程运行各个功能模块的逻辑，将各个功能联动起来。<code>system_server</code>进程的功能非常复杂，使用的线程也非常多。各个功能被抽象成一个个服务，例如和应用程序界面显示相关的<code>WMS</code>（WindowManagerService）服务，和应用组件相关的<code>AMS</code>（ActivityManagerService）服务等，这些服务在<code>system_server</code>进程中以一个个对象实例的形式存在（单例）。从设计的角度来讲，这些服务也是分等级的，有些服务稍显得没那么重要，有些服务例如和窗口显示相关的WMS服务、和应用组件相关的AMS服务等都是比较重要的。<code>system_server</code>进程作为其他进程的数据处理中心，基本所有进程都访问<code>system_server</code>中的各个服务，如果两个应用进程同时访问<code>system_server</code>中的同一个服务，因为服务本身只有一个不可能让所有进程都同时访问到，那么只能排队访问，一个一个访问。那么<code>system_server</code>如何让他们轮着访问呢？答案就是使用锁-对象锁，每个服务都有自己对象锁，使用锁的形式来保证顺序访问。<br><strong>举例</strong>:当进程A来访问<code>system_server</code>中的<code>AMS</code>服务时候那么就先持有<code>AMS</code>实例的对象锁。访问完则释放给其他进程使用，这样又有了新的问题：万一<code>AMS锁</code>被某个流程长期的占用一直不释放怎么办，出现长时间持锁，另外一个情况就是多线程的使用，当各模块服务之间交互的时候就可能出现死锁异常，所以目前可能会出现的两个问题就是：代码流程耗时、逻辑出现死锁。两个问题引起线程长时间持锁的异常，造成<code>system_server</code>卡死，其他进程就无法根本无法使用访问到对应服务，这样系统不就长时间卡死了吗？那么我们要如何解决这个问题呢？</p></li><li><p><strong>问题二</strong>：<br>其次，这些服务逻辑功能的实现离不开各个线程的运行，在<code>system_server</code>中线程也是分作用和功能的，有负责整个<code>system_server</code>进程初始化工作的主线程：<code>main</code>线程，显示相关的<code>android.display</code>线程，动画相关的<code>android.anim</code>线程，用来处理各个客户端应用进程的逻辑的31个<code>binder线程</code>等等。由于线程的分工不一样，他们的重要性就不一样，像<code>main</code>、<code>ui</code>、<code>display</code> 等这些关键的线程处理事务时候是不能出现长时间卡死的，不能长时间只处理一个事务。这样在用户体验上就是极度的顿卡，那么我们如何解决这样的问题呢？</p></li></ul><h3 id="1-1-需要解决的问题"><a href="#1-1-需要解决的问题" class="headerlink" title="1.1 需要解决的问题"></a>1.1 需要解决的问题</h3><p>针对上面的描述目前我们要解决的问题：</p><ul><li>各个关键服务（<code>AMS</code>、<code>WMS</code>、<code>IMS</code>等）不能被某一逻辑长时间占用，即关键服务的对象锁不能被某些线程长时间的持有（死锁，逻辑异常等）</li><li>各个关键线程（<code>main</code>、<code>i/o</code>、<code>ui</code>、<code>display</code>等）不能出现耗时，即关键线程的消息要及时处理完</li></ul><h2 id="2-思考如何解决问题"><a href="#2-思考如何解决问题" class="headerlink" title="2. 思考如何解决问题"></a>2. 思考如何解决问题</h2><p>所以我们要怎么解决这两个问题呢？</p><blockquote><p>答案： 程序员优化代码逻辑。额。。。但情况确实就是这样的，但是起码要让程序员知道哪些逻辑是异常的，所以从<code>system_server</code>的角度来讲我们要对上面问题场景进行监测，当监测到问题时我们将所需日志完整的输出出来，交给程序员解决。</p></blockquote><p>这也就引出了我们今天的主题：<code>system_server</code>进程中的<code>watchdog监测机制</code>。<br>（请注意它是个监测机制，基本上所有的稳定性问题都有对应的监测机制，要分析稳定性问题就要先熟悉对应的监测机制）</p><p>在<code>system_server</code>中我们采取的策略是：我们使用一个新的线程（<code>watchdog线程</code>）来监测上面两个问题，当问题发生时我们将日志保留下来，提供给程序员分析解决异常点（当然这里使用一个线程来进行监测也会有问题，例如<code>watchdog线程</code>卡死了怎么办，难道再使用一个线程来监控吗？这又可以引出另外一个专题，暂时先不多展开）。</p><p>当然这是从我们程序员的角度来看，我们只需要查看日志并解决问题即可。但是从用户体验的角度上来看，出现问题时手机将会长时间顿卡，当问题包含死锁等情况时候，手机可能会一直卡死。在使用可拆卸电池手机的年代，我们用户可以将电池拆下来，直接断电重启可以解决问题。而今电池和手机是封装在一块的，出现这种问题就只能等待手机电量耗尽手机重启才能恢复，这对于用户来说是体验很糟糕的，所以我们要在<code>watchdog机制</code>中制定一个标准，通过手机卡住的时间来衡量问题的严重性，卡住的时间超过用户能忍受的时间直接触发手机重启，让用户能够恢复手机的使用。</p><p>所以目前<code>watchdog机制</code>要解决的问题进一步细化：</p><ul><li>检测关键服务的对象锁是否被某线程长时间占用（死锁、逻辑耗时阻塞），异常情况输出日志</li><li>检测关键线程运行逻辑是否阻塞，异常情况输出日志</li><li>根据异常的时间长短，划分异常的严重性，长时间异常则重启手机，短时间异常则尽可能输出日志让程序员能够知道问题的原因</li></ul><p>针对这上面提出的三个点我们需要怎么样设计代码</p><h2 id="3-如何设计Watchdog机制？"><a href="#3-如何设计Watchdog机制？" class="headerlink" title="3. 如何设计Watchdog机制？"></a>3. 如何设计Watchdog机制？</h2><p>因为我们无法真正从代码设计者的角度去剖析这个代码的由来（因为代码不是我们设计的，但是我们可以通过读代码来反推作者可能这样设计的原因，我查阅了历史watchdog的源码，发现现有Android 15的Watchdog框架延续的是android-4.4.4_r1的watchdog版本,历经10多个版本框架原理基本没有改变，和android-4.4.4_r1以前的watchdog框架基本截然不同，说明android-4.4.4_r1的watchdog代码很健壮）</p><h3 id="3-1-system-server的功能和线程情况"><a href="#3-1-system-server的功能和线程情况" class="headerlink" title="3.1 system_server的功能和线程情况"></a>3.1 system_server的功能和线程情况</h3><p>在此之前我们需要了解一下system_server的功能以及线程的情况，才能更好的结合问题点来设计解决问题的方案。<br>（dump出<code>system_server</code>中启动所有binder服务：<code>adb shell dumpsys system_server_dumper</code>）</p><p><img src="/blog_imgs/1_watchdog_1/Image.png" alt="bc8d1d931735e23f805b22208bb33b6b.png"></p><p>不完全统计可能有100+个服务运行在system_server进程之上，我们要监控比较重要的服务对象：<br>考虑的点（猜测）：和用户进程交互比较频繁的服务，功能比较复杂比较多的服务，功能越多越复杂，线程交叉使用得多越容易死锁，例如如下这些服务：</p><ul><li>StorageManagerService</li><li>MediaProjectionManagerService</li><li>MediaRouterService</li><li>InputManagerService</li><li>PowerManagerService</li><li>WindowManagerService</li><li>ActivityManagerService</li></ul><p>各个服务模块逻辑的实现离不开<code>system_server</code>的各个线程，主要包含下面的一些线程（不完全功能按照来进行划分，粗略统计线程数量300+）</p><p><img src="/blog_imgs/1_watchdog_1/Image_1.png" alt="95a32af7d527a1dfb76b3f20ed66f62c.png"></p><ul><li>橘黄色框图：各个服务模块的线程，线程名和模块相关</li><li>绿色框图：重要的系统线程，按照线程处理的事务类型来进行划分，说白了就是<strong>公共线程</strong>，其他模块要是要处理的事务符合对应线程处理的事务类型，他就可以使用该线程来处理自己的事务。</li><li>橙色框图：Binder线程，用于和其他进程交互</li><li>蓝色框图：基础线程，每个Android应用进程都基本配备的线程</li><li>紫灰色框图：起辅助作用普通线程，线程池线程，和Hal层服务交互的HWBinder线程</li></ul><p>整个<code>system_server</code>进程从功能和线程的角度来看就上图的描述那样。<br>简单介绍如下线程</p><ol><li><p>基础线程（apk进程也是如此）<br>1.1 <strong>基础线程：main</strong>： 主线程初始化工作，<br>1.2 <strong>基础线程：守护线程</strong>:<br>1.2.1 <code>ReferenceQueueDaemon</code> 垃圾回收相关：清理Java引用对象，<br>1.2.2 <code>FinalizerDaemon</code> 垃圾回收相关：清理重写finalize()的对象，<br>1.2.3 <code>FinalizerWatchdogDaemon</code>：垃圾回收相关：监测 FinalizerDaemon线程，<br>1.2.4 <code>Signal Catcher</code>：信号处理函数，堆栈dump工作<br>1.2.5 <code>HeapTaskDaemon</code>：垃圾回收相关：堆内存<br>1.2.6 <code>Profile Saver Android</code> 混合编译相关<br>1.2.7  <code>Jit thread pool worker thread</code>:JIT即时编译相关</p></li><li><p><strong>Binder线程</strong>：和Binder驱动紧密相连，是其他进程和system_server进程交互的重要桥梁<br>2.1 binder:Pid_N(1-20,A-F,1A-1F) &#x3D; 20+6+6&#x3D;32个，包含1个binder主线程和31个binder普通线程<br>2.2 HwBinder</p></li><li><p><strong>普通线程</strong>：<br>3.1 pool-X-thread-Y: 线程池产生的线程,可复用<br>2.2 Thread-N：普通线程，不可复用</p></li><li><p><strong>各服务功能线程</strong>：线程名和功能相关</p></li><li><p><strong>系统公共线程</strong>：</p></li></ol><table><thead><tr><th>Name</th><th>priority</th><th>作用</th></tr></thead><tbody><tr><td>android.fg</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>前台公共线程，该线程设计的特别之处就是当处理的消息有超时的情况就会打印出来，它要求处理的消息要快，我们在system log能看到：Slow delivery XX等等log就是这里设置的</td></tr><tr><td>android.ui</td><td>THREAD_PRIORITY_FOREGROUND &#x3D; -2</td><td>处理系统进程UI相关的事务，它是一个fg线程（有消息超时会打印日志），和上面的fg线程不同的是它属于一个进程的Group中（THREAD_GROUP_TOP_APP &#x3D; 5），因为显示UI要进行额外的加速处理和CPU调度策略相关</td></tr><tr><td>android.io</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>文件读写相关的事务，无耗时监控</td></tr><tr><td>android.display</td><td>THREAD_PRIORITY_DISPLAY +1&#x3D; -4  +1 &#x3D;-3</td><td>处理系统显示事务相关（WindowManager，DisplayManager，InputManager使用），拥有较高线程优先级，无耗时监控</td></tr><tr><td>android.anim</td><td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td><td>处理系统动画相关的事务（窗口动画，启动动画等），线程优先级 ，无耗时监控</td></tr><tr><td>android.anim.lf</td><td>THREAD_PRIORITY_DISPLAY &#x3D; -4</td><td>处理系统动画相关的事务和Vsync相关，线程优先级</td></tr><tr><td>android.bg</td><td>THREAD_PRIORITY_BACKGROUND &#x3D; 10</td><td>后台线程，公共使用，有耗时监控</td></tr><tr><td>android.perm</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>权限处理相关公共线程，有耗时监控</td></tr><tr><td>android.usagestats</td><td>THREAD_PRIORITY_DEFAULT &#x3D; 0</td><td>usagestatus数据处理相关 ，有耗时监控</td></tr></tbody></table><p><strong>watchdog监控的线程</strong>：处理逻辑较多，和用户体验挂钩，窗口显示，动画，UI显示.</p><h3 id="3-2-如何进行监控？"><a href="#3-2-如何进行监控？" class="headerlink" title="3.2 如何进行监控？"></a>3.2 如何进行监控？</h3><ul><li><strong>监测重要线程</strong>：只需要通过<code>watchdog</code>监控线程给对应线程发送一条消息，看对应线程在对应时间能不能处理完就行，不能执行完成，则可能线程出现阻塞</li><li><strong>监测重要对象</strong>：只需要通过<code>watchdog</code>监控线程去使用一次对应对象，即获取一下对象锁能不能获取得到，不能获取到，则对象被某一线程长时间占用，可能线程出现阻塞.目前<code>watchdog</code>设置的时间是<strong>30s</strong>去检测一次（为什么是<strong>30s</strong>，这个我暂时无从考证，可能是由于一分钟&#x3D;60s&#x3D;2个30s）</li></ul><p>第一点较容易实现，<code>watchdog线程</code>向各个线程发送一条消息，在规定时间内是否及时响应。</p><p>第二点稍微难一点，我们的实现方式是：各个重要服务对象都实现一个持锁的方法即可，方法主动使用<code>synchronized</code> (自身服务对象锁)获取一次锁，规定时间内是否能及时获取到。</p><p>目前我们可以根据问题得到下图，<code>watchdog线程</code>给每个重要的线程发消息</p><p><img src="/blog_imgs/1_watchdog_1/Image_2.png" alt="34d72c510426dd1ed301261c8ddc39ab.png"></p><p>对于第二点，需要都调用各个重要服务的该方法来完成一次检查，这里和第一点有相似之处的实现逻辑：都是需要去检查是否出现耗时，所以第二点逻辑实现上我们可以抽象一下（Java中面向对象）：使用单独一个线程去做获取各个重要服务对象锁这件事情。</p><p>那么目前得到下图，我们新增加了一个线程：<code>watchdog:monitor</code>,watchdog线程的事情就变成：给包括<code>watchdog.monitor</code>在内的重要线程发送一条消息，如果消息不能定时处理完成则异常，否则正常。</p><p><img src="/blog_imgs/1_watchdog_1/Image_3.png" alt="b60af6764cd22190019181812416f28d.png"></p><p>以上就是<code>watchdog框架</code>的树干部分，从现在我们就可以去梳理代码，将细枝末节的树叶补充完整。(我会先提出问题再回答这种形式来逐个将细节呈现出来)</p><h3 id="3-3-代码实现一：问题的抽象"><a href="#3-3-代码实现一：问题的抽象" class="headerlink" title="3.3 代码实现一：问题的抽象"></a>3.3 代码实现一：问题的抽象</h3><p>对于上述的图片中我们大概框架已经显现出来了<br>问题：对于我们<code>watchdog线程</code>只需要做的事情就是隔一段时间就发个消息去监测一下各个重要线程（新增加的<code>watchdog.monitor</code>&#x2F;<code>main</code>&#x2F;<code>android.fg</code>&#x2F;<code>android.ui</code>等）是否阻塞就行，那么我们使用什么数据结构来保存这些重要线程呢？或者我们是否重新将这些线程和其他因素考虑在一起封装成一个新的对象呢？<br>考虑因素：</p><ul><li>对于<code>watchdog线程</code>发消息去<code>check</code>各个线程这个事情，了解<code>Android线程模型</code>的的都知道，其实本质就是获取对应线程的handler调用<code>mHandler.postAtFrontOfQueue</code>发送消息即可，即通过<code>Handler</code>去<code>check</code>各个线程是否阻塞–&gt;<strong>HandlerChecker</strong><ul><li><code>(main)Handler.postAtFrontOfQueue</code></li><li>…</li><li><code>(android.fg)Handler.postAtFrontOfQueue</code></li></ul></li><li>假如我们现在有一个模块线程想要被watchdog线程监测，但是我只想watchdog来检测我的时候，由于我模块功能的特殊性检测时候只要我线程10s内不阻塞就行，因此需要提供一个客制化超时时间的方法—&gt;<strong>AndTimeout</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;HandlerCheckerAndTimeout&gt; mHandlerCheckers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()<br></code></pre></td></tr></table></figure><p>所以<code>HandlerCheckerAndTimeout</code>实际上就是要保存各个检测线程的<code>handler</code>，以及特别定制化的超时时间<code>timeout</code>。所以我们进一步看<code>HandlerCheckerAndTimeout</code>的成员有<code>mHandler</code>以及客制化超时时间<code>mCustomTimeoutMillis</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Holds a checker and its timeout. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerCheckerAndTimeout</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HandlerChecker mHandler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;Long&gt; mCustomTimeoutMillis;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HandlerCheckerAndTimeout</span><span class="hljs-params">(HandlerChecker checker, Optional&lt;Long&gt; timeoutMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mHandler = checker;<br>        <span class="hljs-built_in">this</span>.mCustomTimeoutMillis = timeoutMillis;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">//其他方法容易理解类似get/set这样的方法故省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用一个<code>ArrayList</code> 来保存各个检测的对象，所以在<code>watchdog</code>初始化时候会将<code>mHandlerCheckers</code>填满，将各个检测对象<code>add</code>到对应成员中，这里大家可以看一下<code>watchdog</code>的构造函数即可。</p><ul><li>运行<code>watchdog线程</code></li><li>将新的<code>watchdog.monitor线程</code>运行起来并加入监测列表中</li><li>将其他重要监测线程加入到监测列表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Watchdog</span><span class="hljs-params">()</span> &#123;<br>    mThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::run, <span class="hljs-string">&quot;watchdog&quot;</span>);<br>    <br>    <span class="hljs-type">ServiceThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceThread</span>(<span class="hljs-string">&quot;watchdog.monitor&quot;</span>,<br>            android.os.Process.THREAD_PRIORITY_DEFAULT, <span class="hljs-literal">true</span> <span class="hljs-comment">/*allowIo*/</span>);<br>    t.start();<br>    mMonitorChecker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(t.getLooper()), <span class="hljs-string">&quot;monitor thread&quot;</span>, mLock);<br>    mHandlerCheckers.add(withDefaultTimeout(mMonitorChecker));<br><br>    mHandlerCheckers.add(<br>            withDefaultTimeout(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerChecker</span>(FgThread.getHandler(), <span class="hljs-string">&quot;foreground thread&quot;</span>, mLock)));<br>    <span class="hljs-comment">//...相似实现</span><br><br>    <span class="hljs-comment">// Initialize monitor for Binder threads.</span><br>    addMonitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BinderThreadMonitor</span>());<span class="hljs-comment">//后面在提</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到图四，我们虽然抽象出了<code>HandlerCheckerAndTimeout</code>（<code>handler</code>和<code>客制化timeout</code>），但是我们想一下，我们<code>watchdog.monitor线程</code>检查工作和其他线程（例如<code>main线程</code>）检查工作完全不一样，其他线程只需要调用<code>Handler.postAtFrontOfQueue</code>即可，<code>watchdog.monitor线程</code> 需要逐个便利各个服务对象实例的方法去进行持锁检查。为了功能的实现我们当然分开去实现，但是为了代码统一，减少额外的代码，我们能否将将两个<code>check事项</code>抽象为一个新的类？</p><p>可以，我们将两个事项进一步抽象<code>HandlerChecker</code>，并且在<code>HandlerChecker</code>中将两个<code>check事项</code>区分开来就行。<br>我们将<code>watchdog.monitor线程</code>需要<code>check</code>的一个个重要服务称为一个个<code>monitor</code>，对应每个重要服务都实现对应的方法来完成自身模块是否异常的逻辑（对于monitor()方法的实现,大多数模块直接获取当前模块的同步锁对象即可，一些特殊的模块可以根据模块自定义实现例如：StorageManagerService 服务则直接调用Vold进程的相关方法来判断自身模块的阻塞情况）<br>（我们可以在源码搜<code>Watchdog.Monitor</code>关键字就可以知道watchdog.monitor线程一共监测这多少个重要服务他们分别是什么）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象接口继承此接口即可实现自己服务的耗时逻辑监控</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Monitor</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitor</span><span class="hljs-params">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>所以HandlerChecker中我们要使用一个数据结构来保存watchdog.monitor的监测对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChecker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Monitor&gt; mMonitors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Monitor&gt;();<span class="hljs-comment">//保存watchdog.monitor线程的监测对象:各个重要服务对象的实例</span><br><br>    <span class="hljs-comment">//watchdog线程触发的接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCheckLocked</span><span class="hljs-params">(<span class="hljs-type">long</span> handlerCheckerTimeoutMillis)</span> &#123;<br>        ...<br>        mHandler.postAtFrontOfQueue(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//message具体检查事务逻辑细节:</span><br>    <span class="hljs-comment">//也是watchdog.monitor和其他main，android.ui等HandlerCheckers区别的关键</span><br>    <span class="hljs-comment">//* HandlerCheckers:watchdog.monitor 循环遍历各个monitor调用对应的monitor方法持锁排查</span><br>    <span class="hljs-comment">//* HandlerCheckers:main/android.ui/android.fg等，写一个标志位代表我的线程已经按时执行完成了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//下面这个循环主要是watchdog.monitor线程执行调用，只有HandlerCheckers：watchdog.monitor有monitor成员</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mMonitors.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; size ; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                mCurrentMonitor = mMonitors.get(i);<br>            &#125;<br>            mCurrentMonitor.monitor();<br>        &#125;<br>        <span class="hljs-comment">// 所有的HandlerCheckers都写一个标志位，代表我的线程已经顺利完成检查工作</span><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            mCompleted = <span class="hljs-literal">true</span>;<br>            mCurrentMonitor = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中我们能看到使用list来保持monitor对象。以及发送的message的实现（run()）<br>所以目前我们<code>watchdog框架</code>中的<code>HandlerCheckers</code>梳理框架图如下图：</p><p><img src="/blog_imgs/1_watchdog_1/Image_4.png" alt="eddf82180df94170ee26ec6641f059cb.png"></p><p>在mHandlerCheckers中保存了众多的HandlerChecker，仔细分类可以分为：Monitor Checker和Hander Checker</p><ul><li><strong>Monitor Checker</strong>，用于检查是Monitor对象可能发生的”卡死“, <code>AMS</code>, <code>PKMS</code>, <code>WMS</code>等核心的系统服务都是<code>Monitor</code>对象，通过<code>watchdog.monitor</code>线程来检查。</li><li><strong>Handler Checker</strong>, 纯粹意义上的HandlerChecker,主要检测各个线程消息处理是否阻塞</li></ul><p><strong>补充</strong>：Binder线程是其他进程和system_server进程交互的通道，一共32个线程，当这32个线程出现阻塞，或者都繁忙无法继续处理来自其他进程的交互，这个时候会导致异常，系统也会出现卡死。我们需要对这种异常进行监控，所以添加一个monitor：<code>BinderThreadMonitor</code>交给<code>watchdog.monitor</code>线程来监控，所以我们在玫红色框图中看懂一个灰色的<code>monitor</code>成员。所以对于<code>Monitor Checker</code>进一步区分分为：<strong>普通服务监控monitor</strong>和<strong>binder线程监控monitor</strong></p><p>根本上这两类HandlerChecker就是对应着文章开头提出的两个问题1和问题2。（这两个概念比较重要，对于SWT问题的分析特别重要）</p><h3 id="3-4-代码实现二：异常的衡量"><a href="#3-4-代码实现二：异常的衡量" class="headerlink" title="3.4 代码实现二：异常的衡量"></a>3.4 代码实现二：异常的衡量</h3><p>上面的<code>check项</code>，我们都已经抽象完成。那么我们的一个<code>HandlerChecker</code>出现卡死究竟<strong>卡死多久才算异常呢？有没有一个衡量标准？</strong></p><p>阻塞卡死都归结到<code>HandlerChecker</code>是否正常，我们给每个<code>HandlerChecker</code>都设置一个状态值：state，代表<code>HandlerChecker</code>的阻塞程度</p><p>默认的标准是这样的：</p><table><thead><tr><th>state 状态</th><th>timeout</th><th>作用</th></tr></thead><tbody><tr><td>COMPLETED</td><td>timeout &#x3D;0</td><td>当HandlerChecker正常情况下不阻塞，线程能够瞬间的完成message的事务，状态良好</td></tr><tr><td>WAITING</td><td>0&lt;timeout &lt;30s</td><td>当HandlerChecker出现阻塞，线程能够30s内完成message的事务，稍微耗时可能能恢复</td></tr><tr><td>WAITED_HALF</td><td>30s&lt;timeout &lt;60s</td><td>当HandlerChecker出现阻塞，线程能够30s-60s内完成message的事务，耗时以及过半了，可能阻塞恢复不了了</td></tr><tr><td>OVERDUE</td><td>60s&lt;timeout</td><td>当HandlerChecker出现阻塞，线程能够60s都完成不了message的事务，耗时超过1分钟，完了，用户现在可能极度不满</td></tr></tbody></table><p><img src="/blog_imgs/1_watchdog_1/Image_5.png" alt="ec73f97d532c22b08cbc129770c49e68.png"></p><p>判断系统卡死的事情基本解决完毕,<strong>那么我们需要什么时机输出日志呢?以及需要输出那些日志呢?</strong></p><p><code>watchdog线程</code>使用一个死循环,每隔<code>30s</code>去<code>check</code>一次各个<code>HandlerChecker</code>,获取各个<code>HandlerChecker</code>的状态是否正常.</p><ul><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>COMPLETED,WAITING</code>),卡<strong>0-30s</strong>内我们认为可以接受,等下一个<code>30s</code>再去检查一次</li><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>WAITING_HALF</code>),卡<strong>30s-60s</strong>系统可能存在问题了,需要dump一些log,再等下一个<code>30s</code>去检查一次</li><li>当存在一个<code>HandlerChecker</code>的<code>state</code>是(<code>OVERDUE)</code>,卡<strong>大于60s</strong>,系统已经出现问题,用户以及无法使用手机超过1分钟了,可能死锁了等严重阻塞问题,我们需要dump所有必要的日志,重启手机,让用户能恢复使用</li></ul><p>伪代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">run() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>        <span class="hljs-comment">//step2:休眠30s</span><br>        <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>android-4.4.4_r1的watchdog的部分检查代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//step1:调用每个HandlerChecker,检查每个HandlerChecker的状态</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;<br>                <span class="hljs-type">HandlerChecker</span> <span class="hljs-variable">hc</span> <span class="hljs-operator">=</span> mHandlerCheckers.get(i);<br>                hc.scheduleCheckLocked();<br>            &#125;<br>            <span class="hljs-comment">//step2:休眠30s</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-keyword">while</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(timeout);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Log.wtf(TAG, e);<br>                &#125;<br>                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);<br>            &#125;<br>            <span class="hljs-comment">//step3:根据HandlerChecker的状态,决定系统异常程度,以及dump log出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">waitState</span> <span class="hljs-operator">=</span> evaluateCheckerCompletionLocked();<br>            <span class="hljs-keyword">if</span> (waitState == COMPLETED) &#123;<br>                <span class="hljs-comment">// 情况良好,下次继续检查</span><br>                waitedHalf = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITING) &#123;<br>                <span class="hljs-comment">// 可能存在阻塞,时间可控,下次继续检查</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (waitState == WAITED_HALF) &#123;<br>                <span class="hljs-comment">// 存在阻塞,时间超过30s,dump日志,下次继续检查</span><br>                <span class="hljs-keyword">if</span> (!waitedHalf) &#123;<br>                    ArrayList&lt;Integer&gt; pids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                    pids.add(Process.myPid());<br>                    ActivityManagerService.dumpStackTraces(<span class="hljs-literal">true</span>, pids, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                            NATIVE_STACKS_OF_INTEREST);<br>                    waitedHalf = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//存在阻塞,时间超过60s,系统存在问题,用户体验糟糕,尽可能收集日志,重启收集</span><br>            <span class="hljs-comment">// something is overdue!</span><br>            blockedCheckers = getBlockedCheckersLocked();<br>            subject = describeCheckersLocked(blockedCheckers);<br>            allowRestart = mAllowRestart;<br>        &#125;<br>        <span class="hljs-comment">//step4:收集日志部分</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>执行所有的<code>Checker</code>的监控方法<code>scheduleCheckLocked()</code><ol><li>是否完成检测，完成则将mMonitorQueue队列中的monitor全部加入mMonitor中；</li><li>对于HandlerChecker来说,如果目标线程空闲,则不用进一步检测,则设置mCompleted &#x3D; true，返回；</li><li>当上次check还没有完成, 则直接返回；</li><li>Watchdog线程向各个线程发送消息，看消息能否按时完成。</li></ol></li><li>等待30s后, 再调用<code>evaluateCheckerCompletionLocked</code>来评估各<code>HandlerChecker</code>状态;</li><li>根据<code>waitState</code>状态来执行不同的操作:<ol><li>当COMPLETED或WAITING,则正常，继续检查;</li><li>当WAITED_HALF(超过30s)且为首次, 则输出system_server和3个Native进程的traces;</li><li>当OVERDUE, 则输出更多信息,并重启系统。</li></ol></li></ol><p>综合上之前的信息，我们目前可以得到下面这个框架图</p><p><img src="/blog_imgs/1_watchdog_1/Image_6.png" alt="acd22c37acbbe0d5dc72720bcc72ffe3.png"></p><h2 id="4-日志收集"><a href="#4-日志收集" class="headerlink" title="4. 日志收集"></a>4. 日志收集</h2><p>我们需要收集哪些日志呢？<br>因为我们无法得知和<code>HandlerChecker</code>卡住的具体原因，我们只能<code>dump</code>和<code>system_server</code>有交集的各个进程，特别涉及和<code>system_server</code>模块服务有相关交集的进程。<br>例如</p><ul><li>StorageManagerService–<strong>vold</strong>（volume daemon）进程</li><li>WindowManagerService–<strong>SurfaceFlinger</strong> 进程</li><li>等等以及<code>Hal</code>的服务进程<br>首先第一步<code>system_server</code>自身进程的各个线程堆栈信息要<code>dump</code>出来。<br>其次和system_server 交互的其他关系紧密的进程的堆栈也需要dump出来，这里直接给出的进程有：</li></ul><table><thead><tr><th>Name</th><th>说明</th></tr></thead><tbody><tr><td>system_server</td><td>自身进程</td></tr><tr><td>com.android.phone</td><td>由于phone进程作为一个应用层级的Binder服务，依托system_server将接口中转给其他进程使用，（遇到过phone进程system_server形成死锁的案例 ）</td></tr><tr><td>com.google.android.providers.media.module</td><td>同上，也有遇到过类似案例</td></tr><tr><td>media相关进程</td><td></td></tr><tr><td>surfaceflinger</td><td></td></tr><tr><td>netd</td><td></td></tr><tr><td>…30+</td><td>这里主要涉及在开发过程中遇到问题，不断添加完善的过程</td></tr></tbody></table><p>日志输出：</p><ul><li>当阻塞超过30s后进行一次日志输出：用户态进程堆栈，日志包含上面的用户态各个进程的各个现场现场的堆栈信息（目录   <code>data/anr/anr_日期.txt</code>）</li><li>当阻塞超过60s后进行最后一次日志输出<strong>用户态进程堆栈</strong>+<strong>kernel异常信息</strong>，这个时候系统是真的卡死了，很可能是由于<code>kernel</code> 卡死导致（内核线程死锁，阻塞，文件系统异常，内存异常，驱动模块异常等），所以我们要输出一下kernel中状态异常的进程信息<ul><li>使用 <strong>&#x2F;proc&#x2F;sysrq-trigger</strong> 节点</li><li><code>echo l &gt; /proc/sysrq-trigger</code>： 显示所有活动cpu的堆栈信息</li><li><code>echo w &gt; /proc/sysrq-trigger</code>： 将进入 <code>uninterrupted 状态</code>的任务信息 dump 出来</li><li><code>echo c &gt; /proc/sysrq-trigger</code>： 使系统崩溃，如果配置了<code>crashdump</code>，崩溃后会生成 <code>dump 文件</code><br>  (kernel-6.6&#x2F;Documentation&#x2F;admin-guide&#x2F;sysrq.rst )<br>关于dump出来的日志是一个比较复杂的内容，等后面在进一步解释。</li></ul></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文通过文字结合代码结合图片形式来讲述Watchdog机制的由来，讲的内容是粒度较大的，可能还存在部分错误，但是总统是个不断完善的过程。<br>文中比较重要的就是代码上对于两个问题的抽象是比较重要的，对于这两个概念的理解是后面分析SWT问题的基础，读者务必了解清楚。<br>文章的不足：代码部分往往很难使用语言来描述到极度详细，需要一定的代码阅读能力。<br>文章的用途：主要是用于记录自己学习watchdog机制的记录，一方面通过比较口语化的形式记录，方便后续查阅。<br>后期待办：完善问题分析例子</p>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>SWT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>SWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANR-failed to complete startup</title>
    <link href="/2025/03/20/3_ANR_failed_to_complete_startup/"/>
    <url>/2025/03/20/3_ANR_failed_to_complete_startup/</url>
    
    <content type="html"><![CDATA[<h2 id="1-新型anr：Failed-to-complete-startup"><a href="#1-新型anr：Failed-to-complete-startup" class="headerlink" title="1.新型anr：Failed to complete startup"></a>1.新型anr：Failed to complete startup</h2><p><strong>anr名称</strong>：<code>failed to complete startup</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">am_anr  : [<span class="hljs-number">0</span>,<span class="hljs-number">3317</span>,com.android.phone,<span class="hljs-number">952647245</span>,Process ProcessRecord&#123;fac2d35 <span class="hljs-number">3317</span>:com.android.phone/<span class="hljs-number">1001</span>&#125; failed to complete startup]<br></code></pre></td></tr></table></figure><p><strong>目的</strong>：<br>检测应用启动中的耗时异常主要集中于应用进程中的Application的oncreate 函数是否耗时<br><strong>超时时间</strong>：15s+应用进程等待cpu的时间（0-15s），否则触发anr<br><strong>关键log</strong>：<br>表明应用进程存在等待CPU的时间 例如：<code> 02-05 06:17:40.694  1764  1831 I ActivityManagerService: Extending process start timeout by 5088ms for ProcessRecord{a7885a8 3344:com.android.phone/1001}</code><br>在systrace中搜索 <code>bindApplicationTimeSoft</code> 表明这个时间点应用进程在Application的oncreate已经耗时15s了<br><strong>案例</strong>：<br>是否<code>oncreate</code>中耗时超过15s就会触发anr<br><strong>可取的点</strong>：</p><ul><li>anr时长考虑到cpu负载情况</li><li>根据日志能看出进程是否在<code>等待CPU</code>，等待CPU的时长能反应CPU的负载情况</li><li>在广播超时anr的检测中，也使用了考虑CPU负载的这种策略</li></ul><h2 id="2-检测时序图"><a href="#2-检测时序图" class="headerlink" title="2.检测时序图"></a>2.检测时序图</h2><p><img src="/blog_imgs/3_ANR_failed_to_complete_startup/uml.png" alt="时序图"></p><h3 id="2-1-时序图解释："><a href="#2-1-时序图解释：" class="headerlink" title="2.1 时序图解释："></a>2.1 时序图解释：</h3><p>时序图一共分为两个，第一个图是优化前，图二是加强优化后的流程，加强点使用红色线条和红框标出</p><p>图一：</p><ul><li>anr的检测和其他anr的检测流程类似，“拆炸弹和埋炸弹”<code>system_server</code> 埋炸弹，<code>应用进程</code>来触发拆炸弹</li><li>1.<code>system_server</code>调用应用进程<code>handleBindApplication</code>，“埋下定时炸弹”：埋下一条15s的定时消息（粉色提示框1）<code>BIND_APPLICATION_TIMEOUT_SOFT_MSG</code></li><li>2.应用进程进一步调用Application的<code>oncreate</code>流程，当执行完则会调用<code>finishAttachApplication</code>（绿色框）</li><li>3.<code>system_server</code> 执行<code>finishAttachApplicationInner</code> 会移除这条定时消息（粉色提示框2）</li><li>4.如果应用进程<code>Application</code>的<code>oncreate</code>未能执行完成，则定时消息时间到达<code>15s</code>就会触发<code>anr流程</code>（红色提示框）</li></ul><p>图二：<br>当cpu负载比较严重的情况下，应用进程无法抢到cpu无法执行完对应代码流程，图一的检测方式会触发更多的anr出来，但其实没必要触发那么多anr，考虑这点Google 进行了优化：anr的检测时长需要考虑应用进程等待CPU的时间。</p><h3 id="2-2-应用进程等待CPU的时间"><a href="#2-2-应用进程等待CPU的时间" class="headerlink" title="2.2 应用进程等待CPU的时间"></a>2.2 应用进程等待CPU的时间</h3><p>通过检测proc&#x2F;&lt;pid&gt;&#x2F;schedstat中的第二个值的前后变化来达成</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tcl">/<span class="hljs-keyword">proc</span>/17963 $<span class="hljs-title"> cat</span> schedstat<br>        37430675458 16041006985 59414<br>        <br><br>        https://docs.kernel.org/scheduler/sched-stats.html<br>        /<span class="hljs-keyword">proc</span>/&lt;pid&gt;/schedstat<br>        schedstats<span class="hljs-title"> also</span> adds<span class="hljs-title"> a</span> new /<span class="hljs-keyword">proc</span>/&lt;pid&gt;/schedstat<span class="hljs-title"> file</span> to<span class="hljs-title"> include</span> some<span class="hljs-title"> of</span> the<span class="hljs-title"> same</span> information<span class="hljs-title"> on</span> a<span class="hljs-title"> per-process</span> level.<br>        There<span class="hljs-title"> are</span> three<span class="hljs-title"> fields</span> in<span class="hljs-title"> this</span> file<span class="hljs-title"> correlating</span> for<span class="hljs-title"> that</span> process<span class="hljs-title"> to:</span><br>        1.<span class="hljs-title"> time</span> spent<span class="hljs-title"> on</span> the<span class="hljs-title"> cpu</span> (in<span class="hljs-title"> nanoseconds)</span><br>        2.<span class="hljs-title"> time</span> spent<span class="hljs-title"> waiting</span> on<span class="hljs-title"> a</span> runqueue (in<span class="hljs-title"> nanoseconds)</span><br>        3.<span class="hljs-title"> of</span> timeslices<span class="hljs-title"> run</span> on<span class="hljs-title"> this</span> cpu<br></code></pre></td></tr></table></figure><ul><li><ol><li>在<code>system_server</code>调用应用进程<code>handleBindApplication</code>之前获取一次应用进程的该值:<code>schedstat</code>(第一个红色框部分)</li></ol></li><li><ol start="2"><li>如果应用进程耗时<code>Application</code>的<code>oncreate</code>未能执行完成，则定时消息时间到达<code>15s</code>，再次获取应用进程的该值：<code>schedstat</code> 前后差值换算成一个时间值，然后在设置一个定时消息，定时时间为该<strong>时间值</strong>(0-15s)，如果应用进程该时间值之内还未处理完则触发<code>anr</code></li></ol></li></ul><h2 id="3-google-合入记录"><a href="#3-google-合入记录" class="headerlink" title="3.google 合入记录"></a>3.google 合入记录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">from: jji@google.com<br><br>Extend the BIND_APPLICATION_TIMEOUT<br><br>We<span class="hljs-string">&#x27;re reporting an ANR if the app process doesn&#x27;</span>t finish<br>the handling of bindApplication within the BIND_APPLICATION_TIMEOUT.<br>But very often, due to the contended system resources, the app<br>process just doesn<span class="hljs-string">&#x27;t get enough CPU time to run. So now we&#x27;</span>ll<br>extend the timeout by the time that <span class="hljs-keyword">this</span> process is waiting <span class="hljs-keyword">for</span><br>run.<br><br>Also given the bindApplication includes the time the app spends<br>on Application#<span class="hljs-built_in">onCreate</span>(), relax the timeout to <span class="hljs-number">15</span>s by <span class="hljs-keyword">default</span>.<br><br>Bug: <span class="hljs-number">304484667</span><br>Test: Manual<br>Change-Id: I<span class="hljs-number">442e997f</span>a6f30445ddeb<span class="hljs-number">2922146e837</span>cc24d4174<br></code></pre></td></tr></table></figure><h2 id="4-案例："><a href="#4-案例：" class="headerlink" title="4.案例："></a>4.案例：</h2><p>重写应用程序的Application中的oncreate方法<br>在oncreate中睡眠16s</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        Log.i(<span class="hljs-string">&quot;TAG&quot;</span>,<span class="hljs-string">&quot;application sleep&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">160000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这里有耗时行为则会触发该类anr，发生该类anr应用会直接闪退，可能不会有anr弹窗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">02</span><span class="hljs-number">-26</span> <span class="hljs-number">21</span>:<span class="hljs-number">39</span>:<span class="hljs-number">26.345</span>  <span class="hljs-number">1672</span> <span class="hljs-number">13615</span> I am_anr  : [<span class="hljs-number">0</span>,<span class="hljs-number">12825</span>,com.example.myapplication,<span class="hljs-number">552124230</span>,Process ProcessRecord&#123;<span class="hljs-number">24</span>d<span class="hljs-number">36e3</span> <span class="hljs-number">12825</span>:com.example.myapplication/u0a139&#125; failed to complete startup]<br></code></pre></td></tr></table></figure><h2 id="5-排查点"><a href="#5-排查点" class="headerlink" title="5.排查点"></a>5.排查点</h2><h3 id="5-1-从应用角度："><a href="#5-1-从应用角度：" class="headerlink" title="5.1 从应用角度："></a>5.1 从应用角度：</h3><ul><li>排查重写的<code>Application</code>的<code>oncreate</code>方法是否耗时</li><li>主要需要排查<code>main</code> log中主线程打印出来的日志是否存在耗时异常，根据日志排查代码</li><li>可以多<code>dump</code>几次<code>anr trace</code>信息，从t<code>race</code>中看主线程的<strong>阻塞点是否都是一致</strong></li></ul><h3 id="5-2-从系统角度："><a href="#5-2-从系统角度：" class="headerlink" title="5.2 从系统角度："></a>5.2 从系统角度：</h3><ul><li>排查是否是cpu负载影响应用代码的执行，从<code>system</code> log中检索<code>Extending process start timeout by</code>看看应用进程在这段时间内等待CPU的时间是多少</li><li>例如：<br><code>02-05 06:17:40.694  1764  1831 I ActivityManagerService: Extending process start timeout by 5088ms for ProcessRecord{a7885a8 3344:com.android.phone/1001}</code></li><li>以及排查dump出来的<code>anr trace</code>文件中排查主线程堆栈是否存在异常，几次anr的堆栈是否都一致</li><li>anr时候的<code>dump cpu占用信息</code>，anr的进程的cpu占比排名是如何？是否没有抢到cpu</li></ul>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>ANR</category>
      
      <category>failed_to_complete_startup</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InputDispatcher概览</title>
    <link href="/2024/05/22/5_InputDispatcher%E6%A6%82%E8%A7%88/"/>
    <url>/2024/05/22/5_InputDispatcher%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>基于 Android 15(2024&#x2F;5&#x2F;22时间的在线android源码)</p><ul><li><code>InputReader</code> 模块负责将原始的输入事件读取出来，以及加工处理。</li><li>接下来需要 <code>InputDispatcher</code> 模块来完成事件的派发工作。</li></ul><p>在 <code>InputDispatcher</code> 模块中重要的事情：</p><ul><li><strong>首要事情</strong>：将<code>InputReader</code> 传过来的事件派发出去，派送到应用端，<strong>事务特点</strong>：这个事件最重要，不能耽搁，必须及时派发出去</li><li><strong>次要事情</strong>： 在<code>InputDispatcher</code> 派发事件时候，难免会有一些杂项事情需要处理(比如说咨询WMS，这个事件如何处理，需要不要拦截，以及应用端处理完事件后，<code>InputDispatcher</code>需要做什么收尾工作等等)，这些都是杂项的事情.需要<code>InputDispatcher</code> 线程进行处理。 <strong>事务特点</strong>：事情杂乱，相对派发事件没有那么紧急。</li><li><strong>最后事情</strong>： 对于事件派发，需要检测事件派发过程中有没有异常。即：对于特殊事件能不能及时找到焦点窗口（派发这些事件需要一个焦点），对于派发出去的事件，应用端有没有及时完成处理。这里就是我们所描述的几种ANR中的两种。</li></ul><p>简单归纳：</p><ol><li>取事件并派发</li><li>杂项事情处理</li><li>监测事件派发是否异常(ANR)</li></ol><p>到这里可以看一下 <code>InputDispatcher::dispatchOnce()</code>函数的实现。<br>可以看到:</p><ol><li>取事件并派发–<code>dispatchOnceInnerLocked(..)</code></li><li>杂项事情处理–<code>runCommandsLockedInterruptable()</code></li><li>监测事件派发是否异常(ANR)–<code>processAnrsLocked()</code></li></ol><p>这样看是不是简单许多</p><p>我们来看这三项事情如何实现？就能熟悉 <code>InputDispatcher</code> 模块</p><p>接下来继续梳理框架，比较重要一点的细节会梳理处理，不重要的细节会略过</p><h2 id="部分一-InputDispatcher取事件派发"><a href="#部分一-InputDispatcher取事件派发" class="headerlink" title="部分一.InputDispatcher取事件派发."></a>部分一.InputDispatcher取事件派发.</h2><h3 id="1-1-dispatchOnceInnerLocked-取事件"><a href="#1-1-dispatchOnceInnerLocked-取事件" class="headerlink" title="1.1 dispatchOnceInnerLocked 取事件"></a>1.1 dispatchOnceInnerLocked 取事件</h3><p>既然取事件，派发事件那么就会有如下问题。<br><strong>问题1</strong>: <code>InputDispatcher</code>要取输入事件，要从哪里取，或者说从<code>InputReader</code>读取处理的事件被存放在哪里了?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/inputflinger/dispatcher/InputDispatcher.h</span><br>std::deque&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> EventEntry&gt;&gt; <span class="hljs-function">mInboundQueue <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mLock)</span></span>;<br></code></pre></td></tr></table></figure><p>存放在一个名为<code>mInboundQueue</code>的队列中.<code>InputDispatcher</code> 中输入事件以 <code>EventEntry</code> 形式存放。</p><p>那么<code>InputDispatcher</code>中，第一件事情：从<code>mInboundQueue</code>队列 中取事件</p><p>代码实现在 <code>dispatchOnceInnerLocked</code> 中第一步取事件。</p><p>取完事件后，<br><code>问题2</code>： 取完事件后的下一步干什么?</p><ul><li>取完事件后下一步，派发事件，但是各个事件类别种类较多9种</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> CONFIGURATION_CHANGED,<br><span class="hljs-number">2.</span> DEVICE_RESET,<br><span class="hljs-number">3.</span> FOCUS,<br><span class="hljs-number">4.</span> KEY,<br><span class="hljs-number">5.</span> MOTION,<br><span class="hljs-number">6.</span> SENSOR,<br><span class="hljs-number">7.</span> POINTER_CAPTURE_CHANGED,<br><span class="hljs-number">8.</span> DRAG,<br><span class="hljs-number">9.</span> TOUCH_MODE_CHANGED,<br></code></pre></td></tr></table></figure><ul><li>而且不同事件的派发方式也不一样.所以这里要分开处理针对每一种输入事件类型不同，不同特性，要分别去处理.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnceInnerLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;<br>    <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-number">1.</span>取事件<br>    <span class="hljs-number">2.</span>针对不同输入事件，进行分别派发<br>     <span class="hljs-number">2.1</span> CONFIGURATION_CHANGED: <br>        <span class="hljs-built_in">dispatchConfigurationChangedLocked</span>(...);<br><br>     <span class="hljs-number">2.2</span> DEVICE_RESET:<br>        <span class="hljs-built_in">dispatchDeviceResetLocked</span>(...);<br><br>     <span class="hljs-number">2.3</span> FOCUS:<br>        <span class="hljs-built_in">dispatchFocusLocked</span>(...);<br><br>     <span class="hljs-number">2.4</span> TOUCH_MODE_CHANGED: <br>        <span class="hljs-built_in">dispatchTouchModeChangeLocked</span>(...);<br><br>     <span class="hljs-number">2.5</span> POINTER_CAPTURE_CHANGED: <br>        <span class="hljs-built_in">dispatchPointerCaptureChangedLocked</span>(...);<br><br>     <span class="hljs-number">2.5</span> DRAG: <br>        <span class="hljs-built_in">dispatchDragLocked</span>(...);<br><br>     <span class="hljs-number">2.6</span> KEY: <br>        <span class="hljs-built_in">dispatchKeyLocked</span>(...);<br><br>     <span class="hljs-number">2.7</span> MOTION: <br>        <span class="hljs-built_in">dispatchMotionLocked</span>(...);<br> <br>     <span class="hljs-number">2.8</span> SENSOR: &#123;<br>        <span class="hljs-built_in">dispatchSensorLocked</span>(...);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从<code>mInboundQueue</code>队列中取出事件</li><li>针对9种不同事件，去做特殊处理.使用函数<code>dispatchXXXLocked(...)</code>(XXX：事件类型)</li></ul><p>对于<code>dispatchXXXLocked(...)</code>来说，针对9种事件暂时不去每一个都理解，这属于不同类型事件的特殊性做特殊处理</p><p><strong>问题</strong>：如何派发事件?给谁派发事件这是关键?<br>： <code>dispatchXXXLocked(...)</code> 流程处理后，大多数事件的派发都会走到<code>dispatchEventLocked</code>中。<br>这时候需要接收各类型输入事件的派发目标(Input窗口).那就分为两步：</p><ul><li>找到需要接收各类事件的窗口-目标窗口， 由于不同事件，派发的目标窗口不同，所以这里就不同输入事件查找目标窗口来说较大区别，但是明确无论有查找目标窗口的过程有多大区别，查找的结果都是一样：目标窗口</li><li>针对目标窗口派发对应事件。</li></ul><p>这里我们需要思考一下： <code>InputDispatcher模块</code> 属于<code>InputManagerService</code> 服务运行在<code>system_server</code>进程， 输入事件需要派发给应用进程，给应用进程提供事务驱动源.那么他们是如何完成通信的呢?也即输入事件通过什么进程间通信方式传给应用进程呢?</p><ul><li><strong>进程间通信方式</strong>：<code>pipe</code>、<code>socket</code>、<code>binder</code>等等<br>这里选择的是 <code>socket</code>，准确来说是 <code>socketpair</code></li></ul><p>这里可以引入一个图片：<br><img src="/blog_imgs/5_InputDispatcher/Image.png" alt="329793dba4574a7fc0acb9960fe7f176.png"><br>生成两个<code>fd</code>，<strong>fd1</strong>和<strong>fd2</strong> 用来实现双向通信<br><img src="/blog_imgs/5_InputDispatcher/Image_1.png" alt="dac676578e526a71b526b6019919dfd4.png"><br>这里是重点，需要着重强调。</p><p>既然作为通信的两端(<strong>ServerChannel</strong>和<strong>ClientChannel</strong>)</p><ul><li><code>ServerChannel</code>：一端要存在<code>system_server进程</code>的<code>InputDispatcher 模块</code>中。</li><li><code>ClientChannel</code>： 另外一端则存在于应用进程中，这样来实现事件派发。</li></ul><p><strong>问题</strong>： 应用进程如何拿到这个所谓的<code>ClientChannel</code>(<strong>fd2</strong>)?</p><p>下图是Android 11时候的<br><img src="/blog_imgs/5_InputDispatcher/Image_2.png" alt="d017548c3c465bbaabb1adc358207d87.png"><br>可以看到 socketpair 是在 WMS 模块进行创建，并分配到IputDispatcher 和 应用进程。<br>下图是Android 15的</p><p><img src="/blog_imgs/5_InputDispatcher/Image_3.png" alt="18ca3bc2cdf7b3f7d2fd98599b2f6b39.png"></p><p>两者差别不大， 区别L：15 上将<strong>socketpair</strong>的创建放在了<strong>InputDispatcher</strong>中。</p><p>大致流程：</p><ol><li>应用进程 <code>addwindow</code> 时候，<code>Binder</code>通信通知 <code>WMS</code> 。</li><li><code>WMS</code> 将创建 <code>windowState</code> ，然后通知 <code>InputDispatcher</code>，创建 <code>Socketpair</code> ，并将其中一端返回给 <code>WMS</code> ， <code>WMS</code>进一步<code>Binder</code>通信返回给应用进程。</li><li>应用进程拿到 <code>fd</code> 后，就可以通过 <code>epoll</code> 进行监听，主线程读取 <code>InputDispatcher</code> 传过来的消息。</li></ol><p>在 <code>InputDispatcher</code> 中，<code>Socketpair</code>的另一端将封装成一个个的<code>connection</code>中，如上图。<br>回到刚才的流程： 针对目标窗口派方法事件，通过目标窗口找到对应的<code>connection</code>，进而通过<code>connection</code>封装的<strong>fd</strong> 写入输入事件，应用程序就可以收到。</p><p>对于事件的派发大致流程就如上，比较模糊的点：</p><ul><li>针对不同事件，如何找到目标派发的窗口–TODO</li><li>给应用程序除了发送事件信息，还发送了些什么?–TODO</li></ul><h2 id="部分二：InputDispatcher杂项处理"><a href="#部分二：InputDispatcher杂项处理" class="headerlink" title="部分二：InputDispatcher杂项处理"></a>部分二：InputDispatcher杂项处理</h2><p>部分一处理的是关键任务：事件的派发，派发过程中难免会有额外的事情需要处理。<br>例如：</p><ol><li>对于处理<strong>configuration</strong>这个事件时，需要让WMS知道。</li><li>处理<code>key事件</code>派发前，咨询一些WMS要不要先响应这个事件。</li><li>等等各类事务。</li></ol><p>在这一块上，<code>InputDispatcher</code>中，进行了封装.将所有这些事件都抽象成一个<code>command</code>，然后构建一个队列： <code>mCommandQueue</code>。只要有杂项事务需要处理，就封装一个<code>command</code>，存到 <code>mCommandQueue</code> 中。<code>InputDispatcher</code>线程不断监测这个队列是否有事件，有事件就处理。</p><p>查看<code>InputDispatcher::dispatchOnce()</code>函数的实现。<br>2. 杂项事情处理–<code>runCommandsLockedInterruptable()</code></p><p>这块其实框架并不复杂，对于三个部分的处理其实都是在<code>inputDispatcher</code> 线程本身在处理。所谓的<code>command</code>只不过是一个的函数指针，使用一个函数指针队列(<code>mCommandQueue</code>)将各个函数接口存放在一起，这里的处理框架比init进程中的处理框架<code>ActionManager</code>简单得多。在<code>InputDispatcher</code>中直接使用一个函数指针队列存放各个杂项事务，主线程监听函数指针队列(<code>mCommandQueue</code>)，有事务就进行处理。</p><h2 id="部分三：InputDispatcher事件派发监测"><a href="#部分三：InputDispatcher事件派发监测" class="headerlink" title="部分三：InputDispatcher事件派发监测"></a>部分三：InputDispatcher事件派发监测</h2><p>对于<code>ANR</code>的监测是比较细节的，我们这里只梳理大概框架，两类<code>ANR</code>的剖析换另外一篇文章阐述。<br>这里有两种检测：</p><ul><li><strong>派发事件过程中</strong>能否及时获取到焦点窗口-无焦点窗口ANR</li><li>事件派发完后，应用进程能否及时处理完-事件处理耗时ANR</li></ul><p>对于部分一：</p><ul><li>针对不同事件，如何找到派发事件的目标窗口。<br>这一块对于<code>key事件</code>，<code>motion事件</code>有些特殊。这里需要确切的找到焦点窗口，如果没有及时的找到那是不行的，事件是无法继续往后派发的。</li></ul><p>焦点窗口是由WMS进行设置的，所以我们需要WMS时刻给我们传焦点窗口过来(这里把sf和WMS说一块，都是WMS模块，实际上是WMS设置完转交给sf，sf再传给InputDispatcher中)。</p><p>我们需要使用一个数据结构来进行存放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>std::unordered_map&lt;<span class="hljs-type">int32_t</span> /* displayId */, NamedToken&gt; mFocusedWindowTokenByDisplay<br></code></pre></td></tr></table></figure><p>提供两个外部访问的接口：</p><ul><li><strong>setFocusedWindow</strong></li><li><strong>setInputWindows</strong></li></ul><p><strong>无焦点窗口ANR监测原理</strong>： 首次找不到焦点窗口时候设置一个定时时间值，下一次再次查找焦点窗口时候，当前时间超过设定的时间值，则触发anr。</p><p><strong>输入事件处理超时ANR检测原理</strong>： 当向对应的窗口发送完输入事件后，由于情况有：多个窗口，或者一个窗口，接收多个事件，所以使用一个数据结构：<strong>map</strong>。向目标窗口派发一个事件后，封装一个<strong>超时时间值</strong>以及<strong>窗口识别标识</strong>存入map中，检查时候，如果从map中取出来的最早的时间超过了当前时间则，触发anr。</p><p>检查的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">nsecs_t</span> <span class="hljs-title">InputDispatcher::processAnrsLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br><span class="hljs-comment">//#### 无焦点窗口anr检测</span><br>    <span class="hljs-comment">// Check if we are waiting for a focused window to appear. Raise ANR if waited too long</span><br>    <span class="hljs-keyword">if</span> (currentTime &gt;= *mNoFocusedWindowTimeoutTime) &#123;<br>        <span class="hljs-built_in">processNoFocusedWindowAnrLocked</span>();<span class="hljs-comment">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;触发无焦点窗口anr处理</span><br>        <span class="hljs-keyword">return</span> LLONG_MIN;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//#### 输入事件超时anr检测</span><br>    <span class="hljs-comment">// Check if any connection ANRs are due</span><br>    nextAnrCheck = std::<span class="hljs-built_in">min</span>(nextAnrCheck, mAnrTracker.<span class="hljs-built_in">firstTimeout</span>());<br>    <span class="hljs-keyword">if</span> (currentTime &lt; nextAnrCheck) &#123; <br>        <span class="hljs-keyword">return</span> nextAnrCheck;          <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">onAnrLocked</span>(connection);<span class="hljs-comment">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;触发输入事件处理超时处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/blog_imgs/5_InputDispatcher/anrnofocusedwindow.png" alt="3481e9ce8cd1efb7fcef41576b756202.png"></p><p>(图片将杂项处理部分去掉了)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>InputDispatcher</code> 主要做的事情就是派发事件</li><li>检查派发的事件是否正常</li></ol><p>1.1 <strong>预处理</strong>，派发事件的过程中先对事件进行预处理，预处理需要找到关键事件派发的目标窗口等各项事情。对于 <code>key</code> 合 <code>motion</code> 事件需要找到焦点窗口，找窗口的过程中，进行计时 <code>mNoFocusedWindowTimeout</code> ，超时则触发anr。<br>1.2 <strong>最终派发事件</strong>，然后通过<code>connection</code>封装socketpair的一端， 将事件先放入<code>connection</code>中的 <code>outboundQueue</code> 中，等事件发送出去后(已经往fd中写入值后)，将 <code>outboundQueue</code> 中的事件取出来，放到 <code>waitQueue</code> 中代表事件还没有被消费完，其次将开始计时，计时时间放入<code>mAnrTracker</code> 集合中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>Input</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hung Task Detect机制介绍</title>
    <link href="/2024/04/17/7_Hung_Task_Detect/"/>
    <url>/2024/04/17/7_Hung_Task_Detect/</url>
    
    <content type="html"><![CDATA[<p><img src="/blog_imgs/7_Hung_Task_Detect/Image.png" alt="进程状态轮转"><br><linux_kernel_development></p><h2 id="1-Hung-Task-Detect机制"><a href="#1-Hung-Task-Detect机制" class="headerlink" title="1.Hung Task Detect机制"></a>1.Hung Task Detect机制</h2><p><code>kernel</code> 中 <code>hung task detect</code> 机制的核心目的就是为了检测那些处于 <code>D</code> 状态且长时间无法被调度运行的进程，如果存在这类进程则 <code>kernel</code>认为这些进程是异常的，会在<code>kernel</code> 日志中打印这些长时间<code>D</code>状态的进程堆栈信息，如果有必要则还可能触发<code>panic</code>。</p><h2 id="2-D-状态-TASK-UNINTERRUPTIBLE"><a href="#2-D-状态-TASK-UNINTERRUPTIBLE" class="headerlink" title="2. D 状态-TASK_UNINTERRUPTIBLE"></a>2. D 状态-TASK_UNINTERRUPTIBLE</h2><h3 id="2-1-问题：那么什么-是-D-状态的进程？D状态进程有什么特点？"><a href="#2-1-问题：那么什么-是-D-状态的进程？D状态进程有什么特点？" class="headerlink" title="2.1 问题：那么什么 是 D 状态的进程？D状态进程有什么特点？"></a>2.1 问题：那么什么 是 D 状态的进程？D状态进程有什么特点？</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                                    <span class="hljs-symbol">*</span><br>                                    |<span class="hljs-string"></span><br><span class="hljs-string">                                    </span>|<span class="hljs-string"> task</span><br><span class="hljs-string">                                    </span>|<span class="hljs-string"> forks</span><br><span class="hljs-string">                                    v</span><br><span class="hljs-string">                     +------------------------------+</span><br><span class="hljs-string">                     </span>|<span class="hljs-string">           TASK_NEW           </span>|<br>                     |<span class="hljs-string">        (Ready to run)        </span>|<br>                     +------------------------------+<br>                                    |<span class="hljs-string"></span><br><span class="hljs-string">                                    </span>|<br>                                    v<br>                  +------------------------------------+<br>                  |<span class="hljs-string">            TASK_RUNNING            </span>|<br>+---------------&gt; |<span class="hljs-string">           (Ready to run)           </span>|<span class="hljs-string"> &lt;--+</span><br><span class="hljs-string"></span>|<span class="hljs-string">                 +------------------------------------+    </span>|<br>|<span class="hljs-string">                   </span>|<span class="hljs-string">                                       </span>|<br>|<span class="hljs-string">                   </span>|<span class="hljs-string"> schedule() calls context_switch()     </span>|<span class="hljs-string"> task is preempted</span><br><span class="hljs-string"></span>|<span class="hljs-string">                   v                                       </span>|<br>|<span class="hljs-string">                 +------------------------------------+    </span>|<br>|<span class="hljs-string">                 </span>|<span class="hljs-string">            TASK_RUNNING            </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">                 </span>|<span class="hljs-string">             (Running)              </span>|<span class="hljs-string"> ---+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> event occurred  +------------------------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">                   </span>|<br>|<span class="hljs-string">                   </span>|<span class="hljs-string"> task needs to wait for event</span><br><span class="hljs-string"></span>|<span class="hljs-string">                   v</span><br><span class="hljs-string"></span>|<span class="hljs-string">                 +------------------------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">                 </span>|<span class="hljs-string">         TASK_INTERRUPTIBLE         </span>|<br>|<span class="hljs-string">                 </span>|<span class="hljs-string">        TASK_UNINTERRUPTIBLE        </span>|<br>+-----------------|<span class="hljs-string">           TASK_WAKEKILL            </span>|<br>                  +------------------------------------+<br>                                    |<span class="hljs-string"></span><br><span class="hljs-string">                                    </span>|<span class="hljs-string"> task exits via do_exit()</span><br><span class="hljs-string">                                    v</span><br><span class="hljs-string">                     +------------------------------+</span><br><span class="hljs-string">                     </span>|<span class="hljs-string">          TASK_DEAD           </span>|<br>                     |<span class="hljs-string">         EXIT_ZOMBIE          </span>|<br>                     +------------------------------+<br><br></code></pre></td></tr></table></figure><blockquote><p>从内核调度的角度来讲，进程的状态通常主要在运行和不运行（休眠）之间切换。休眠状态又可分为可中断休眠（TASK_INTERRUPTIBLE）和不可中断休眠（TASK_UNINTERRUPTIBLE）。<br>从字面意思上看，不可中断休眠（TASK_UNINTERRUPTIBLE） 这种状态下的进程似乎比可中断休眠（TASK_INTERRUPTIBLE）进程更为严格，毕竟不可被中断。确实是这样的，对于内核来说，使用 TASK_UNINTERRUPTIBLE 的条件比使用 TASK_INTERRUPTIBLE 更为严苛的，并且内核推荐少使用TASK_UNINTERRUPTIBLE。</p></blockquote><p><strong>特点</strong>：<br>1.<strong>是否可以被信号中断</strong>：<br><code>TASK_INTERRUPTIBLE</code>：进程在休眠等待期间可被信号打断<br><code>TASK_UNINTERRUPTIBLE</code>： 进程在休眠等待期间不能被信号打断<br>2.两者虽然都是休眠状态，但是为了进一步区别，他们的<strong>进程状态标识不一样</strong><br><code>TASK_INTERRUPTIBLE</code>：<strong>S</strong><br><code>TASK_UNINTERRUPTIBLE</code>：<strong>D</strong><br>3. <strong>唤醒源区别</strong>：<br><code>TASK_INTERRUPTIBLE</code>：两个唤醒源①：等待事件完成②：收到信号<br><code>TASK_UNINTERRUPTIBLE</code>：一个唤醒源①：等待事件完成</p><p>4.<strong>使用场景不同</strong><br><code>TASK_INTERRUPTIBLE</code>：强调：等一件相对没那么关键的事情<br>例如：</p><ul><li>用户输入</li><li>等socket数据</li><li>等普通锁</li><li>等调度资源</li><li>如果被中断，可重新来过重新处理</li></ul><p><code>TASK_UNINTERRUPTIBLE</code>：强调：等一件“必须完成，无法回滚”的事情<br>例如：</p><ul><li>磁盘I&#x2F;O已下发</li><li>文件系统元数据已经提交</li><li>块设备flush</li><li>某些硬件、驱动的响应</li><li>关键内核路径的资源释放</li><li>假如它是可以被中断的，可能导致内核状态不一致或者数据损害等严重问题</li><li>弊端：假如等待的事件一直无法完成，那么就会造成进程死等，可能影响到其他进程，进而可能造成系统卡死，影响系统稳定性。</li></ul><p>5.<strong>内核宏观角度来说着重点不同</strong>：<br><code>TASK_INTERRUPTIBLE</code>： 强调“可控性”-优点<br><code>TASK_UNINTERRUPTIBLE</code>：强调“一致性”-优点</p><h3 id="2-2-TASK-UNINTERRUPTIBLE-弊端"><a href="#2-2-TASK-UNINTERRUPTIBLE-弊端" class="headerlink" title="2.2 TASK_UNINTERRUPTIBLE 弊端"></a>2.2 TASK_UNINTERRUPTIBLE 弊端</h3><p>如上所述<code>TASK_UNINTERRUPTIBLE</code> 安全一致性好，可控性差。<br>弊端1：进程无法被杀死（由于不可被信号中断）<br>弊端2：如果等待的条件意外无法达成，一直死等拖垮系统，只能重启系统恢复<br>弊端3：调试定位困难，进程无法<code>attach</code>，只能通过堆栈等信息确认<br>弊端4：不占用<code>CPU</code>，但是会被统计进入<code> load average</code>（衡量：系统无法完成的工作量，D状态进程任务也被包含其中）中</p><p>针对弊端1，内核已经衍生出<code>TASK_KILLABLE</code>的进程状态，该状态的进程虽然是不可中断休眠，但是它收到 <code>fatal</code> 信号能够被杀。</p><h2 id="3-Hung-Task-Detect原理"><a href="#3-Hung-Task-Detect原理" class="headerlink" title="3. Hung Task Detect原理"></a>3. Hung Task Detect原理</h2><p><code>hung task detect 机制</code> 就是针对于弊端2和弊端3进行改善，对于长时间的 <code>TASK_UNINTERRUPTIBLE</code> 进程进行监控，打印堆栈日志，必要时重启系统。<br>由于一个进程可能短时间进入 <code>TASK_UNINTERRUPTIBLE</code> 状态，随后等待的事件完成了，进程退出 <code>TASK_UNINTERRUPTIBLE</code> 状态得以运行 <code>TASK_RUNNING</code>，但随后有需要进入 <code>TASK_UNINTERRUPTIBLE</code> 进行等待，进程在这种情况下通常来说是正常行为，我们需要监控的是长时间未被调度过的进程。</p><h3 id="3-1-监控原理："><a href="#3-1-监控原理：" class="headerlink" title="3.1 监控原理："></a>3.1 监控原理：</h3><p>是否存在超过120s都未发生过调度的 <code>TASK_UNINTERRUPTIBLE</code> 进程，如果存在，则打印出该进程堆栈信息，必要时重启系统。</p><h3 id="3-2-问题1：如何判断Task长时间未发生调度？"><a href="#3-2-问题1：如何判断Task长时间未发生调度？" class="headerlink" title="3.2 问题1：如何判断Task长时间未发生调度？"></a>3.2 问题1：如何判断Task长时间未发生调度？</h3><p>主要依据task结构中的两个值：nvcsw 和 nivcsw</p><ul><li><code>nvcsw</code>：n（Number of）v（Voluntary）c（Context）sw（Switch），<code>Number of Voluntary Context Switch</code>，自愿上下文切换次数</li><li><code>nivcsw</code>：n（Number of）iv（Involuntary）c（Context）sw（Switch），<code>Number of Involuntary Context Switch</code>，非自愿上下文切换次数</li></ul><p><code>nvcsw</code>： 主要统计的是因为自身原因<strong>主动放弃CPU</strong>的次数，场景：等待资源、主动调用sleep、等锁等<br><code>nivcsw</code>：主要统计的是因为外部原因<strong>被动放弃CPU</strong>的次数，场景：时间片用完、被高优先级进程抢占</p><p>当这两个值，任意一个值发生改变都代表进程的被调度过，无论是自愿或者非自愿。如果在长时间120s之外，进程的这两个值都没有发生过改变（增加），那么说明进程一直未能被调度。并且它还是 <code>D</code> 状态，我们认为这个进程可能存在异常。</p><h2 id="4-源码梳理"><a href="#4-源码梳理" class="headerlink" title="4. 源码梳理"></a>4. 源码梳理</h2><p>接下来我们对源码进行梳理</p><h3 id="4-1-hung-task-初始化"><a href="#4-1-hung-task-初始化" class="headerlink" title="4.1 hung_task 初始化"></a>4.1 hung_task 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel<span class="hljs-number">-6.6</span>/kernel/hung_task.c<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">hung_task_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// 注册panic通知链，作用：当系统正在panic时候。不应该出现hung task detect机制panic的干扰，以免影响之前的panic日志</span><br>atomic_notifier_chain_register(&amp;panic_notifier_list, &amp;panic_block);<br><br><span class="hljs-comment">// 注册PM管理通知链，作用：设备休眠期间，CPU停止运行，所有task均不会被调度，暂停hung_task监测，防止误报</span><br>pm_notifier(hungtask_pm_notify, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 创建并启动“hungtaskd”内核守护线程</span><br>watchdog_task = kthread_run(watchdog, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;khungtaskd&quot;</span>);<br><span class="hljs-comment">// 初始化hung_task相关Sysctl节点（proc/sys/kernel下）作用：通过设定节点值控制hung_task行为</span><br>hung_task_sysctl_init();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">watchdog</span><span class="hljs-params">(<span class="hljs-type">void</span> *dummy)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hung_last_checked = jiffies;<br>    <span class="hljs-comment">//设置线程nice值 0</span><br>set_user_nice(current, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//守护线程：死循环</span><br><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout = sysctl_hung_task_timeout_secs;<span class="hljs-comment">//120s</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> interval = sysctl_hung_task_check_interval_secs;<span class="hljs-comment">//0s</span><br><span class="hljs-type">long</span> t;<br><span class="hljs-keyword">if</span> (interval == <span class="hljs-number">0</span>)<br>interval = timeout;<br>interval = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, interval, timeout);<span class="hljs-comment">//120s</span><br>t = hung_timeout_jiffies(hung_last_checked, interval);<span class="hljs-comment">//计算休眠时间，小于0代表已经120s没有做hung检查了，需要要做hung 检查，</span><br><span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//reset_hung_task用于外部取消hung_task检测，hung_detector_suspended用于控制设备休眠，是否开启hung_task检测</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-type">atomic_xchg</span>(&amp;reset_hung_task, <span class="hljs-number">0</span>) &amp;&amp;<br>    !hung_detector_suspended)<br>check_hung_uninterruptible_tasks(timeout);<span class="hljs-comment">//检查</span><br>hung_last_checked = jiffies;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>schedule_timeout_interruptible(t);<span class="hljs-comment">//设置进程休眠（TASK_INTERRUPTIBLE）休眠时间t</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>初始化</strong>：</p><ul><li>注册<code>panic</code>通知链，作用：当系统正在<code>panic</code>时候。不应该有<code>hung task detect</code> 机制<code>panic</code>的干扰，以免影响之前 <code>panic</code> 日志信息。</li><li>注册<code>PM</code>管理通知链，作用：设备休眠期间，CPU停止运行，所有task均不会被调度，暂停<code>hung task detect </code>机制，防止误报。</li><li>创建并启动“<strong>hungtaskd</strong>”内核守护线程</li><li>初始化<code>hung task</code>相关<code>Sysctl</code>节点（<code>proc/sys/kernel</code>下）作用：通过设定节点值控制<code>hung task</code>行为。</li></ul><p><strong>守护线程-hungtaskd</strong>：</p><ul><li>线程<code>nice</code>为0</li><li>开启死循环每隔120s进行<code>hung task</code> 检测一次，其他时间休眠（<code>TASK_INTERRUPTIBLE</code>）</li><li>检测前提条件：没有外部模块取消<code>hung task</code> 检测 以及 设备未在休眠</li><li>进行检测-<code>check_hung_uninterruptible_tasks</code></li></ul><h3 id="4-2-遍历所有D状态Task-check-hung-uninterruptible-tasks"><a href="#4-2-遍历所有D状态Task-check-hung-uninterruptible-tasks" class="headerlink" title="4.2 遍历所有D状态Task-check_hung_uninterruptible_tasks"></a>4.2 遍历所有D状态Task-check_hung_uninterruptible_tasks</h3><p>在内核由于遍历所有<code>task</code>是一个比较耗时且比较危险的任务，造成系统阻塞。所以在遍历所有线程时候，要分时段进行遍历，所以下面的代码在遍历时候进行了一些<code>RCU</code>锁的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">//遍历系统所有进程，检查处于UNINTERRUPTIBLE 状态的task</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">check_hung_uninterruptible_tasks</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout)</span><br>&#123;<br><span class="hljs-type">int</span> max_count = sysctl_hung_task_check_count;<span class="hljs-comment">//4194304</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> last_break = jiffies;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">g</span>, *<span class="hljs-title">t</span>;</span><br><span class="hljs-type">bool</span> need_check = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the system crashed already then all bets are off,</span><br><span class="hljs-comment"> * do not report extra hung tasks:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (test_taint(TAINT_DIE) || did_panic)<br><span class="hljs-keyword">return</span>;<br><br>hung_task_show_lock = <span class="hljs-literal">false</span>;<br>rcu_read_lock();<br>for_each_process_thread(g, t) &#123;<span class="hljs-comment">//for_each_process_thread是双重循环，先遍历所有进程，所有进程中的所有线程</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-keyword">if</span> (!max_count--)<br><span class="hljs-keyword">goto</span> unlock;<br><span class="hljs-keyword">if</span> (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) &#123;<span class="hljs-comment">//检查是否处理太久</span><br><span class="hljs-keyword">if</span> (!rcu_lock_break(g, t))<span class="hljs-comment">//暂时释放RCU锁</span><br><span class="hljs-keyword">goto</span> unlock;<br>last_break = jiffies;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skip the TASK_KILLABLE tasks -- these can be killed</span><br><span class="hljs-comment"> * skip the TASK_IDLE tasks -- those are genuinely idle</span><br><span class="hljs-comment"> */</span><br>trace_android_vh_check_uninterruptible_tasks(t, timeout, &amp;need_check);<span class="hljs-comment">//hook点</span><br><span class="hljs-comment">//只检查 TASK_UNINTERRUPTIBLE 的task</span><br><span class="hljs-keyword">if</span> (need_check) &#123;<br>state = READ_ONCE(t-&gt;__state);<br><span class="hljs-keyword">if</span> ((state &amp; TASK_UNINTERRUPTIBLE) &amp;&amp;<br>    !(state &amp; TASK_WAKEKILL) &amp;&amp;<br>    !(state &amp; TASK_NOLOAD))<br>check_hung_task(t, timeout);<span class="hljs-comment">//检查</span><br>&#125;<br>&#125;<br>trace_android_vh_check_uninterruptible_tasks_dn(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//hook点</span><br> unlock:<br>rcu_read_unlock();<br><span class="hljs-comment">//是打印日志信息，是否重启系统</span><br><span class="hljs-keyword">if</span> (hung_task_show_lock)<br>debug_show_all_locks();<br><br><span class="hljs-keyword">if</span> (hung_task_show_all_bt) &#123;<br>hung_task_show_all_bt = <span class="hljs-literal">false</span>;<br>trigger_all_cpu_backtrace();<br>&#125;<br><br><span class="hljs-keyword">if</span> (hung_task_call_panic)<br>panic(<span class="hljs-string">&quot;hung_task: blocked tasks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>系统处于<code>panic</code>流程或者设备休眠过程中不做检查</li><li>只检查 <code>TASK_UNINTERRUPTIBLE</code> 状态的<code>task</code></li><li>检测前后有<code>hook</code>点</li><li><code>check_hung_task</code> 检测<code>task</code>是否长时间未发生调度 </li><li>日志打印或者<code>panic</code>重启系统</li></ul><h3 id="4-3-Task是否长时间未调度-check-hung-task"><a href="#4-3-Task是否长时间未调度-check-hung-task" class="headerlink" title="4.3 Task是否长时间未调度-check_hung_task"></a>4.3 Task是否长时间未调度-check_hung_task</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">check_hung_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *t, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> switch_count = t-&gt;nvcsw + t-&gt;nivcsw;<span class="hljs-comment">//统计自愿和非自愿放弃cpu的次数</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ensure the task is not frozen.</span><br><span class="hljs-comment"> * Also, skip vfork and any other user process that freezer should skip.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//跳过刚fork出来和被freezer的进程</span><br><span class="hljs-keyword">if</span> (unlikely(READ_ONCE(t-&gt;__state) &amp; TASK_FROZEN))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When a freshly created task is scheduled once, changes its state to</span><br><span class="hljs-comment"> * TASK_UNINTERRUPTIBLE without having ever been switched out once, it</span><br><span class="hljs-comment"> * musn&#x27;t be checked.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//刚创建出来没有被调度过的task跳过</span><br><span class="hljs-keyword">if</span> (unlikely(!switch_count))<br><span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//上次检查时的switch_count值是否等于这次检查的switch_count值，如果是则没有被调度过</span><br><span class="hljs-keyword">if</span> (switch_count != t-&gt;last_switch_count) &#123;<br>t-&gt;last_switch_count = switch_count;<br>t-&gt;last_switch_time = jiffies;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//未调度过的时间是否超过120s</span><br><span class="hljs-keyword">if</span> (time_is_after_jiffies(t-&gt;last_switch_time + timeout * HZ))<br><span class="hljs-keyword">return</span>;<br><br>trace_sched_process_hang(t);<br>    <span class="hljs-comment">//设置了panic，则打印日志信息，默认不打开</span><br><span class="hljs-keyword">if</span> (sysctl_hung_task_panic) &#123;<br>console_verbose();<br>hung_task_show_lock = <span class="hljs-literal">true</span>;<br>hung_task_call_panic = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ok, the task did not get scheduled for more than 2 minutes,</span><br><span class="hljs-comment"> * complain:</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//kernel log中打印该task的堆栈信息</span><br><span class="hljs-keyword">if</span> (sysctl_hung_task_warnings) &#123;<span class="hljs-comment">//默认十次</span><br><span class="hljs-keyword">if</span> (sysctl_hung_task_warnings &gt; <span class="hljs-number">0</span>)<br>sysctl_hung_task_warnings--;<br>pr_err(<span class="hljs-string">&quot;INFO: task %s:%d blocked for more than %ld seconds.\n&quot;</span>,<br>       t-&gt;comm, t-&gt;pid, (jiffies - t-&gt;last_switch_time) / HZ);<br>pr_err(<span class="hljs-string">&quot;      %s %s %.*s\n&quot;</span>,<br>print_tainted(), init_utsname()-&gt;release,<br>(<span class="hljs-type">int</span>)<span class="hljs-built_in">strcspn</span>(init_utsname()-&gt;version, <span class="hljs-string">&quot; &quot;</span>),<br>init_utsname()-&gt;version);<br>pr_err(<span class="hljs-string">&quot;\&quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs\&quot;&quot;</span><br><span class="hljs-string">&quot; disables this message.\n&quot;</span>);<br>sched_show_task(t);<br>hung_task_show_lock = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (sysctl_hung_task_all_cpu_backtrace)<br>hung_task_show_all_bt = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!sysctl_hung_task_warnings)<br>pr_info(<span class="hljs-string">&quot;Future hung task reports are suppressed, see sysctl kernel.hung_task_warnings\n&quot;</span>);<br>&#125;<br><br>touch_nmi_watchdog();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据<code>t-&gt;nvcsw + t-&gt;nivcsw</code> 的值来决定<code>task</code>是否被调度过，刚<code>fork</code>出来的<code>task</code>、从未被调度过的<code>task</code>、<code>freezer</code>的<code>task</code>以及未被调度时间没有超过<code>120s</code>的task将会被跳过</li><li><code>kernel log</code>打印该<code>task</code>的堆栈信息</li></ul><h3 id="4-4-一句话原理小结："><a href="#4-4-一句话原理小结：" class="headerlink" title="4.4 一句话原理小结："></a>4.4 一句话原理小结：</h3><p><code>hungtaskd</code> 进程每隔 <strong>120s</strong> (<code>hung_task_check_interval_secs</code>) 起来检测一次是否存在 <strong>120s</strong> (<code>hung_task_timeout_secs</code>)未被调度过的<code>D状态进程</code></p><ul><li>如果存在，那么根据 <code>hung_task_all_cpu_backtrace</code> 决定是否 <code>dump</code> 所有<code>cpu backtrace</code>到<code>kernel log</code>中、以及根据 <code>hung_task_panic</code> 决定是否触发 <code>panic</code>、以及将该<code>D状态进程backtrace</code>信息输出到<code>kernel log</code>中</li><li>检测完，休眠 <strong>120s</strong>。</li></ul><h2 id="5-hung-task-其他参数信息"><a href="#5-hung-task-其他参数信息" class="headerlink" title="5. hung_task 其他参数信息"></a>5. hung_task 其他参数信息</h2><h3 id="5-1-内核宏控"><a href="#5-1-内核宏控" class="headerlink" title="5.1 内核宏控"></a>5.1 内核宏控</h3><ul><li><strong>CONFIG_DETECT_HUNG_TASK</strong>：控制内核是否开启 <code>hung task</code> 检测机制，默认打开y</li><li><strong>CONFIG_DEFAULT_HUNG_TASK_TIMEOUT</strong>：默认超时时间<strong>120s</strong>，判断<code>tas</code>k多长时间未被调用</li><li><strong>CONFIG_BOOTPARAM_HUNG_TASK_PANIC</strong>：<code>hung task</code> 检测到异常则直接<code>panic</code>，默认不开</li></ul><p>可以使用<code>unzip</code>过滤内核宏控文件得到系统是否有开 <code>hung task</code> 相关宏</p><ul><li><code>gunzip -c /proc/config.gz|grep -Ei hung</code></li></ul><h3 id="5-2-内核节点信息"><a href="#5-2-内核节点信息" class="headerlink" title="5.2 内核节点信息"></a>5.2 内核节点信息</h3><p>如果有root权限的话可以通过修改节点值来控制 <code>hung task</code> 机制的行为<br>节点信息如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">/proc/sys/kernel $ ls |grep hung<br>hung_task_all_cpu_backtrace<br>hung_task_check_count<br>hung_task_check_interval_secs<br>hung_task_panic<br>hung_task_timeout_secs<br>hung_task_warnings<br></code></pre></td></tr></table></figure><ul><li><strong>hung_task_all_cpu_backtrace</strong> ：打印所有<code>CPU</code>的<code>backtrace</code>到<code>kernel log</code>中，默认<code>0</code>，不打印，1打印</li><li><strong>hung_task_check_count</strong>：检查task数量上限，默认值：<code>PID_MAX_LIMIT</code></li><li><strong>hung_task_check_interval_secs</strong>：<code>hung task</code>多久检查一次的时间（其实就是线程间隔多久检查一次的时间），默认值是上述宏控120s，检测时此值和宏控值比较，谁小使用谁</li><li><strong>hung_task_panic</strong>：<code>hung task</code> 检测到异常是否panic，默认值为 <code>CONFIG_BOOTPARAM_HUNG_TASK_PANIC</code> ，<code>1</code>则触发 <code>panic</code>，<code>0</code>则不触发 panic</li><li><strong>hung_task_timeout_secs</strong>：可修改的超时时长（判断<code>D状态进程</code>多久未被调度），默认值是 <code>CONFIG_DEFAULT_HUNG_TASK_TIMEOUT</code></li><li><strong>hung_task_warnings</strong>：在hung task检测期间，如果有长时间未被调度的<code>D状态task</code>，则会在 <code>kernel log</code> 打印对于 <code>task</code> 的 <code>backtrace</code> 信息，该值代表检测期间，能打印 <code>backtrace</code> 的次数，默认<code>10</code>次</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul><li><code>Hung task</code> : 长时间未被调度的 不可中断休眠 进程。</li><li><code>Detect</code>：每隔120s 检查一次是否存在这样的<code>Hung task</code>，存在则输出日志，必要时则重启恢复。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>Hung</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>Hung</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hung-各平台Hung机制介绍</title>
    <link href="/2024/03/18/4_Hung-%E5%90%84%E5%B9%B3%E5%8F%B0Hung%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/03/18/4_Hung-%E5%90%84%E5%B9%B3%E5%8F%B0Hung%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一-概念原理"><a href="#一-概念原理" class="headerlink" title="一. 概念原理:"></a>一. 概念原理:</h2><p>在手机系统运行过程中，由于系统代码逻辑上的缺陷，使用过程中和开发测试过程中都会出现手机卡死无法恢复的现象。这类问题只要出现，对于使用者来说是不可接受的，对于手机研发阶段而言，此类问题是很严重，将会定级为阻塞问题。</p><p>Android系统使用的是<code>Linux内核</code>，对于内核层面为了防止这类问题发生，设计了<code>Linux kernel</code>的<code>Hung_task</code>机制，用来监测内核态卡死的各个进程，当出现内核进程卡死将会在<code>kernel log</code>打印出日志，并且对手机进行整机重启，防止长时间卡死。对于用户态层面，<code>Google</code>原生代码System_server中设计了<code>Watchdog</code>机制，当系统进程中各个关键线程存在异常，有可能导致用户使用过程中出现卡死现象时，对于手机进行上层重启。防止长时间卡死，影响用户体验。</p><p>对于原生的机制来说，能够解决大部分的手机卡死问题，但是并不能覆盖所有场景。为此各个平台厂商（通常指手机芯片厂商）均会在原生的监测机制上进行加强。例如：</p><ul><li>高通平台在原生的<code>Hung_task</code> 机制上进行了加强,构建”<strong>hung_task_enh</strong>“机制（遍历所有task,监测特定<code>Task</code>状态是否异常）</li><li>展锐平台在<code>Watchdog</code>机制基础上进行扩充开发”<strong>Native_Hang</strong>“机制（根据场景监测特定<code>Task</code>状态是否异常）</li><li>MTK平台在<code>Watchdog</code>机制基础上添加了”<strong>Hang_detect</strong>“模块（根据场景监测特定<code>Task</code>状态是否异常）</li></ul><p>各个厂商加强后的平台代码能很大程度的解决长时间卡死不能恢复的问题。<br>加强的意义：将原生未监测到的场景进行弥补完善<br>下面将会介绍各个平台增强机制的大概原理.</p><blockquote><p>这里需要再次强调一下所有的稳定性问题都存在一个机制，以及所有稳定性相关事情都围绕着两个方面，一：问题监测，二：收集日志和尽可能让机器恢复正常</p></blockquote><h3 id="1-MTK-hang-detect"><a href="#1-MTK-hang-detect" class="headerlink" title="1. MTK hang_detect"></a>1. MTK hang_detect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">config MTK_HANG_DETECT<br>        tristate <span class="hljs-string">&quot;hang detect monitor&quot;</span><br>        help<br>          MTK_HANG_DETECT is the kernel config of hang feature designed by MTK,<br>          which is a debug feature <span class="hljs-keyword">for</span> detecting device hang. When the device<br>          hang is detected by this mechanism, it will notice get some<br>          debug information.<br></code></pre></td></tr></table></figure><h4 id="1-1-MTK-Hang-Detect实现原理"><a href="#1-1-MTK-Hang-Detect实现原理" class="headerlink" title="1.1 MTK Hang_Detect实现原理"></a>1.1 MTK Hang_Detect实现原理</h4><p>MTK平台的<code>Hang_Detect机制</code>是根据特定的场景监测特定进程状态是否异常来实现。<br>具体实现笼统来讲：</p><ol><li>系统启动内核模块加载注册杂项设备<code>RT_Monitor</code>,提供用户进程(<code>system_server</code>等)访问.</li><li>开启一个线程：<code>hang_detect</code>，循环进行倒数，倒数的计数值(<code>counter</code>)不能小于0，小于0代表系统出现问题了，监控的<strong>特定进程</strong>每隔一段时间给<code>hang_detect</code>线程设置一个大于0的<code>counter </code>倒数值。当<strong>特定进程</strong>不能及时给<code>hang_detect线程</code>设置值时，其实代表特定进程已经出问题了，通常来说是内核态异常。<strong>注</strong>:<code>counter值</code>的设定和场景有关系</li><li><code>hang_detect</code>线程监控工作:<br> 3.1 线程中开启一个循环,每隔<code>30s</code>循环一次<br> 3.2 当counter计数值&gt;0时,循环一次<code>counter值</code>-1<br> 3.3 当counter计数值&#x3D;0时,代表系统特定进程应该发生了异常了(<strong>特定进程</strong>没有更新新的<code>counter值</code>).进行信息dump<br> 3.4 当counter计数值&#x3D;-1时,代表系统已经卡死很久了,进行信息dump并触发panic收集完整日志，并整机重启恢复.</li></ol><p>dump信息:</p><ul><li>内存信息</li><li>task 堆栈信息</li><li>dump出的信息存在<code>db</code>(MTK客制化log文件)中</li></ul><h4 id="1-2-监测场景"><a href="#1-2-监测场景" class="headerlink" title="1.2 监测场景"></a>1.2 监测场景</h4><table><thead><tr><th>场景</th><th>counter值</th><th>时间值</th></tr></thead><tbody><tr><td>watchdog正常运行</td><td>10</td><td>300s</td></tr><tr><td>watchdog 检测到hang 30s, 在dump backtrace 前</td><td>12</td><td>360s</td></tr><tr><td>watchdog 检测到hang 60s,进行收尾工作</td><td>14</td><td>420s</td></tr><tr><td>SWT发生后,AEE抓取完日志,准备进行上层重启</td><td>11</td><td>320s</td></tr><tr><td>在 Surfaceflinger&#x2F;SystemServer 发生Native Exception</td><td>20</td><td>600s</td></tr><tr><td>在 Surfaceflinger&#x2F;SystemServer 发生Native Exception后， 并且AEE开始抓取coredump</td><td>20</td><td>1200s</td></tr><tr><td>在 Surfaceflinger&#x2F;SystemServer 发生Native Exception， 并且AEE抓取完coredump后</td><td>19</td><td>570s</td></tr><tr><td>关机场景</td><td>5</td><td>150s</td></tr><tr><td>开机场景(新kernel有实现6.1之后)</td><td>9</td><td>270s</td></tr></tbody></table><h4 id="1-3-临时关闭hang机制的方法"><a href="#1-3-临时关闭hang机制的方法" class="headerlink" title="1.3 临时关闭hang机制的方法"></a>1.3 临时关闭hang机制的方法</h4><p>每3s执行一次<br>开两个adb shell，先进去<br>watch -n3 setprop init.svc.zygote stopped<br>另外一个adb shell<br>dmesg -w|grep –color -iE “hang_detect”<br>一直有打hang_detect: disable by stop cmd<br>hang就是关着的状态</p><h3 id="2-展锐-native-hang"><a href="#2-展锐-native-hang" class="headerlink" title="2. 展锐 native_hang"></a>2. 展锐 native_hang</h3><p>展锐<code>native_hang</code> 机制实现上和MTK的<code>hang_detect</code>功能实现上大致相同.通过上层需要监控的进程主动<code>kick</code>kernel守护线程实现.在实现细节上有些许差异.后面会对比差异点.<br>展锐平台在<code>system_server</code>客制化较多,新增了<code>UnisocWatchdog</code>模块,该模块用来监测<code>system_server</code>原生<code>watchdog</code>,并负责和<code>kernel 守护进程</code>交互.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">config SPRD_NATIVE_HANG_MONITOR<br>     <span class="hljs-type">bool</span> <span class="hljs-string">&quot;Enable SPRD android native hang detect handler&quot;</span><br>     help<br>             This option enables Spreatrum android native hang detect which prepare debug info<br>             <span class="hljs-keyword">for</span> the <span class="hljs-keyword">case</span> to debug.<br></code></pre></td></tr></table></figure><h4 id="2-1-实现原理"><a href="#2-1-实现原理" class="headerlink" title="2.1 实现原理"></a>2.1 实现原理</h4><p>Linux内核中构造 <code>unisoc native hang monitor</code> 模块</p><ol><li>注册一个杂项设备:<code>/dev/native_hang_monitor</code> 让用户态进程(<code>systme_server</code>)可以和<code>kernel设备</code>进行数据交互</li><li>创建一个模块开关:<code>/proc/monitor_enable</code>, 用户空间的进程可以通过次开关写值,来开启或者关闭该模块功能,当开机时候通过一个<strong>客制化的native 服务</strong>:<code>nhMonitorService</code>开启该功能<br> 2.1 当服务写入<strong>on</strong>时候, 模块会开启一个<code>native_hang_detect</code>线程, 开始他的监控工作,传入<strong>off</strong>时候则线程停止运行</li><li><code>native_hang_detect</code>线程的监控工作:<br> 3.1 在<code>native_hang_detect</code>线程中开启一个循环,每隔1s循环一次<br> 3.2 当出现<code>counter计数值</code>&gt;0情况,休眠1s循环1次,每次循环<code>counter值</code>1s减1(<strong>counter值由system_server来维护</strong>)<br> 3.3 当出现<code>counter计数值</code>&lt;0时说明有卡住的情况,等待40s,是否还能恢复,如果无法恢复那么进行信息保存,触发<code>panic</code>.信息输出到<code>dump文件</code>中</li></ol><h4 id="2-2-输出信息"><a href="#2-2-输出信息" class="headerlink" title="2.2 输出信息"></a>2.2 输出信息</h4><ol><li><code>dump</code>出关键进程的堆栈信息<br> 1.1 <code>init</code><br> 1.2 <code>surfaceflinger</code><br> 1.3 <code>debuggerd</code><br> 1.4 <code>debuggerd64</code><br> 1.5 <code>system_server</code><br> 1.6 <code>systemui</code><br> 1.7 <code>mediaserver</code><br> 1.7 <code>mmcqd/0</code><br> 1.9 <code>mmcqd/1</code></li><li><code>dump</code>出所有进程中处于D状态的task堆栈信息</li><li><code>dump</code>出各个task持锁信息</li><li><code>dump</code>出内存区域信息(<code>/proc/zoneinfo</code>)</li><li><code>dump</code>的信息存储到<code>minidump</code>文件中</li></ol><h4 id="2-3-监控场景"><a href="#2-3-监控场景" class="headerlink" title="2.3 监控场景"></a>2.3 监控场景</h4><table><thead><tr><th>场景</th><th>counter值</th></tr></thead><tbody><tr><td>开机启动(注:<code>init进程</code>处理rc后开始计时)</td><td>默认<strong>120s</strong></td></tr><tr><td>关机广播</td><td>3×60s&#x3D;<strong>180s</strong></td></tr><tr><td>watchdog 正常运行阶段</td><td>20+30&#x3D;<strong>50s</strong></td></tr><tr><td>watchdog WAITED_HALF阶段</td><td>2*(20s+30s)&#x3D;<strong>100s</strong></td></tr><tr><td>watchdog OVERDUE阶段</td><td>展锐平台客制化selfkill system_server之前需要抓取bugreport(开始抓bugreport: 5×60s&#x3D;300s):5×60s&#x3D;<strong>300s</strong></td></tr><tr><td>SF相关的场景</td><td>没实现完</td></tr></tbody></table><h3 id="3-高通hung-task加强-QCOM-Hung-Task-Enhancement"><a href="#3-高通hung-task加强-QCOM-Hung-Task-Enhancement" class="headerlink" title="3. 高通hung_task加强(QCOM Hung Task Enhancement)"></a>3. 高通hung_task加强(QCOM Hung Task Enhancement)</h3><p>高通平台的加强<code>hung_task_enh</code>机制在原生<code>hung_task</code>的基础上做扩充和加强.<br>加强点:</p><ol><li>针对有关键<code>task</code>长期处于<code>io阻塞状态</code>做监测,当出现这种<strong>task长时间io阻塞情况</strong>,我们触发<code>panic</code>恢复系统.</li><li>原生<code>hung_task</code>机制只监测特定的<code>task</code>,非所有<code>task</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">config QCOM_HUNG_TASK_ENH<br>tristate <span class="hljs-string">&quot;QTI Hung Task Enhancement&quot;</span><br>depends on ARCH_QCOM<br>help<br>  Add options at sysfs to enhance khungtask, allow user to<br>  select and monitor tasks in black/white <span class="hljs-built_in">list</span> mode. Also<br>  processes in iowait <span class="hljs-keyword">for</span> specific situation will be monitored<br>  to avoid devices <span class="hljs-type">long</span> time no response.<br></code></pre></td></tr></table></figure><h4 id="3-1-hung-task实现原理"><a href="#3-1-hung-task实现原理" class="headerlink" title="3.1 hung_task实现原理"></a>3.1 hung_task实现原理</h4><p>由于高通<code>hung_task_enh</code> 功能是实现在原生<code>hung_task</code>基础上的,所有有必要先了解清楚<code>hung_task机制</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">config DETECT_HUNG_TASK<br><span class="hljs-type">bool</span> <span class="hljs-string">&quot;Detect Hung Tasks&quot;</span><br>depends on DEBUG_KERNEL<br><span class="hljs-keyword">default</span> SOFTLOCKUP_DETECTOR<br>help<br>  Say Y here to enable the kernel to detect <span class="hljs-string">&quot;hung tasks&quot;</span>,<br>  which are bugs that cause the task to be stuck in<br>  uninterruptible <span class="hljs-string">&quot;D&quot;</span> state indefinitely.<br><br>  When a hung task is detected, the kernel will print the<br>  current <span class="hljs-built_in">stack</span> <span class="hljs-title function_">trace</span> <span class="hljs-params">(which you should report)</span>, but the<br>  task will stay in uninterruptible state. If lockdep is<br>  enabled then all held locks will also be reported. This<br>  feature has negligible overhead.<br></code></pre></td></tr></table></figure><p>内核启动加载<code>hung_task</code>模块,启动<code>khungtaskd线程</code>用于监控工作.<strong>监控工作</strong>执行有两个前提</p><ol><li>发生<code>panic</code> 不进行<code>hung_task</code>监控检测</li><li>系统进入<strong>休眠期间</strong> 不进行<code>hung_task</code>监控检测</li></ol><p>监测检查工作:<strong>每隔120s遍历一遍所有task(所有进程,所有线程,对应函数:<code>check_hung_uninterruptible_tasks</code>)做check_hung_task检查工作</strong></p><p><strong>check_hung_task检查工作</strong></p><ol><li><strong>被冻结的task</strong>,不做检查</li><li><strong>新创建的task</strong>(还从未被调度过),不做检查</li><li><strong>调度过的task</strong>(上下文切换次数不等于上次记录的切换次数,上下文切换次数&#x3D;<code>t-&gt;nvcsw + t-&gt;nivcsw</code>),不做检查</li><li><strong>未被调度过,时间少于120s的task</strong>,则不做检查</li><li>如果以上条件都不满足,则认为<strong>task已经卡死了</strong>(task超过2分钟没有被调度),打印信息并<strong>重启系统</strong><br>  5.1 打印: <code>INFO: task %s:%d blocked for more than %ld seconds</code> 信息+堆栈+cpu堆栈信息<br>  5.2 如果配置了触发<code>panic</code>,则可以触发<code>panic</code></li></ol><h4 id="3-2-高通QCOM-Hung-Task-Enhancement-实现原理"><a href="#3-2-高通QCOM-Hung-Task-Enhancement-实现原理" class="headerlink" title="3.2 高通QCOM Hung Task Enhancement 实现原理"></a>3.2 高通QCOM Hung Task Enhancement 实现原理</h4><p><strong>背景</strong><br>原生<code>hung_task</code>原理如上,但是我们在分析hang问题时候,往往会遇到其他的情况.例如:</p><ol><li>有的重要进程在做大量<code>io操作</code>,<code>task</code>长时间等io,这种情况下,对应用户来说也是长时间卡死.造成不好的用户体验.</li><li>原生<code>hung_task</code>机制检测的时所有的<code>task</code>,这适用于<code>kernel内核</code>,对于<code>Android</code>系统来说,我们并不需要检测所有<code>task</code>,我只需监测我们想监测的<code>task</code>即可,例如<code>SurfaceFlinger/system_server</code>等<br>原生<code>hung_task</code>机制能满足一部分要求但无法全部满足上面的这些客制化的需求.所以,高通平台针对这种场景在原生<code>hung_task</code>基础进行了加强.</li></ol><p><strong>加强点</strong></p><ol><li><strong>监测我想要监测task</strong>.</li><li><strong>最后把IOwait这种情况也监测上去</strong>.<br>由于<code>GKI</code>的要求,厂商不能轻易修改通用内核中的<code>hung_task</code>代码.高通平台选择对<code>hung_task</code>代码就行<strong>hook</strong>.对<code>check_hung_uninterruptible_tasks</code>中的两个函数进行<code>hook</code></li><li><code>android_vh_check_uninterruptible_tasks</code>函数——–hook函数:<code>qcom_before_check_tasks</code></li><li><code>android_vh_check_uninterruptible_tasks_dn</code>函数——–hook函数:<code>qcom_check_tasks_done</code><br>两个函数进行hook.来实现此功能.</li></ol><p><code>check_hung_uninterruptible_tasks</code>实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check whether a TASK_UNINTERRUPTIBLE does not get woken up for</span><br><span class="hljs-comment"> * a really long time (120 seconds). If that happens, print out</span><br><span class="hljs-comment"> * a warning.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">check_hung_uninterruptible_tasks</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout)</span><br>&#123;<br>    <span class="hljs-comment">//....</span><br><span class="hljs-type">bool</span> need_check = <span class="hljs-literal">true</span>;<br>for_each_process_thread(g, t) &#123;<span class="hljs-comment">//遍历所有task</span><br><span class="hljs-comment">//...</span><br>trace_android_vh_check_uninterruptible_tasks(t, timeout, &amp;need_check);<span class="hljs-comment">//&lt;&lt;&lt;&lt;######这里qcom平台进行hook,统计处于iowait的task数量</span><br><span class="hljs-keyword">if</span> (need_check)<br><span class="hljs-comment">/* use &quot;==&quot; to skip the TASK_KILLABLE tasks waiting on NFS */</span><br><span class="hljs-keyword">if</span> (READ_ONCE(t-&gt;__state) == TASK_UNINTERRUPTIBLE)<br>check_hung_task(t, timeout);<span class="hljs-comment">//进行检查,传入task以及时间值(120s)</span><br>&#125;<br>trace_android_vh_check_uninterruptible_tasks_dn(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//&lt;&lt;&lt;&lt;######这里qcom平台进行hook,iowait数量&gt;5 触发panic</span><br> unlock:<br>    <span class="hljs-comment">//...打印信息,重启系统</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历每一个<code>task</code>时,让高通平台<code>hook的代码</code>能做个<code>预处理</code>来实现两个<strong>加强点</strong>.<br>对于高通<code>hook</code>的代码如何实现两个加强点,先用两个问题来引出</p><ol><li><p>由于hung_task中遍历所有的task,如何区分出哪些task是我们想要监测的task?</p><blockquote><p>只需要在task中添加一个标志就行,高通在task中添加了一个标志位<code>hung_detect_status</code>,该标志由用户进程来触发设定,识别到此标志的<code>task</code>让<code>hung_task</code>进一步检测是否卡死.</p></blockquote></li><li><p>对于<code>iowait异常</code>情况,<code>hung_task</code>无法监测,应该如何确定是<code>iowait耗时</code>异常?<br>  2.1 task要处于iowait状态<br>  2.2 task的线程状态处于{<code>TASK_UNINTERRUPTIBLE,TASK_STOPPED,TASK_TRACED</code>}<br>  2.3 task不是才刚被创建出来<br>  2.4 task已经超过120s没有被调度过<br>  2.5 task是主线程并且mm!&#x3D;NULL(用户虚拟地址空间不能为null即:task不能是内核线程)<br>  对于以上状态的<code>task</code>超过<strong>5个</strong>,则触发panic,重启系统</p></li></ol><p>3.如何标记<code>task</code>的<code>hung_detect_status</code>,如何开启高通<code>hung_task_enh</code>功能?<br>该块内容猜测可能由高通 <code>qguard服务</code>来控制(<code>qguard.bin</code>源码无法看到)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//from: XX/qguard.json</span><br>------<br><span class="hljs-string">&quot;black_white_list&quot;</span>: &#123;<br><span class="hljs-string">&quot;enable&quot;</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-string">&quot;mode&quot;</span>: <span class="hljs-string">&quot;white&quot;</span>,<br><span class="hljs-string">&quot;max_iowait_timeout_cnt&quot;</span>: <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;max_iowait_task_cnt&quot;</span>: <span class="hljs-number">5</span>,<br><span class="hljs-string">&quot;list&quot;</span>: []<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="4-机制总结"><a href="#4-机制总结" class="headerlink" title="4. 机制总结"></a>4. 机制总结</h3><p>三种机制各有特点,MTK监测场景较全,展锐平台上层实现模块较为丰富和灵活,高通平台代码实现依靠原生,实现了IO场景异常监测.</p><ul><li>√:支持</li><li>×:不支持</li><li>-:未知</li></ul><table><thead><tr><th>平台</th><th>开机场景</th><th>关机场景</th><th>SWT场景</th><th>SF 场景</th><th>IOwait场景</th><th>是否能从监测log中看到事发场景</th><th>实现代码量</th></tr></thead><tbody><tr><td>MTK</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>√</td><td>极大</td></tr><tr><td>展锐</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td><td>√</td><td>大</td></tr><tr><td>高通</td><td>-</td><td>-</td><td>-</td><td>-</td><td>√</td><td>×</td><td>中等</td></tr></tbody></table><h2 id="二-案例"><a href="#二-案例" class="headerlink" title="二. 案例"></a>二. 案例</h2><p>(案例均涉及敏感信息，无法一一展示，)</p>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>Hung</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>Hung</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANR-Have no focused Window</title>
    <link href="/2022/11/25/6_ANR_Application_does_not_have_a_focused_window/"/>
    <url>/2022/11/25/6_ANR_Application_does_not_have_a_focused_window/</url>
    
    <content type="html"><![CDATA[<p>[!top]<br>Android 13</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近项目在首轮Monkey测试中，频繁报了很多”无焦点窗口”的ANR.</p><p>鉴于之前也看过Android 的Input模块，于是想重新在梳理一下该种类型应用无响应的原理，以便后面分析问题能更快精准定位.</p><p>该种ANR主要表现为:<br><code>am_anr  : [用户id,进程号,包名,flag,ANR原因]</code></p><p>原因为：<br><code>Input dispatching timed out (Application does not have a focused window)</code><br>主要强调：<strong>分发输入事件过程中，应用没有一个有焦点的窗口</strong></p><p>另外还有一种ANR原因为：<br><code>Input dispatching timed out (ce4ddfb com.android.chrome/org.chromium.chrome.browser.firstrun.FirstRunActivity (server) is not responding. Waited 8000ms for KeyEvent)</code><br>主要强调：<br><strong>分发输入事件给应用进程，应用进程在规定的时间内，没有将此输入事件处理完</strong>.</p><h3 id="ANR一"><a href="#ANR一" class="headerlink" title="ANR一"></a>ANR一</h3><p>我们首先将梳理第一种原因的ANR.</p><p>我们要知道，ANR的触发流程都在系统进程 <code>system_server</code> 进程中的 <code>InputManagerService</code> 服务中.</p><p>在 <code>InputManagerService</code> 服务中，两个 <code>Native</code> 线程比较关键：</p><ul><li><strong>InputReader</strong>–事件的读取</li><li><strong>InputDispatcher</strong>–事件的分发</li></ul><p><code>ANR</code>的触发机制在 <code>InputDispatcher</code> 线程中，输入事件通过 <code>InputReader</code> 线程上报上来，就会触发到 <code>InputDispatcher</code> 线程中 <code>InputDispatcher.cpp</code> 的  <code>dispatchOnce()</code> 中，我们从此开始分析.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputDispatcher.cpp</span><br><span class="hljs-keyword">void</span> InputDispatcher::dispatchOnce() &#123;<br>    <span class="hljs-type">nsecs_t</span> <span class="hljs-variable">nextWakeupTime</span> <span class="hljs-operator">=</span> LONG_LONG_MAX;<br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        std::scoped_lock <span class="hljs-title function_">_l</span><span class="hljs-params">(mLock)</span>;<br>        mDispatcherIsAlive.notify_all();<br><br>        <span class="hljs-comment">/*mCommandQueue为一个命令队列即:该线程在其他地方只要想执行一个操作,</span><br><span class="hljs-comment">        就可以通过postCommandLocked(),往里面插入，在InputDispater线程中在循环中，</span><br><span class="hljs-comment">        实施监控着里面是否command需要处理</span><br><span class="hljs-comment">        判断mCommandQueue是否为空</span><br><span class="hljs-comment">        mCommandQueue是通过postCommandLocked()添加元素</span><br><span class="hljs-comment">        postCommandLocked()在多处地方调用，</span><br><span class="hljs-comment">        总结来说就是有事件触发时mCommandQueue不会为空*/</span><br>        <span class="hljs-keyword">if</span> (!haveCommandsLocked()) &#123;<br>            dispatchOnceInnerLocked(&amp;nextWakeupTime);<br>        &#125;<br><br>        <span class="hljs-comment">// 运行pending Command</span><br>        <span class="hljs-comment">// 运行后，下一次立刻唤醒</span><br>        <span class="hljs-keyword">if</span> (runCommandsLockedInterruptible()) &#123;<br>            nextWakeupTime = LONG_LONG_MIN;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查ANR</span><br>        <span class="hljs-comment">// 下一次唤醒时间为唤醒时间和ANR检查时间的最小值</span><br>        const <span class="hljs-type">nsecs_t</span> <span class="hljs-variable">nextAnrCheck</span> <span class="hljs-operator">=</span> processAnrsLocked();<span class="hljs-comment">//&lt;&lt;&lt;&lt;进入这里</span><br>        nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck);<br><br>        <span class="hljs-comment">//如果没有要处理的Command或者pending或者正在排队处理的Input事件,</span><br>        <span class="hljs-comment">//那么InputDispatcher线程将休眠</span><br>        <span class="hljs-keyword">if</span> (nextWakeupTime == LONG_LONG_MAX) &#123;<br>            mDispatcherEnteredIdle.notify_all();<br>        &#125;<br>    &#125; <span class="hljs-comment">// release lock</span><br><br>    <span class="hljs-comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span><br>    <span class="hljs-type">nsecs_t</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> now();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">timeoutMillis</span> <span class="hljs-operator">=</span> toMillisecondTimeoutDelay(currentTime, nextWakeupTime);<br>    mLooper-&gt;pollOnce(timeoutMillis);<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>先通过 <code>haveCommandsLocked()</code> 判断 <code>mCommandQueue</code> 是否不为空，则进入<br><code>dispatchOnceInnerLocked(&amp;nextWakeupTime)</code> 处理事件派发或者 <code>command</code> 事务。</li><li>其次就是 <code>runCommandsLockedInterruptible</code> 处理 <code>pending Command</code> 事务</li><li>通过 <code>processAnrsLocked</code> 检查是否有ANR发生。</li><li>判断下一次唤醒的时间 是否 <code>c == LONG_LONG_MAX</code><br> 这个 <code>nextWakeupTime</code> 是否等于<code>LONG_LONG_MAX</code>和<code>AnrTracker</code>中的 <code>mAnrTimeouts</code>集合，集合为空即会返回<code>LONG_LONG_MAX</code>，注:这个<code>AnrTracker</code>是用来追踪每个 <code>connection</code> 进入ANR的时间，以便能快速找到，更快导致ANR的<code>connections</code></li></ol><h3 id="事件的分发-dispatchOnceInnerLocked"><a href="#事件的分发-dispatchOnceInnerLocked" class="headerlink" title="事件的分发 dispatchOnceInnerLocked"></a>事件的分发 dispatchOnceInnerLocked</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;<br>    <span class="hljs-type">nsecs_t</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> now();<span class="hljs-comment">//ANR 计算的起点时间&lt;&lt;&lt;&lt; 1</span><br><br>    <span class="hljs-comment">//..</span><br><br>   <span class="hljs-comment">//..</span><br>    <span class="hljs-comment">//mPendingEvent默认为空，会从mInboundQueue中获取到值</span><br>    <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>        <span class="hljs-comment">// mInboundQueue是通过enqueueInboundEventLocked()赋值，所以有事件的时候mInboundQueue不为空</span><br>        <span class="hljs-comment">// notifyConfigurationChanged() -&gt; enqueueInboundEventLocked()</span><br>        <span class="hljs-comment">// notifyKey() -&gt; enqueueInboundEventLocked()</span><br>        <span class="hljs-comment">// notifyMotion() -&gt; enqueueInboundEventLocked()</span><br>        <span class="hljs-comment">// notifyDeviceReset() -&gt; enqueueInboundEventLocked()</span><br>        <span class="hljs-comment">// injectInputEvent() -&gt; enqueueInboundEventLocked()</span><br>        <span class="hljs-comment">// setInputWindowsLocked() -&gt; enqueueFocusEventLocked()</span><br>        <span class="hljs-keyword">if</span> (mInboundQueue.empty()) &#123;<br>            <span class="hljs-keyword">if</span> (isAppSwitchDue) &#123;<br>                <span class="hljs-comment">// The inbound queue is empty so the app switch key we were waiting</span><br>                <span class="hljs-comment">// for will never arrive.  Stop waiting for it.</span><br>                <span class="hljs-comment">//入站队列为空，因此我们等待的应用进程切换key永远不会到达。 别再等了</span><br>                resetPendingAppSwitchLocked(<span class="hljs-literal">false</span>);<br>                isAppSwitchDue = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>           <span class="hljs-comment">//...repeat相关</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//&lt;&lt;&lt;&lt; 2</span><br>            <span class="hljs-comment">// Inbound queue has at least one entry.</span><br>            <span class="hljs-comment">//取出一个事件</span><br>            mPendingEvent = mInboundQueue.front();<br>            mInboundQueue.pop_front();<br>            traceInboundQueueLengthLocked();<br>        &#125;<br><br>        <span class="hljs-comment">// Poke user activity for this event.</span><br>        <span class="hljs-comment">//该 event是否该传给应用程序</span><br>        <span class="hljs-keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;<br>            pokeUserActivityLocked(*mPendingEvent);<span class="hljs-comment">//&lt;&lt;&lt;&lt; 3</span><br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//..</span><br>    <span class="hljs-comment">//根据PendingEvent-&gt;type 不同的类型区处理不同的事件</span><br>    <span class="hljs-keyword">switch</span> (mPendingEvent-&gt;type) &#123;<span class="hljs-comment">//&lt;&lt;&lt;&lt; 4</span><br>        <span class="hljs-comment">//..</span><br>        <span class="hljs-comment">//case:....</span><br>        <span class="hljs-comment">//来源：notifyKey() -&gt; new KeyEntry()</span><br>        <span class="hljs-keyword">case</span> EventEntry::Type::KEY: &#123;<br>            std::shared_ptr&lt;KeyEntry&gt; keyEntry = std::static_pointer_cast&lt;KeyEntry&gt;(mPendingEvent);<br>            <span class="hljs-comment">//....设置dropReason相关</span><br>            <br>            done = dispatchKeyLocked(currentTime, keyEntry, &amp;dropReason, nextWakeupTime);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">case</span> EventEntry::Type::MOTION: &#123;<br>            <span class="hljs-comment">//....设置dropReason相关</span><br>            <br>            done = dispatchMotionLocked(currentTime, motionEntry, &amp;dropReason, nextWakeupTime);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>      <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (done) &#123;<span class="hljs-comment">//&lt;&lt;&lt;&lt; 5</span><br>        <span class="hljs-keyword">if</span> (dropReason != DropReason::NOT_DROPPED) &#123;<br>            dropInboundEventLocked(*mPendingEvent, dropReason);<br>        &#125;<br>        mLastDropReason = dropReason;<br><br>        releasePendingEventLocked();<br>        *nextWakeupTime = LONG_LONG_MIN; <span class="hljs-comment">// force next poll to wake up immediately</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;N</code>的解释</p><ol><li>当前将会保留一个时间，作为ANR检查开始的计时时间: <strong>currentTime</strong></li><li>将会判断 <code>mPendingEvent</code> 有没有值，有没有 <code>pending</code> 的输入事件需要处理。没有则需要从 <code>mInboundQueue</code> 队头取一个事件出来处理， <code>mInboundQueue</code> 则为一个收集所有事件的队列，包括，按键 滑动 等等一系列事件。通过 <code>InputDispatcher</code> 模块中的notifyXXXXX()，将事件放入 <code>connection。outboundQueue</code> 队列中。</li><li><code>pokeUserActivityLocked</code> 会调用到 <code>PowerManagerService</code> 中的 <code>updatePowerStateLocked()</code>函数中，主要作用就是通知<code>power</code>服务，更新服务状态不要休眠相关。</li><li>下面就根据 <code>pendingEvent</code> 的类型对事件进行派发 <code>dispatchXXXXLocked</code>(currentTime&#x2F;ANR计时时间&#x2F;, )，并且将会返回一个事件处理的结果值 done</li><li>根据处理结果 <code>done</code> 的值(true-事件处理完 false-事件未处理完)，处理完则需要将事件释放掉 并且将 <code>mPendingEvent</code> 置空</li></ol><h3 id="dispatchKeyLocked"><a href="#dispatchKeyLocked" class="headerlink" title="dispatchKeyLocked"></a>dispatchKeyLocked</h3><p>我们选择<code>key</code>事件派发流程来讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, std::shared_ptr&lt;KeyEntry&gt; entry,<br>                                        DropReason* dropReason, nsecs_t* nextWakeupTime) &#123;<br>    <span class="hljs-comment">//...省略</span><br><br>    <span class="hljs-comment">// Identify targets.</span><br>    std::vector&lt;InputTarget&gt; inputTargets;<br>    <span class="hljs-comment">//寻找焦点窗口</span><br>    <span class="hljs-type">InputEventInjectionResult</span> <span class="hljs-variable">injectionResult</span> <span class="hljs-operator">=</span><br>            findFocusedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime);<br>    <span class="hljs-keyword">if</span> (injectionResult == InputEventInjectionResult::PENDING) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//pending事件未被处理,代表焦点窗口还没找到,有可能是ANR或者其他原因</span><br>    &#125;<br><br>    setInjectionResult(*entry, injectionResult);<br>    <span class="hljs-keyword">if</span> (injectionResult != InputEventInjectionResult::SUCCEEDED) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Add monitor channels from event&#x27;s or focused display.</span><br>    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));<br><br>    <span class="hljs-comment">// Dispatch the key.分发此事件</span><br>    dispatchEventLocked(currentTime, entry, inputTargets);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>省略部分和该种情况<code>ANR</code>无关的代码(按键重复相关，以及，<code>WMS</code> 对于key事件的拦截，感兴趣自行了解)<br>这里解读一下查找焦点窗口函数的返回值，返回<code>SUCCEEDED</code>即成功找到焦点窗口，另外下面两种返回值将是异常情况：</p><ul><li><p><strong>PENDING</strong>：</p><ul><li>1 应用已经获得焦点 但是窗口没有焦点，我们将会设置 <code>mNoFocusedWindowTimeoutTime</code> 事件为当前时间+5s，返回pending，(意思代表如果下一次检查过来时候，将会比较当前时间和 <code>mNoFocusedWindowTimeoutTime</code>，如果当前时间大于 <code>mNoFocusedWindowTimeoutTime</code>，就代表发生已经ANR。)这种情况通常打印log: <code>Waiting because no window has focus but XXX may eventually add a window when it finishes starting up。 Will wait for XXX ms&quot;</code></li><li>2 另外一种就是上面说的另一种情况 如果当前时间 小于 <code>mNoFocusedWindowTimeoutTime</code>，意思就是寻找焦点窗口还未超时，继续<code>pending</code>，不打印log</li><li>3 焦点窗口找到了，但是本来焦点窗口就处于<code>paused</code>状态，这个时候也返回<code>pending</code>，这种情况会打印log: <code>Waiting because XXX is paused</code></li><li>4 最后一种情况是，派发的是按键事件，如果这里将要特殊处理，因为原则是:如果是按键事件，那么焦点窗口之前还未处理的其他事件必须处理完:(<u>如果分发一个按键事件，给一个窗口，那么这个窗口之前的<code>input</code>事件必须处理完，因为之前的事件可能改变焦点到另外一个窗口。 确保，key 事件被派发找正确的焦点窗口中，如果之前的事件未处理完，那么此key事件将<code>pending</code>，处理完之前的事件后再次发送</u>)</li></ul></li><li><p><strong>FAILED</strong>：</p><ul><li>如果当前应用程序没有焦点并且也没有焦点窗口，这将会返回 FAILED，并且该input事件将被丢掉，将打印log： <code>Dropping XXX  event because there is no focused window or focused application in DisplayId</code></li><li>另外一种返回failed情况即 上面PENDING 情况1的括号部分，已经出现ANR;log将会打印log：<code>Dropping XXX event because there is no focused window</code></li></ul></li></ul><p>上面的两种返回值的逻辑在函数：<code>findFocusedWindowTargetsLocked</code>中，如下：</p><h3 id="findFocusedWindowTargetsLocked"><a href="#findFocusedWindowTargetsLocked" class="headerlink" title="findFocusedWindowTargetsLocked"></a>findFocusedWindowTargetsLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java">InputEventInjectionResult InputDispatcher::findFocusedWindowTargetsLocked(<br>        nsecs_t currentTime, const EventEntry&amp; entry, std::vector&lt;InputTarget&gt;&amp; inputTargets,<br>        nsecs_t* nextWakeupTime) &#123;<br>    std::string reason;<br><br>    <span class="hljs-type">int32_t</span> <span class="hljs-variable">displayId</span> <span class="hljs-operator">=</span> getTargetDisplayId(entry);<br>    <span class="hljs-comment">// mFocusedWindowHandlesByDisplay在setInputWindowsLocked()里赋值</span><br>    sp&lt;InputWindowHandle&gt; focusedWindowHandle = getFocusedWindowHandleLocked(displayId);<br>    <span class="hljs-comment">// mFocusedApplicationHandlesByDisplay在setFocusedApplication()里赋值</span><br>    std::shared_ptr&lt;InputApplicationHandle&gt; focusedApplicationHandle =<br>            getValueByKey(mFocusedApplicationHandlesByDisplay, displayId);<br><br>    <span class="hljs-comment">//如果当前没有焦点窗口和焦点应用程序，则删除该事件。</span><br>    <span class="hljs-keyword">if</span> (focusedWindowHandle == nullptr &amp;&amp; focusedApplicationHandle == nullptr) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Dropping %s event because there is no focused window or focused application in &quot;</span><br>              <span class="hljs-string">&quot;display %&quot;</span> PRId32 <span class="hljs-string">&quot;.&quot;</span>,<br>              NamedEnum::string(entry.type).c_str(), displayId);<br>        <span class="hljs-keyword">return</span> InputEventInjectionResult::FAILED;<br>    &#125;<br><br>    <span class="hljs-comment">// Compatibility behavior: raise ANR if there is a focused application, but no focused window.</span><br>    <span class="hljs-comment">// Only start counting when we have a focused event to dispatch. The ANR is canceled if we</span><br>    <span class="hljs-comment">// start interacting with another application via touch (app switch). This code can be removed</span><br>    <span class="hljs-comment">// if the &quot;no focused window ANR&quot; is moved to the policy. Input doesn&#x27;t know whether</span><br>    <span class="hljs-comment">// an app is expected to have a focused window.</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    兼容性行为：</span><br><span class="hljs-comment">    如果存在焦点应用程序但没有焦点窗口，则引发 ANR。</span><br><span class="hljs-comment">    只有当我们有重点事件要调度时，才开始计数。</span><br><span class="hljs-comment">    如果我们开始通过触摸（app switch）与另一个应用程序交互，则 ANR 将被取消。</span><br><span class="hljs-comment">    如果将“无焦点窗口 ANR”移动到policy中，则可以删除此代码。输入不知道应用是否应具有焦点窗口。</span><br><span class="hljs-comment">    ---开始ANR检查</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (focusedWindowHandle == nullptr &amp;&amp; focusedApplicationHandle != nullptr) &#123;<br>        <span class="hljs-keyword">if</span> (!mNoFocusedWindowTimeoutTime.has_value()) &#123;<br>            <span class="hljs-comment">// 默认mNoFocusedWindowTimeoutTime没有值，第一次检查ANR会走下面这个流程</span><br><br>            <span class="hljs-comment">// DEFAULT_INPUT_DISPATCHING_TIMEOUT = 5s * HwTimeoutMultiplier();</span><br>            <span class="hljs-comment">// 默认input dispatch timeout时间时5s</span><br>            std::chrono::<span class="hljs-type">nanoseconds</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> focusedApplicationHandle-&gt;getDispatchingTimeout(<br>                    DEFAULT_INPUT_DISPATCHING_TIMEOUT);<br>            <span class="hljs-comment">// 给mNoFocusedWindowTimeoutTime赋值，触发ANR时会检查这个值是否为空，不为空才触发ANR</span><br>            mNoFocusedWindowTimeoutTime = currentTime + timeout.count();<br>            <span class="hljs-comment">// 把当前的focusedApplicationHandle赋值给mAwaitedFocusedApplication，</span><br>            <span class="hljs-comment">//触发ANR时会检查这个值是否为空，不为空才触发ANR</span><br>            mAwaitedFocusedApplication = focusedApplicationHandle;<br>            mAwaitedApplicationDisplayId = displayId;<br>            ALOGW(<span class="hljs-string">&quot;Waiting because no window has focus but %s may eventually add a &quot;</span><br>                  <span class="hljs-string">&quot;window when it finishes starting up. Will wait for %&quot;</span> PRId64 <span class="hljs-string">&quot;ms&quot;</span>,<br>                  mAwaitedFocusedApplication-&gt;getName().c_str(), millis(timeout));<br>            *nextWakeupTime = *mNoFocusedWindowTimeoutTime;<br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentTime &gt; *mNoFocusedWindowTimeoutTime) &#123;<br>            <span class="hljs-comment">// Already raised ANR. Drop the event</span><br>            ALOGE(<span class="hljs-string">&quot;Dropping %s event because there is no focused window&quot;</span>,<br>                  NamedEnum::string(entry.type).c_str());<br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::FAILED;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Still waiting for the focused window</span><br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// we have a valid, non-null focused window</span><br>    <span class="hljs-comment">//到这则说明没有ANR</span><br>    <span class="hljs-comment">// // 如果走到这个流程，说明没有ANR，清空mNoFocusedWindowTimeoutTime和mAwaitedFocusedApplication</span><br>    resetNoFocusedWindowTimeoutLocked();<br><br>    <span class="hljs-comment">// Check permissions.</span><br>    <span class="hljs-keyword">if</span> (!checkInjectionPermission(focusedWindowHandle, entry.injectionState)) &#123;<br>        <span class="hljs-keyword">return</span> InputEventInjectionResult::PERMISSION_DENIED;<br>    &#125;<br>    <span class="hljs-comment">//窗口暂停</span><br>    <span class="hljs-keyword">if</span> (focusedWindowHandle-&gt;getInfo()-&gt;paused) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Waiting because %s is paused&quot;</span>, focusedWindowHandle-&gt;getName().c_str());<br>        <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>    &#125;<br><br>    <span class="hljs-comment">// If the event is a key event, then we must wait for all previous events to</span><br>    <span class="hljs-comment">// complete before delivering it because previous events may have the</span><br>    <span class="hljs-comment">// side-effect of transferring focus to a different window and we want to</span><br>    <span class="hljs-comment">// ensure that the following keys are sent to the new window.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Suppose the user touches a button in a window then immediately presses &quot;A&quot;.</span><br>    <span class="hljs-comment">// If the button causes a pop-up window to appear then we want to ensure that</span><br>    <span class="hljs-comment">// the &quot;A&quot; key is delivered to the new pop-up window.  This is because users</span><br>    <span class="hljs-comment">// often anticipate pending UI changes when typing on a keyboard.</span><br>    <span class="hljs-comment">// To obtain this behavior, we must serialize key events with respect to all</span><br>    <span class="hljs-comment">// prior input events.</span><br>    <span class="hljs-comment">/*如果分发一个按键事件,给一个窗口,那么这个窗口之前的input事件必须处理完,因为之前的事件可能改变焦点到另外一个窗口</span><br><span class="hljs-comment">    确保,key 事件被派发找正确的焦点窗口中,如果之前的事件未处理完,那么此key事件将pending,处理完之前的事件后再次发送*/</span><br>    <span class="hljs-keyword">if</span> (entry.type == EventEntry::Type::KEY) &#123;<br>        <span class="hljs-keyword">if</span> (shouldWaitToSendKeyLocked(currentTime, focusedWindowHandle-&gt;getName().c_str())) &#123;<br>            *nextWakeupTime = *mKeyIsWaitingForEventsTimeout;<br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Success!  Output targets.找到派发目标</span><br>    addWindowTargetLocked(focusedWindowHandle,<br>                          InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS,<br>                          BitSet32(<span class="hljs-number">0</span>), inputTargets);<br><br>    <span class="hljs-comment">// Done.</span><br>    <span class="hljs-keyword">return</span> InputEventInjectionResult::SUCCEEDED;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数内容，涉及其他方面，可能看起来没那么容易理解， 我将判断<code>no focuse Window ANR</code>关键的部分抽出来(&#x2F;&#x2F; …表示已去除部分)<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">InputEventInjectionResult <span class="hljs-title">InputDispatcher::findFocusedWindowTargetsLocked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> currentTime, <span class="hljs-type">const</span> EventEntry&amp; entry, std::vector&lt;InputTarget&gt;&amp; inputTargets,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;<br>    std::string reason;<br><br>    <span class="hljs-type">int32_t</span> displayId = <span class="hljs-built_in">getTargetDisplayId</span>(entry);<br>    <span class="hljs-comment">// mFocusedWindowHandlesByDisplay在setInputWindowsLocked()里赋值</span><br>    sp&lt;InputWindowHandle&gt; focusedWindowHandle = <span class="hljs-built_in">getFocusedWindowHandleLocked</span>(displayId);<br>    <span class="hljs-comment">// mFocusedApplicationHandlesByDisplay在setFocusedApplication()里赋值</span><br>    std::shared_ptr&lt;InputApplicationHandle&gt; focusedApplicationHandle =<br>            <span class="hljs-built_in">getValueByKey</span>(mFocusedApplicationHandlesByDisplay, displayId);<br><br>    <span class="hljs-comment">//...如果当前没有焦点窗口和焦点应用程序，则删除该事件。</span><br>    <br>    <span class="hljs-comment">/*兼容性行为：</span><br><span class="hljs-comment">    如果存在焦点应用程序但没有焦点窗口，则引发 ANR。</span><br><span class="hljs-comment">    只有当我们有重点事件要调度时，才开始计数。</span><br><span class="hljs-comment">    如果我们开始通过触摸（app switch）与另一个应用程序交互，则 ANR 将被取消。</span><br><span class="hljs-comment">    如果将“无焦点窗口 ANR”移动到policy中，则可以删除此代码。输入不知道应用是否应具有焦点窗口。</span><br><span class="hljs-comment">    ---开始ANR检查</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (focusedWindowHandle == <span class="hljs-literal">nullptr</span> &amp;&amp; focusedApplicationHandle != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!mNoFocusedWindowTimeoutTime.<span class="hljs-built_in">has_value</span>()) &#123;<br>            <span class="hljs-comment">// 默认mNoFocusedWindowTimeoutTime没有值，第一次检查ANR会走下面这个流程</span><br><br>            <span class="hljs-comment">// DEFAULT_INPUT_DISPATCHING_TIMEOUT = 5s * HwTimeoutMultiplier();</span><br>            <span class="hljs-comment">// 默认input dispatch timeout时间时5s</span><br>            std::chrono::nanoseconds timeout = focusedApplicationHandle-&gt;<span class="hljs-built_in">getDispatchingTimeout</span>(<br>                    DEFAULT_INPUT_DISPATCHING_TIMEOUT);<br>            <span class="hljs-comment">// 给mNoFocusedWindowTimeoutTime赋值，触发ANR时会检查这个值是否为空，不为空才触发ANR</span><br>            mNoFocusedWindowTimeoutTime = currentTime + timeout.<span class="hljs-built_in">count</span>();<br>            <span class="hljs-comment">// 把当前的focusedApplicationHandle赋值给mAwaitedFocusedApplication，</span><br>            <span class="hljs-comment">//processAnrsLocked检查,ANR时会检查这个值是否为空，不为空才触发ANR</span><br>            mAwaitedFocusedApplication = focusedApplicationHandle;<span class="hljs-comment">//&lt;&lt;这里是关键</span><br>            mAwaitedApplicationDisplayId = displayId;<br>            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Waiting because no window has focus but %s may eventually add a &quot;</span><br>                  <span class="hljs-string">&quot;window when it finishes starting up. Will wait for %&quot;</span> PRId64 <span class="hljs-string">&quot;ms&quot;</span>,<br>                  mAwaitedFocusedApplication-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">millis</span>(timeout));<br>            *nextWakeupTime = *mNoFocusedWindowTimeoutTime;<br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentTime &gt; *mNoFocusedWindowTimeoutTime) &#123;<br>            <span class="hljs-comment">// 已经发生ANR,并且需要丢掉该事件</span><br>            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Dropping %s event because there is no focused window&quot;</span>,<br>                  NamedEnum::<span class="hljs-built_in">string</span>(entry.type).<span class="hljs-built_in">c_str</span>());<br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::FAILED;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 继续等待焦点窗口</span><br>            <span class="hljs-keyword">return</span> InputEventInjectionResult::PENDING;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...窗口没有权限</span><br>    <span class="hljs-comment">//...窗口是paused</span><br>    <span class="hljs-comment">//...key事件派发 pending</span><br>    <span class="hljs-comment">//...成功找到焦点窗口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从代码转述过来就是：<br>当第一次进来寻找焦点窗口时候，我设定一个时间值(<code>current+5s</code>)，当下一次或者第次过来获取焦点时候，判断是否获取到焦点窗口，如果还获取不到，那么就比较当前时间值是否超过之前设定的时间值。如果超时，那么就已经发生<code>ANR</code>了(这里不要误解，是指已经发生该类型<code>ANR</code>了，这里不是判断该种ANR的地方，只为了出现ANR后，后面的事件需要被<code>drop</code>丢掉而判断的)，需要将事件丢掉</p><p>从中看出流程的关键在于，变量 </p><ul><li><code>focusedWindowHandle== null</code></li><li><code>focusedApplicationHandle != null</code><br>这个条件成立，并且超时，才会赋值<code>mAwaitedFocusedApplication</code>，这个变量代表有等待获取焦点的<code>Application</code>，并且设置 <code>mNoFocusedWindowTimeoutTime</code> 时间，</li></ul><p><code>dispatchOnce()</code>中后面的anr检查<code>processAnrsLocked()</code>流程通过上面两个值的设定判断是否可能出现ANR</p><p>回到<code>dispatchOnce()</code>中的ANR检查流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnce</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;<br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        <span class="hljs-comment">//...事件派发</span><br>        <span class="hljs-comment">//检查是否发生ANR.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> nextAnrCheck = <span class="hljs-built_in">processAnrsLocked</span>();<span class="hljs-comment">//&lt;&lt;&lt;</span><br>        nextWakeupTime = std::<span class="hljs-built_in">min</span>(nextWakeupTime, nextAnrCheck);<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>检查我们是否正在等待一个聚焦窗口出现。如果等待时间过长，请发出 <code>ANR</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">nsecs_t</span> <span class="hljs-title">InputDispatcher::processAnrsLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">nsecs_t</span> nextAnrCheck = LONG_LONG_MAX;<br>    <span class="hljs-comment">// 在findFocusedWindowTargetsLocked()中，</span><br>    <span class="hljs-comment">// 如果focusedWindowHandle为空，focusedApplicationHandle不为空，以下条件就会满足</span><br>    <span class="hljs-keyword">if</span> (mNoFocusedWindowTimeoutTime.<span class="hljs-built_in">has_value</span>() &amp;&amp; mAwaitedFocusedApplication != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// 第一次查找焦点窗口时候会设置 mNoFocusedWindowTimeoutTime 的值,如果当前时间超过了这个值</span><br>        <span class="hljs-comment">// 则代表寻找焦点窗口超时了,</span><br>        <span class="hljs-keyword">if</span> (currentTime &gt;= *mNoFocusedWindowTimeoutTime) &#123;<br>            <span class="hljs-comment">// 触发ANR流程，此处触发的ANR类型是xxx does not have a focused window</span><br>            <span class="hljs-built_in">processNoFocusedWindowAnrLocked</span>();<br>            mAwaitedFocusedApplication.<span class="hljs-built_in">reset</span>();<br>            mNoFocusedWindowTimeoutTime = std::<span class="hljs-literal">nullopt</span>;<br>            <span class="hljs-keyword">return</span> LONG_LONG_MIN;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//焦点还未找到,等待,并且将这期间的event事件 丢掉,并将下一次ANR检查时间设置为mNoFocusedWindowTimeoutTime</span><br>            <span class="hljs-comment">// Keep waiting. We will drop the event when mNoFocusedWindowTimeoutTime comes.</span><br>            nextAnrCheck = *mNoFocusedWindowTimeoutTime;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//..其他ANR</span><br>&#125;<br></code></pre></td></tr></table></figure><p>流程:<br>即之前事件派发过程中，获取焦点窗口过程中，设置了两个变量，通过变量判断是否可能出现ANR　<br>当前时间超过了设置获取焦点时设置的时间(<code>mNoFocusedWindowTimeoutTime</code><br>)，<code>mAwaitedFocusedApplication</code> 还为空，还没有获取焦点的<code>window</code>.则可能要发出一个ANR。</p><p>详细见 <code>processNoFocusedWindowAnrLocked()</code></p><h3 id="processNoFocusedWindowAnrLocked"><a href="#processNoFocusedWindowAnrLocked" class="headerlink" title="processNoFocusedWindowAnrLocked"></a>processNoFocusedWindowAnrLocked</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 如果没有聚焦窗口，请发出 ANR。</span><br><span class="hljs-comment"> * 在发出 ANR 之前，请执行最终状态检查：</span><br><span class="hljs-comment"> * 1.当前关注的应用程序必须与我们正在等待的应用程序相同。</span><br><span class="hljs-comment"> * 2.确保我们仍然没有聚焦窗口。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::processNoFocusedWindowAnrLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 检查应用是否仍是刚刚获取焦点的应用,不是则可能我们用户切换应用了</span><br>    std::shared_ptr&lt;InputApplicationHandle&gt; focusedApplication =<br>            <span class="hljs-built_in">getValueByKey</span>(mFocusedApplicationHandlesByDisplay, mAwaitedApplicationDisplayId);<br>    <span class="hljs-keyword">if</span> (focusedApplication == <span class="hljs-literal">nullptr</span> ||<br>        focusedApplication-&gt;<span class="hljs-built_in">getApplicationToken</span>() !=<br>                mAwaitedFocusedApplication-&gt;<span class="hljs-built_in">getApplicationToken</span>()) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Waited for a focused window, but focused application has already changed to %s&quot;</span>,<br>              focusedApplication-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// The focused application has changed.</span><br>    &#125;<br><br>    <span class="hljs-type">const</span> sp&lt;InputWindowHandle&gt;&amp; focusedWindowHandle =<br>            <span class="hljs-built_in">getFocusedWindowHandleLocked</span>(mAwaitedApplicationDisplayId);<br>    <span class="hljs-keyword">if</span> (focusedWindowHandle != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// We now have a focused window. No need for ANR.</span><br>    &#125;<br>    <span class="hljs-comment">//走到这就是focusedApplication!=null,focusedWindowHandle == nullptr,触发ANR</span><br>    <span class="hljs-built_in">onAnrLocked</span>(mAwaitedFocusedApplication);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将再次检查，我们之前获取焦点的应用是否还是之前的应用，如果不是则可能用户已经切换应用了，这种情况我们不希望发生ANR<br>打印log:<code>Waited for a focused window, but focused application has already changed to 新的应用包名</code></p><p>下面 <code>onAnrLocked(mAwaitedFocusedApplication)</code> 则就是正式的触发<code>ANR</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 从processNoFocusedWindowAnrLocked()走过来的流程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::onAnrLocked</span><span class="hljs-params">(std::shared_ptr&lt;InputApplicationHandle&gt; application)</span> </span>&#123;<br>    <span class="hljs-comment">// 这个流程走过来的ANR类型是xxx does not have a focused window</span><br>    std::string reason =<br>            <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;%s does not have a focused window&quot;</span>, application-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">updateLastAnrStateLocked</span>(*application, reason);<br><br>    <span class="hljs-comment">// 构建CommandEntry，在dispatchOnce时执行命令</span><br>    std::unique_ptr&lt;CommandEntry&gt; commandEntry = std::<span class="hljs-built_in">make_unique</span>&lt;CommandEntry&gt;(<br>            &amp;InputDispatcher::doNotifyNoFocusedWindowAnrLockedInterruptible);<span class="hljs-comment">//&lt;&lt;&lt;</span><br>    commandEntry-&gt;inputApplicationHandle = std::<span class="hljs-built_in">move</span>(application);<br>    <span class="hljs-comment">// 发送命令到mCommandQueue</span><br>    <span class="hljs-built_in">postCommandLocked</span>(std::<span class="hljs-built_in">move</span>(commandEntry));<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就要思考出现此种类型的ANR的一些原因会是什么呢?</p><p>该种类型的ANR主要着重点在于: “我想要给你派发输入事件，由于没有获取焦点的窗口，所以我没法给”，所以此种ANR应该为:事件派发途径受阻。所以问题主要还在于，InputDispater中维护的两个相关焦点的成员。</p><ol><li><strong>mFocusedApplicationHandlesByDisplay</strong> ： map类型 存放着有焦点的application</li><li><strong>mWindowHandlesByDisplay</strong> ： map类型 存放着displayid的windowhandle</li><li><strong>FocusResolver</strong> ：跟踪每个显示器的焦点窗口并确定焦点变化，和 <code>mWindowHandlesByDisplay</code> 一同可以确定有焦点的window</li></ol><h3 id="mFocusedApplicationHandlesByDisplay"><a href="#mFocusedApplicationHandlesByDisplay" class="headerlink" title="mFocusedApplicationHandlesByDisplay"></a>mFocusedApplicationHandlesByDisplay</h3><ol><li>void onDisplayChanged(…)&lt;—ActivityRecord.java&#x2F;&#x2F;这里将会设置dc.<strong>setFocusedApp</strong>(this)</li><li>onRemovedFromDisplay(…)&lt;—ActivityRecord.java&#x2F;&#x2F;setFocusedApp(null)</li><li>setResumedActivityUncheckLocked(…)&lt;—ActivityTaskManagerService.java&#x2F;&#x2F;  当<strong>resume</strong>一个activity时候将会 final boolean changed &#x3D; r.mDisplayContent.setFocusedApp(r)</li></ol><p>上面三种渠道可以调用到下面的流程</p><blockquote><p>setFocusedApp(ActivityRecord newFocus)&lt;—-DisplayContent.java<br>—setFocusedAppLw(ActivityRecord newApp)&lt;—InputMonitor.java&#x2F;&#x2F;新的ActivityRecord所属的application设置Focused<br>——setFocusedApplication&lt;—inputDispather.cpp<br>———setFocusedApplicationLocked&lt;—inputDispather.cpp<br>————mFocusedApplicationHandlesByDisplay</p></blockquote><p>应用首先要确保 走到resume</p><h3 id="mWindowHandlesByDisplay"><a href="#mWindowHandlesByDisplay" class="headerlink" title="mWindowHandlesByDisplay"></a>mWindowHandlesByDisplay</h3><blockquote><p>—SurfaceFlinger::onMessageInvalidate(int64_t vsyncId, nsecs_t expectedVSyncTime)&lt;—SurfaceFlinger.cpp<br>——SurfaceFlinger::updateInputWindowInfo()&lt;—SurfaceFlinger.cpp<br>———benchmarkNotifyMotion和 setInputWindows&lt;—InputManager.cpp<br>————setInputWindows 和 displayRemoved&lt;—InputDispater.cpp<br>—————setInputWindowsLocked<br>——————updateWindowHandlesForDisplayLocked(        const std::vector&lt;sp<InputWindowHandle>&gt;&amp; inputWindowHandles, int32_t displayId)<br>———————mWindowHandlesByDisplay</p></blockquote><p>将涉及到SurfaceFlinger部分内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::injectorCallback</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-type">ssize_t</span> n;<br>      DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];<br>      <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(&amp;mInjector.tube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>              <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br>                  mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>(buffer[i].vsync.vsyncId,<br>                                               buffer[i].vsync.expectedVSyncTimestamp);<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::vsyncCallback</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> vsyncTime, <span class="hljs-type">nsecs_t</span> targetWakeupTime, <span class="hljs-type">nsecs_t</span> readyTime)</span> </span>&#123;<br>      <span class="hljs-built_in">ATRACE_CALL</span>();<br>      <span class="hljs-comment">// Trace VSYNC-sf</span><br>      mVsync.value = (mVsync.value + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>  <br>      &#123;<br>          <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mVsync.mutex)</span></span>;<br>          mVsync.lastCallbackTime = std::chrono::<span class="hljs-built_in">nanoseconds</span>(vsyncTime);<br>          mVsync.scheduled = <span class="hljs-literal">false</span>;<br>      &#125;<br>      mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>(mVsync.tokenManager-&gt;<span class="hljs-built_in">generateTokenForPredictions</span>(<br>                                           &#123;targetWakeupTime, readyTime, vsyncTime&#125;),<br>                                   vsyncTime);<br>  &#125;<br><br><br><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>(<span class="hljs-type">int64_t</span> vsyncId, <span class="hljs-type">nsecs_t</span> expectedVSyncTimestamp) &#123;<br>      <span class="hljs-keyword">if</span> ((mEventMask.<span class="hljs-built_in">fetch_or</span>(eventMaskInvalidate) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;<br>          mVsyncId = vsyncId;<br>          mExpectedVSyncTime = expectedVSyncTimestamp;<br>          mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="启动一个新的Activity时候会发生焦点的切换"><a href="#启动一个新的Activity时候会发生焦点的切换" class="headerlink" title="启动一个新的Activity时候会发生焦点的切换"></a>启动一个新的Activity时候会发生焦点的切换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">------&gt;system_log<br><span class="hljs-comment">// 根据Intent 启动新的activity</span><br>I ActivityTaskManager: START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.google.android.apps.messaging/.ui.ConversationListActivity bnds=[<span class="hljs-number">193</span>,<span class="hljs-number">1099</span>][<span class="hljs-number">331</span>,<span class="hljs-number">1280</span>]&#125; from uid <span class="hljs-number">10042</span><br>------&gt;events_log<br><span class="hljs-comment">//创建新的Task,id为15,rootTaskid=-1</span><br>I wm_task_created: [<span class="hljs-number">15</span>,<span class="hljs-number">-1</span>] <br><br>------&gt;system_log<br><span class="hljs-comment">//到切换焦点函数的调用栈--scheduleUpdateInputWindows</span><br> I TAG     : TAG-scheduleUpdateInputWindows-TAG<br> I TAG     : java.lang.Throwable<br> I TAG     : at com.android.server.wm.InputMonitor.<span class="hljs-built_in">scheduleUpdateInputWindows</span>(InputMonitor.java:<span class="hljs-number">359</span>)<br> I TAG     : at com.android.server.wm.InputMonitor.<span class="hljs-built_in">updateInputWindowsLw</span>(InputMonitor.java:<span class="hljs-number">348</span>)<br> I TAG     : at com.android.server.wm.DisplayContent.<span class="hljs-built_in">layoutAndAssignWindowLayersIfNeeded</span>(DisplayContent.java:<span class="hljs-number">3590</span>)<br> I TAG     : at com.android.server.wm.Task.<span class="hljs-built_in">onChildPositionChanged</span>(Task.java:<span class="hljs-number">7722</span>)<br> I TAG     : at com.android.server.wm.WindowContainer.<span class="hljs-built_in">onChildAdded</span>(WindowContainer.java:<span class="hljs-number">581</span>)<br> I TAG     : at com.android.server.wm.WindowContainer.<span class="hljs-built_in">setParent</span>(WindowContainer.java:<span class="hljs-number">395</span>)<br> I TAG     : at com.android.server.wm.WindowContainer.<span class="hljs-built_in">addChild</span>(WindowContainer.java:<span class="hljs-number">571</span>)<br> I TAG     : at com.android.server.wm.Task.<span class="hljs-built_in">addChild</span>(Task.java:<span class="hljs-number">1714</span>)<br> I TAG     : at com.android.server.wm.Task.<span class="hljs-built_in">addChild</span>(Task.java:<span class="hljs-number">1759</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">addOrReparentStartingActivity</span>(ActivityStarter.java:<span class="hljs-number">2706</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">setNewTask</span>(ActivityStarter.java:<span class="hljs-number">2683</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">startActivityInner</span>(ActivityStarter.java:<span class="hljs-number">1736</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">startActivityUnchecked</span>(ActivityStarter.java:<span class="hljs-number">1571</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">executeRequest</span>(ActivityStarter.java:<span class="hljs-number">1177</span>)<br> I TAG     : at com.android.server.wm.ActivityStarter.<span class="hljs-built_in">execute</span>(ActivityStarter.java:<span class="hljs-number">665</span>)<br> I TAG     : at com.android.server.wm.ActivityTaskManagerService.<span class="hljs-built_in">startActivityAsUser</span>(ActivityTaskManagerService.java:<span class="hljs-number">1227</span>)<br> I TAG     : at com.android.server.wm.ActivityTaskManagerService.<span class="hljs-built_in">startActivityAsUser</span>(ActivityTaskManagerService.java:<span class="hljs-number">1199</span>)<br> I TAG     : at com.android.server.wm.ActivityTaskManagerService.<span class="hljs-built_in">startActivity</span>(ActivityTaskManagerService.java:<span class="hljs-number">1174</span>)<br> I TAG     : at android.app.IActivityTaskManager$Stub.<span class="hljs-built_in">onTransact</span>(IActivityTaskManager.java:<span class="hljs-number">900</span>)<br> I TAG     : at com.android.server.wm.ActivityTaskManagerService.<span class="hljs-built_in">onTransact</span>(ActivityTaskManagerService.java:<span class="hljs-number">5081</span>)<br> I TAG     : at android.os.Binder.<span class="hljs-built_in">execTransactInternal</span>(Binder.java:<span class="hljs-number">1179</span>)<br> I TAG     : at android.os.Binder.<span class="hljs-built_in">execTransact</span>(Binder.java:<span class="hljs-number">1143</span>)<br><br><br><span class="hljs-comment">//Task移动,Taskid=15,1表示朝顶部移动(如果为0表示朝底部移动),8为角标index</span><br>I wm_task_moved: [<span class="hljs-number">15</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>]<br><span class="hljs-comment">//taskid=15的task 被带到前台,显示在最前面,即屏幕</span><br>I wm_task_to_front: [<span class="hljs-number">0</span>,<span class="hljs-number">15</span>]<br><span class="hljs-comment">//一个新的task正在创建,userId=0,taskid=15</span><br>I wm_create_task: [<span class="hljs-number">0</span>,<span class="hljs-number">15</span>]<br><span class="hljs-comment">//创建一个activity</span><br>I wm_create_activity: [<span class="hljs-number">0</span>,<span class="hljs-number">60142361</span>,<span class="hljs-number">15</span>,com.google.android.apps.messaging/.ui.ConversationListActivity,android.intent.action.MAIN,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">270532608</span>]<br>I wm_task_moved: [<span class="hljs-number">15</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>]<br>I wm_pause_activity: [<span class="hljs-number">0</span>,<span class="hljs-number">96699712</span>,com.TAG.launcher/com.android.searchlauncher.SearchLauncher,userLeaving=<span class="hljs-literal">true</span>,pauseBackTasks]<br>I wm_on_top_resumed_lost_called: [<span class="hljs-number">96699712</span>,com.android.searchlauncher.SearchLauncher,topStateChangedWhenResumed]<br>I wm_on_paused_called: [<span class="hljs-number">96699712</span>,com.android.searchlauncher.SearchLauncher,performPause]<br>I wm_add_to_stopping: [<span class="hljs-number">0</span>,<span class="hljs-number">96699712</span>,com.TAG.launcher/com.android.searchlauncher.SearchLauncher,makeInvisible]<br></code></pre></td></tr></table></figure><p>焦点窗口更新相关 <a href="https://juejin.cn/post/6955857985151336484">https://juejin.cn/post/6955857985151336484</a></p><hr><p>NoFocusedWindowANR </p><ul><li>需确认 Input 的焦点是否正确切换： </li><li>− 如果 Input 焦点正确切换，则需要检查窗口信息是否正确。 窗口信息是 WMS 设置，由 SurfaceFlinger 传入，可以查看 Log 中 Layer 信息以及发生 ANR 后 dump 的窗口信息，来判断窗口信息是否正常。 </li><li>− 如果 Input 焦点未正确切换，需要查看应用生命周期等情况。</li></ul><hr><h3 id="Windowstate获取焦点的条件"><a href="#Windowstate获取焦点的条件" class="headerlink" title="Windowstate获取焦点的条件"></a>Windowstate获取焦点的条件</h3><blockquote><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;DisplayContent.java<br>搜索 mFindFocusedWindow</p></blockquote><ol><li><p>如果<code>WindowState</code>不能接收<code>Input事件</code>，则不能作为焦点窗口；(<br><code>WindowState</code>可以接受<code>Input</code>事件，需要同时满足多个条件)</p><ol><li><code>isVisibleOrAdding()</code>方法为<code>true</code>，表示该<code>WindowState</code>可见或处于添加过程中</li><li><code>mViewVisibility</code>属性为<code>View.VISIBLE</code>，表示客户端View可见；     </li><li><code>mRemoveOnExit</code>为false，表示<code>WindowState</code>的退出动画不存在</li><li><code>mAttrs.flags</code>中不存在<code>FLAG_NOT_FOCUSABLE</code>标记，该标记如果设置，表示该窗口为不可获焦窗口；</li><li><code>mActivityRecord</code>为<code>null</code>或者<code>mActivityRecord</code>可获焦;</li><li><code>cantReceiveTouchInput()</code>方法为<code>false</code>，表示可以接受Touch事件</li></ol></li><li><p>如果没有前台<code>Activity</code>，则当前<code>WindowState</code>作为焦点窗口返回；</p></li><li><p>如果前台<code>Activity</code>是不可获焦状态，则当前<code>WindowState</code>作为焦点窗口返回；</p></li><li><p>如果当前<code>WindowState</code>由<code>ActivityRecord</code>管理，且该<code>WindowState</code>不是<code>Staring Window</code>类型，那么当前台<code>Activity</code>在当前<code>WindowState</code>所属<code>Activity</code>之上时，不存在焦点窗口；</p></li><li><p>如果以上条件都不满足，则当前<code>WindowState</code>作为焦点窗口返回</p></li></ol><p>从上面InputDispatcher侧分析来看，无焦点窗口ANR主要原因点在WMS，只有熟悉WMS后对该类问题才能有更清晰的认识<br>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>机制</category>
      
      <category>ANR</category>
      
      <category>Application_does_not_have_a_focused_window</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统概念原理</tag>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/07/22/hello-world2/"/>
    <url>/2019/07/22/hello-world2/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
